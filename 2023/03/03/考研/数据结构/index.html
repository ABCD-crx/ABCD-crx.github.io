

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/loge/loge.png">
  <link rel="icon" href="/img/loge/loge.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Crx">
  <meta name="keywords" content="C,C++,Java,Vue,Linux,Docker">
  
    <meta name="description" content="408坐牢之旅之小八股的梦境传说">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/2023/03/03/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Chenrx&#39;s Blog">
<meta property="og:description" content="408坐牢之旅之小八股的梦境传说">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/blog/ds.png">
<meta property="article:published_time" content="2023-03-03T01:24:45.000Z">
<meta property="article:modified_time" content="2024-02-24T07:03:36.840Z">
<meta property="article:author" content="Crx">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/blog/ds.png">
  
  
  
  <title>数据结构 - Chenrx&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Chenrx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/background3.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-03 09:24" pubdate>
          2023年3月3日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          293 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-02-24T15:03:36+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">1.数据：是能输入计算机且能被计算机处理的各种符号的集合<br>2.数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理，<br>			也称元素，或者称为结点或顶点<br>			一个数据元素也可若干个数据项组成<br>3.数据项：构成数据元素不可分割的最小单位<br>		数据 &gt; 数据元素 &gt; 数据项<br>4.数据对象：性质相同的数据元素的集合<br>		数据元素——组成数据的基本单位（集合和个体）<br>		数据对象——性质相同的数据元素的集合（集合的子集）<br>5.数据结构：数据元素不是孤立存在的，他们直接存在着某种关系，数据元素相互之间的关系称为结构<br>			（带结构的数据元素的集合）<br>	数据结构包括：<br>		逻辑结构：数据元素之间的逻辑关系<br>		储存结构：数据元素及其关系在计算机内存中的表示（映像），称为数据的物理结构或数据存储结构<br>		数据的运算和实现，即对数据元素可以施加的操作以及这些操作在相应存储结构上的实现<br></code></pre></td></tr></table></figure>

<h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">逻辑结构<br>描述数据元素之间的逻辑关系<br>与数据存储无关，独立与计算机<br>是具体问题抽象出来的数学模型<br><br>物理结构（存储结构）<br>数据元素及其关系在计算机储存器中的结构（储存方式）<br>是数据结构在计算机中的表示<br><br>存储结构是逻辑关系的映像与元素本身的映像<br>逻辑结构是数据的抽象，存储结构是数据的实现<br>两者建立数据元素之间的结构关系<br></code></pre></td></tr></table></figure>

<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">种类<br>1.线性结构：有且仅有一个开始和一个终端节点，并且结点都最多有一个直接前趋和一个直接后继<br>2.非线性结构，一个节点可能有多个直接前趋和直接后继<br><br>第二种划分：<br>1.集合结构<br>2.线性结构：一对一<br>3.树形结构：一对多<br>4.图状结构：多对多<br></code></pre></td></tr></table></figure>

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">种类：<br>顺序存储结构：<br>	用一组<span class="hljs-string">&#x27;连续&#x27;</span>的存储单元依次存储数据元素，数据元素之间的逻辑关系有元素的存储位置来表示（数组）<br>链式存储结构：<br>	用一组<span class="hljs-string">&#x27;任意&#x27;</span>的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示（指针-&gt;地址）<br>    	在存储每一个元素的同时也存储了下一个元素的地址<br></code></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>抽象数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">作用：<br>约束变量或常量的取值范围<br>约束变量或常量的操作<br><br>数据类型：数据类型是一组性质相同的值的集合以及定义于这个值的集合上的一组操作的总称<br>	数据类型 = 值的集合 + 值集合上的一组操作<br><br>抽象数据类型：指一个数学模型以及定义在此数学模型上的一组操作<br>	<br>	定义格式<br>	ADT &lt;抽象数据类型名&gt;&#123;<br>		数据对象：&lt;数据对象的定义&gt;<br>		数据关系：&lt;数据关系的定义&gt;<br>		基本操作：&lt;基本操作的定义&gt;<br>	&#125; ADT 抽象数据类型名<br>    <br>    <br>    基本操作的定义格式为：<br>    基本操作名（参数表）<br>    初始条件：&lt;初始条件描述&gt;<br>	操作结构：&lt;操作结果描述&gt;<br>    <br>	基本操作定义格式说明：<br>    参数表:赋值参数 只为操作操作提供输入值<br>    	  引用参数 以&amp;打头，除可提供输入值外，还将返回操作结果 （类形参 ，加上&amp;取地址，可带回返回值）<br>    <br>    初始条件：描述操作执行前数据结构和参数应满足的条件，若不满足则操作失败，并返回相应出错信息。若初始条件为空，则省略之。<br>    <br>    操作结果：说明操作正常完成之后，数据结构的变化状况和相应的返回结果<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">eg.<br><span class="hljs-comment">//复数</span><br>    ADT Complex&#123;<br>    D = &#123;r1,r2| r1,r2都是实数&#125;<br>    S = &#123;&lt;r1,r2&gt;|r1是实部，r2是虚部&#125;<br>    assign（&amp;C,v1,v2)<br>        初始条件：<br>        操作结果：<br>    destroy(&amp;C)<br>&#125;ADT Complex<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/KFcLWo2gAp8Bl1f.png" srcset="/img/loading.gif" lazyload alt="image-20220315112140283"></p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">抽象数据类型的实现<br>	<span class="hljs-keyword">c</span>语言实现抽象数据类型<br>		用已有的数据定义描述它的存储结构<br>		用函数定义它的操作 <br>			-》在程序中使用<br>类<span class="hljs-keyword">c</span>语言（介于伪码和<span class="hljs-keyword">c</span>语言之间）<br></code></pre></td></tr></table></figure>

<h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs excel">算法的特性：<br><span class="hljs-number">1</span>.有穷性<br><span class="hljs-number">2</span>.确定性<br><span class="hljs-number">3</span>.可行性<br><span class="hljs-number">4</span>.输入（<span class="hljs-number">0</span>个或多个输入）<br><span class="hljs-number">5</span>.输出（<span class="hljs-number">1</span>个或多个输出）<br><br>算法设计的要求：<br><span class="hljs-number">1</span>.正确性 <br><span class="hljs-number">2</span>.可读性<br><span class="hljs-number">3</span>.健壮性<br><span class="hljs-number">4</span>.高效性<br><br>通过算法的效率，来判断算法的优劣<br><span class="hljs-number">1</span>.时间效率，所消耗的时间<br><span class="hljs-number">2</span>.空间效率， 数量级用来衡量算法的复杂度，称为算法的渐进时间复杂度，简称时间复杂度。<br><br>时间复杂度，只看最高次项，不用考虑低次项和系数<br>	方法：<span class="hljs-number">1</span>.找出语句频率最大的那条语句，作为基本语句（嵌套层次最深的）<br>		 <span class="hljs-number">2</span>.计算基本语句的频率得到问题规模<span class="hljs-built_in">n</span>的某个函数f(<span class="hljs-built_in">n</span>)<br>		 <span class="hljs-number">3</span>.取其数量级<br><br>最坏时间复杂度，平均时间复杂度<br><br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/t7CfmrDxKS6dgU9.png" srcset="/img/loading.gif" lazyload alt="image-20220316151905410"></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是具有相同特性的数据元素的一个有限序列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">由 n(n&gt;=<span class="hljs-number">0</span>)个数据元素（结点）a1，a2，...,an组成的有限序列<br>	首元，线性起点（起始节点）<br>	线性终点，终端结点<br>	直接前趋，直接后继<br>	<br>	数据元素的个数n定义为表的长度<br>	当n=<span class="hljs-number">0</span> 时为空表<br>	<br>	<span class="hljs-string">&#x27;同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系&#x27;</span><br></code></pre></td></tr></table></figure>

<p>线性表的类型定义</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">抽象数据类型 <span class="hljs-variable">ADT</span><br><span class="hljs-variable">ADT</span> <span class="hljs-built_in">List</span><span class="hljs-punctuation">&#123;</span><br>	数据对象：<span class="hljs-built_in">D</span><span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>	数据关系：<br>	基本操作：<br><span class="hljs-punctuation">&#125;</span><span class="hljs-variable">ADT</span> <span class="hljs-built_in">List</span><br></code></pre></td></tr></table></figure>

<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>初始化 <br>	lnitList(&amp;L) 操作结果：构造一个空的线性表L<br><span class="hljs-number">2.</span>删除<br>	DestroyList(&amp;L)<br>		条件：线性表L存在	结果：销毁线性表L。<br><span class="hljs-number">3.</span>清除<br>	ClearLIst(&amp;L)	<br>		将线性表L置为空表<br><span class="hljs-number">4.</span>判断线性表是否为空<br>	ListEmpty(L)<br>		结果：若线性表为L为空表，则返回<span class="hljs-literal">true</span>;否则返回False<br><span class="hljs-number">5.</span>求线性表的长度<br>    ListLength(L)<br>        结果：返回线性表L中的数据元素个数<br><span class="hljs-number">6.</span>获取元素<br>	GetElem(L,i,&amp;e);<br>		<span class="hljs-number">1</span>&lt;=i&lt;= ListLength(L)<br>        结果：用e返回线性表L中第i个数据元素的值<br><span class="hljs-number">7.</span>查找<br>	LocateElem(L,e,compare())<br>		compare()是元素判定函数<br>        结果：返回L中第<span class="hljs-number">1</span>个与e满足 compare()的数据元素 的位序。若不存在则返回值为<span class="hljs-number">0</span><br><span class="hljs-number">8.</span>获取一个元素的前驱<br>   	PriorElem(L,cur_e, &amp;pre_e)<br>		结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义<br><span class="hljs-number">9.</span>获取一个元素的后继<br>	NextElem(L,cur_e,&amp;next_e)<br>    	结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败<br><span class="hljs-number">10.</span>在线性表中插入一个元素<br>	Listnsert(&amp;L,i,e)<br>		<span class="hljs-number">1</span> &lt;= i &lt;= ListLength(L)+<span class="hljs-number">1</span><br>		结果：在L的第i个位置插入新的数据元素，L长度加<span class="hljs-number">1</span><br><span class="hljs-number">11.</span>删除线性表中的元素<br>	ListDelete(&amp;L,i,&amp;e)<br>		<span class="hljs-number">1</span> &lt;=i &lt;= ListLength(L)<br>        结果：删除L的第i个数据元素，并用e返回其值，L的长度减一<br><span class="hljs-number">12.</span>遍历线性表<br>	ListTraverse(&amp;L,visited())<br>        依次对线性表中的每个元素调用visited()<br>		<br></code></pre></td></tr></table></figure>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>——线性表的顺序表示</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">顺序存储的定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构占用一片连续的存储空间，<span class="hljs-comment">(知道一个元素存储单元存储位置，可以通过计算知道其他元素位置)</span><br>	特点：<br>		以物理位置相邻表示逻辑关系，任一元素位置均可随机存取。<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">数组长度需要变化，c89不支持可变长度，c99好像支持<br>	<br>	数组长度不可变时，可以用变量表示顺序表的长度属性<br>    <br>初始化模板：（类c）	<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;		<span class="hljs-comment">//数据类型定义也可使用 typedef 进行预编译</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        ElemType elem[LIST_INIT_SIZE];		<span class="hljs-comment">//ElemType 代表元素类型（int...)</span><br>        <span class="hljs-type">int</span> length;<br>    &#125;Sqlist;<br><br>eg.也可用结构体嵌套定义数据类型<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	<span class="hljs-type">float</span> p;<br>	<span class="hljs-type">int</span> e;<br>	&#125;Polynomial;<br>	<br>	<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        Polynomial *elem;		<span class="hljs-comment">// *data 定义数组第一个元素的地址，后续由动态分布，分布空间</span><br>        <span class="hljs-type">int</span> length;<br>    &#125;SqList;<br></code></pre></td></tr></table></figure>

<h3 id="c语言的内存动态分配"><a href="#c语言的内存动态分配" class="headerlink" title="c语言的内存动态分配"></a>c语言的内存动态分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">ElemType data[MaxSize] 			<span class="hljs-comment">//数组静态分配</span><br><br>ElemType *data					<span class="hljs-comment">//数组动态分配</span><br>    L.data=(Elemtype*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize); <span class="hljs-comment">//ElemType可以是变量也可以是类型</span><br><span class="hljs-comment">//malloc(sizeof(ElemType)*MaxSize) 开辟 一个长度 * 总数 的长度空间</span><br><span class="hljs-comment">//(Elemtype*)，通过类型将分配的长空间，化成小单位</span><br><span class="hljs-comment">//(xxx*)  ()是强制类型转化，这里转化成指向xxx类型的指针(原因：*data)</span><br>		eg.(<span class="hljs-type">int</span>*)表示强制转化为指向整型的指针<br><br>内存分配函数：<br>    <span class="hljs-built_in">malloc</span>(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址<br>    <span class="hljs-keyword">sizeof</span>(X)运算，计算变量x的长度<br>    <span class="hljs-built_in">free</span>(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量<br><span class="hljs-comment">//注：需要声明头文件&lt;stdlib.h&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="c-的动态存储分配"><a href="#c-的动态存储分配" class="headerlink" title="c++的动态存储分配"></a>c++的动态存储分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> 类型名<span class="hljs-built_in">T</span> (初值列表)			eg. <span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> / <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    申请用于存放T类型对象的内存空间，并依初值列表赋初值<br>    结果值：<br>        	成功：T类型的指针，指向新分配的内存<br>        	失败：<span class="hljs-number">0</span> （<span class="hljs-literal">NULL</span>）<br><span class="hljs-keyword">delete</span> 指针P<br>    释放指针p所指向的内存，P必须是<span class="hljs-keyword">new</span>操作的返回值<br><br>c++ 创建动态数组<br>		<span class="hljs-type">int</span> *type = <span class="hljs-keyword">new</span> type[n];<br>		<span class="hljs-keyword">delete</span>[]type<br></code></pre></td></tr></table></figure>

<h3 id="c-中的参数传递"><a href="#c-中的参数传递" class="headerlink" title="c++中的参数传递"></a>c++中的参数传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">实参与形参 类型,个数，顺序 必须一致<br><br>参数传递的两种方式：<br>	<span class="hljs-number">1.</span>传值方式(参数为整形，实型，字符型),（	形参改变，实参不变）<br>    <span class="hljs-number">2.</span>传地址<br>    	参数为指针变量<br>    	参数为引用类型 <span class="hljs-comment">//c++ 新增</span><br>    	参数为数组名<br><br>引用类型作参数<br>    引用：用来给一个对象提供一个代替的名字<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-type">int</span> i=<span class="hljs-number">5</span>；<br>        <span class="hljs-type">int</span> &amp;j=i;			<span class="hljs-comment">//j是一个引用类型，代表i的一个替代名i值改变时，j值也跟着改变</span><br>    	i=<span class="hljs-number">7</span>;<br>    	cout&lt;&lt; <span class="hljs-string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;j= &quot;</span> &lt;&lt; j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span>&amp; m ,<span class="hljs-type">float</span>&amp; n)</span></span>&#123;&#125;		<span class="hljs-comment">//对形参操作相当于对实参操作</span><br><br><span class="hljs-number">1.</span>传递引用给函数与传递指针的效果时一样的<br><span class="hljs-number">2.</span>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作；而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值是实参变量的副本。所以，传递参数数据量较大时，引用比用一般变量传递参数的时间和空间效率都好。<br></code></pre></td></tr></table></figure>

<h3 id="线性表基本实现"><a href="#线性表基本实现" class="headerlink" title="线性表基本实现"></a>线性表基本实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZEE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *elem;		<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;		<span class="hljs-comment">//定义顺序表的类型</span><br><br>SqList L;		<span class="hljs-comment">//定义变量，分配内存空间</span><br><br><br><span class="hljs-comment">//函数结果状态代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	TRUE	1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	FALSAE	0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	OK		1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	ERROR	0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	INFEASIBLE	-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW	-2</span><br><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;<br></code></pre></td></tr></table></figure>

<h4 id="线性表的初始化"><a href="#线性表的初始化" class="headerlink" title="线性表的初始化"></a>线性表的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//伪代码</span><br><span class="hljs-function">Status <span class="hljs-title">lnitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;					<span class="hljs-comment">//构造一个空的顺序表L</span><br>	L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE];				<span class="hljs-comment">//为顺序表分配空间C++</span><br>	<span class="hljs-keyword">if</span>(!L.elem)	<span class="hljs-built_in">exit</span>(OVERFLOW);					<span class="hljs-comment">//储存分配失败</span><br>	L.length=<span class="hljs-number">0</span>;									<span class="hljs-comment">//空表长度为0</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="销毁线性表L"><a href="#销毁线性表L" class="headerlink" title="销毁线性表L"></a>销毁线性表L</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(L.elem) <span class="hljs-keyword">delete</span> L.elem;		<span class="hljs-comment">//释放存储空间</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="清空线性表L"><a href="#清空线性表L" class="headerlink" title="清空线性表L"></a>清空线性表L</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>	L.length = <span class="hljs-number">0</span>; 				<span class="hljs-comment">//将线性表的长度置为0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="求线性表长度"><a href="#求线性表长度" class="headerlink" title="求线性表长度"></a>求线性表长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>	<span class="hljs-keyword">return</span>(L.length);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判断线性表L是否为空"><a href="#判断线性表L是否为空" class="headerlink" title="判断线性表L是否为空"></a>判断线性表L是否为空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取第i个元素"><a href="#获取第i个元素" class="headerlink" title="获取第i个元素"></a>获取第i个元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>|i&gt;L.length) <span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//判断i值是否合理，不合理返回ERROR</span><br>	e = L.elem[i<span class="hljs-number">-1</span>];	<span class="hljs-comment">//i-1的单元存储第i个元素</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">算法思想<br><span class="hljs-number">1</span>.插入位置<span class="hljs-selector-tag">i</span>是否合法。<br><span class="hljs-number">2</span>.判断顺序表的存储空间是否已满，若已满返回ERROR<br><span class="hljs-number">3</span>.将第n至第<span class="hljs-selector-tag">i</span>位的元素依次向后移动一个位置，空出第<span class="hljs-selector-tag">i</span>个位置<br><span class="hljs-number">4</span>.将要插入的新元素e放入第<span class="hljs-selector-tag">i</span>个位置<br><span class="hljs-number">5</span>.表长加<span class="hljs-number">1</span>，插入成功返沪OK。<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Listlnsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i ,ElemType e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//i值不合法  i是位置</span><br>	<span class="hljs-keyword">if</span>(L.length==MAXSIZE) <span class="hljs-keyword">return</span> ERROR;		<span class="hljs-comment">//当前储存空间已满</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span> ;j&gt;=i<span class="hljs-number">-1</span>;j--)<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];	<span class="hljs-comment">//插入位置及之后的元素后移</span><br>    L.elem[i<span class="hljs-number">-1</span>]=e;			<span class="hljs-comment">//将新元素e放入第i个位置</span><br>    L.length++;				<span class="hljs-comment">//表长加1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Eins</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>	平均移动次数  时间复杂度为O(n)<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">List_Insert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i ,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(L.length==MAXSIZE)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;MAXSIZE&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j=L.length<span class="hljs-number">-1</span> ; j&gt;=i<span class="hljs-number">-1</span>; j--)<br>    &#123;<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<br>    &#125;<br>    L.elem[i<span class="hljs-number">-1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><p>算法思想</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.判断删除位置i是否合法（合法值<span class="hljs-number">1</span>&lt;=i&lt;=n)<br><span class="hljs-attribute">2</span>.将欲删除的元素保留在e中（可省）<br><span class="hljs-attribute">3</span>.将第i+<span class="hljs-number">1</span>至第n位的元素依次向前移动一个位置<br><span class="hljs-attribute">4</span>.表长减一，删除成功返回OK<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.Length)) <span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//i值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++)<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];			<span class="hljs-comment">//被删除元素之后的元素前移（后面元素赋值到以前一个）</span><br>    L.length--;<br>    returnOK<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Edel</span><span class="hljs-operator">=</span> (n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>		时间复杂度O(n)<br></code></pre></td></tr></table></figure>

<p>c++代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">List_Delete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;=L.length<span class="hljs-number">-1</span>; j++ )<span class="hljs-comment">//小于还是小于等于需要仔细判断</span><br>    &#123;<br>        L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>——线性表的链式表示</p>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>单链表是由头指针唯一确定，因此单链表可以用头指针的名字来命名</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm">各个结点由两个域组成：<br><span class="hljs-number">1</span>.数据域：存储元素数值数据<br><span class="hljs-number">2</span>.指针域:储存直接后继结点的存储位置<br><br>结点：数据元素的存储映像，由数据域和指针域两部分组成<br>链表：n个结点由指针链组成一个链表，他是线性表的链式存储映像，称为线性表的链式存储结构<br><br>单链表：结点只有一个指针域的链表，称为单链表或者线性链表<br>双链表：结点由两个指针域的链表，称为双链表<br>循环链表：首位相接的链表称为循环链表<br><br>头指针：是指向链表中第一个结点的指针<br>首元节点：是指链表中存储第一个数据元素<span class="hljs-built_in">a1</span>的结点<br>头结点：是在链表的首元结点之前附设的一个结点<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/he2pwcRFrCZIaS3.png" srcset="/img/loading.gif" lazyload alt="image-20220321143557148"></p>
<p>所以链表存储形式有</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.不带头结点<br>2.带头结点<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">空表表示：<br>1.无头结点时，头指针为空时表示空表<br>2.有头节点时，当头结点的指针域为空时表示空表<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">头节点的好处<br>1.便于首元结点的处理<br>		首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作与其他位置一致，无需特殊处理<br>2.便于空表和非空表的统一处理<br>	无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理得到统一<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">头节点的数据域<br>	可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值<br></code></pre></td></tr></table></figure>

<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">链表（链式存储结构）的特点<br>（<span class="hljs-number">1</span>）结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。<br>（<span class="hljs-number">2</span>）访问时只能通过头指针进入链表）井通过每个结点的指针城依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等<br>			链表<span class="hljs-comment">---顺序存取法	（从头开始寻找）</span><br>			顺序表<span class="hljs-comment">---随机存取法（下标直接定位）</span><br></code></pre></td></tr></table></figure>

<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>，带头结点的单链表<br>		单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L<br>	用结构体实现<br>		包括两个成员一个为<span class="hljs-meta">data</span>，一个为next指针 指向结构体地址		<span class="hljs-comment">//嵌套定义</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123;		<span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>	ElemType data;			<span class="hljs-comment">//结点的数据域</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;		<span class="hljs-comment">//结点的指针域</span><br>&#125;Lnode,*LinkList;			<span class="hljs-comment">//LinkList为指向结构体Lnode的指针类型	</span><br><br>Londe a;	<span class="hljs-comment">//定义一个a结点</span><br>Londe *L; = LinkList L;	<span class="hljs-comment">//定义指向结点的指针</span><br><br>定义指向头节点的指针，就代表了整个链表<br>定义链表L ：LinkList L;	<br>定义结点指针p：LNode *p; = LinkList p;		<br></code></pre></td></tr></table></figure>

<p>对于多个数据域通常这样定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];	<span class="hljs-comment">//数据域</span><br>	<span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];	<span class="hljs-comment">//数据域</span><br>	<span class="hljs-type">int</span> score;		<span class="hljs-comment">//数据域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123;<br>    ElemType data;			<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;		<span class="hljs-comment">//指针域</span><br>&#125;Lnode,*LinkList;<br></code></pre></td></tr></table></figure>

<h3 id="单链表的销毁"><a href="#单链表的销毁" class="headerlink" title="单链表的销毁"></a>单链表的销毁</h3><p>销毁所有元素，包括头指针，头节点</p>
<p>算法思路：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">从头指针开始，依次释放所有结点<br>将后一个结点的地址，赋值给L,释放当前节点<br>	L = L-&gt;next;	!!!<br>    <span class="hljs-keyword">delete</span> p;	--创建时为<span class="hljs-keyword">new</span>			C++<br>    <span class="hljs-built_in">free</span>(p);	--创建时为<span class="hljs-built_in">malloc</span>()  	c<br>结束条件：L==<span class="hljs-literal">NULL</span><br>循环条件：L！==<span class="hljs-literal">NULL</span> 或L<br></code></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestroyList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>	Lnode *p;<br>	<span class="hljs-keyword">while</span>(L)&#123;		<span class="hljs-comment">//L不为空时循环继续</span><br>		p = L;				<span class="hljs-comment">//从头结点开始销毁，L开始存放的为头结点地址</span><br>		L = L-&gt;next;	<span class="hljs-comment">//指向下一个，释放当前</span><br>		<span class="hljs-keyword">delete</span> p		<span class="hljs-comment">//最后一个时：指向空，释放最后一个</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="清空单链表"><a href="#清空单链表" class="headerlink" title="清空单链表"></a>清空单链表</h3><p>链表仍存在，但链表中无元素，成为空链表（头指针和头结点仍然存在）</p>
<p>算法思路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">依次释放所有的结点，并将头结点指针域设置为空<br>	L来保存头部结点指针域<br>	<br><span class="hljs-number">1.</span>开始p用来存储第一结点（及头部结点下一个，p=L-&gt;next;）<br><span class="hljs-number">2.</span>释放p结点,同时需要保存下一个结点的地址（q = p-&gt;next;)<br><span class="hljs-number">3.</span>反复执行p=q; q=q-&gt;next;<br>	<span class="hljs-comment">//注：不用L的原因：L用来存储头部指针，如果使用头部指针无处存放</span><br>	<span class="hljs-comment">//		具体实现q=q-&gt;next与q=p-&gt;next重复，表达思维相同</span><br><br>结束条件：p==<span class="hljs-literal">NULL</span><br>循环条件：p！==<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;	<span class="hljs-comment">//将L重置为空表</span><br>	Lnode *p,*q;	<span class="hljs-comment">//或者LinkList p,q;</span><br>    p=L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;	<span class="hljs-comment">//p不为空反复执行</span><br>        q=p-&gt;next;		<span class="hljs-comment">//最后一个情况：q = NULL, p存的是当前地址</span><br>        <span class="hljs-keyword">delete</span> p;		<span class="hljs-comment">//释放当前指针</span><br>        p = q;			<span class="hljs-comment">//将下一个指针地址传给p</span><br>    &#125;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">//将头结点指针域为空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>总结：q用来存放下一个结点地址，当p释放当前结点成功后，将下一个指针地址重新赋值给p<br></code></pre></td></tr></table></figure>

<h3 id="求链表的表长"><a href="#求链表的表长" class="headerlink" title="求链表的表长"></a>求链表的表长</h3><p>算法思想：从首元结点开始，依次计数所有结点</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">依次遍历直到 <span class="hljs-attribute">p</span>=<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>	LinkList p;<br>	p =L-&gt;next			<span class="hljs-comment">//p指向第一个结点</span><br>	i = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(p)&#123;			<span class="hljs-comment">//遍历单链表，统计结点数</span><br>		i++;<br>		p=p-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> i;		<span class="hljs-comment">//如果长度为0及为空表</span><br>&#125;		<br></code></pre></td></tr></table></figure>

<p>重要操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">p = L;			<span class="hljs-comment">//p指向头结点</span><br>s = L-&gt;next;	<span class="hljs-comment">//s指向首元结点</span><br>p = p-&gt;next;	<span class="hljs-comment">//p指向下一结点</span><br></code></pre></td></tr></table></figure>

<h3 id="查找——取单链表中第i个元素"><a href="#查找——取单链表中第i个元素" class="headerlink" title="查找——取单链表中第i个元素"></a>查找——取单链表中第i个元素</h3><p>还不是查找,按下标查询,并不是按数据元素查询</p>
<p>算法思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止，因此，链表不是随机存储结构。<br><br><span class="hljs-number">1.</span>从第<span class="hljs-number">1</span>个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p=L-&gt;next<br><span class="hljs-number">2.</span>j做计数器，累计当前扫描过的结点数，j初值为<span class="hljs-number">1</span><br><span class="hljs-number">3.</span>当p指向扫描到的下一结点，计数器j加<span class="hljs-number">1</span><br><span class="hljs-number">4.</span>当j==i时，p所指的结点就是要找的第i个结点<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br>	p = L-&gt;next; j=<span class="hljs-number">1</span>		<span class="hljs-comment">//初始化</span><br>	<span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;		<span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>        p = p-&gt;next; ++j;<br>	&#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;???  <span class="hljs-comment">//第i个元素不存在  j&gt;i是判断万一i为负/0的情况和未找到元素j</span><br>    e = p-&gt;data;			<span class="hljs-comment">//取第i个元素</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>!p || j&gt;i   <span class="hljs-number">5</span>   <span class="hljs-number">4</span><br>当i小于链表长度，当j=i时p不为空，循环继续，结果至p=<span class="hljs-literal">NULL</span>，j&gt;i,(!p=<span class="hljs-number">1</span>,j&gt;i =<span class="hljs-number">1</span>)<br>当i大于链表长度，p为空，j&lt;<span class="hljs-built_in">i</span> (!p=<span class="hljs-number">1</span> || j&lt;i = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">时间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h3 id="增加——插入一个结点"><a href="#增加——插入一个结点" class="headerlink" title="增加——插入一个结点"></a>增加——插入一个结点</h3><p>在第i个节点前插入值为e的新结点</p>
<p>算法思想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">在ai前插入一个新结点<br><br><span class="hljs-number">1.</span>首先找到a（i<span class="hljs-number">-1</span>）的存储位置p<br><span class="hljs-number">2.</span>生成一个数据域为e的新结点s;<br><span class="hljs-number">3.</span>插入新结点：(<span class="hljs-number">1</span>)新结点的指针域指向结点ai	s-&gt;next = p-&gt;<span class="hljs-built_in">next</span><br>			(<span class="hljs-number">2</span>)结点<span class="hljs-built_in">a</span>(i<span class="hljs-number">-1</span>)的指针域指向新结点	p-&gt;next = s;<br>注意顺序，小心内存泄漏，ai地址丢失<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>	p = L;j = <span class="hljs-number">0</span>;		<span class="hljs-comment">//p指向头结点，不是首元结点，所以j=0，与前一个不同</span><br>	<span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123;<br>        p=p-&gt;next;<br>        ++j;			<span class="hljs-comment">//寻找第i-1个结点，p指向i-1结点</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//i大于表长+1或者小于1，插入位置非法</span><br>    			<span class="hljs-comment">//!p 过滤i大于表长，j&gt;i-1过滤i小于1的情况</span><br>    s = <span class="hljs-keyword">new</span> LNode; s-&gt;data=e;	<span class="hljs-comment">//生成新结点s，将结点s的数据域置为e</span><br>    s-&gt;next = p-&gt;next;		<br>    p-&gt;next = s;		<span class="hljs-comment">//将结点插入L中</span><br>&#125;<br><br><span class="hljs-comment">//p不从首元结点开始，原因避免插入位置为第一个，p指向的地址出现问题</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">时间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，不需要移动元素只需要修改指针<br></code></pre></td></tr></table></figure>

<h3 id="删除——第i个结点"><a href="#删除——第i个结点" class="headerlink" title="删除——第i个结点"></a>删除——第i个结点</h3><p>算法思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">寻找第i<span class="hljs-number">-1</span>个结点，修改指针域指向i+<span class="hljs-number">1</span>，释放第i个结点<br><br><span class="hljs-number">1.</span>首先找到<span class="hljs-built_in">a</span>(i<span class="hljs-number">-1</span>)的储存位置p，保存要删除的ai的值<br><span class="hljs-number">2.</span>令p-&gt;next指向<span class="hljs-built_in">a</span>(i+<span class="hljs-number">1</span>)<br>    p-&gt;next = p-&gt;next-&gt;next		<br><span class="hljs-number">3.</span>释放结点ai的空间<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>	p = L;j = <span class="hljs-number">0</span>;Lnode *q;<br>	<span class="hljs-keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)&#123;<br>		p=p-&gt;next; ++j;		<span class="hljs-comment">//寻找第i-1个结点，并令p指向其前驱</span><br>	&#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;		<span class="hljs-comment">//删除位置不合理</span><br>    		<span class="hljs-comment">//p是头结点，p-&gt;next为空，一种是空表，一种是i超出长度</span><br>    q = p-&gt;next;		<span class="hljs-comment">//临时保存被删除结点的地址以备释放</span><br>   <span class="hljs-string">&quot;p-&gt;next=q-&gt;next;&quot;</span>	<span class="hljs-comment">//改变删除结点前驱结点的指针域		</span><br>    e=q-&gt;data;			<span class="hljs-comment">//保存删除节点的数据域</span><br>    <span class="hljs-keyword">delete</span> q;			<span class="hljs-comment">//释放删除结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//q结点用来保存需要删除的结点</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">时间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，不需要移动元素只需要修改指针<br></code></pre></td></tr></table></figure>

<h3 id="建立单链表"><a href="#建立单链表" class="headerlink" title="建立单链表"></a>建立单链表</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>.从一个空表开始，重复读入数据<span class="hljs-comment">;</span><br><span class="hljs-number">2</span>.生成新结点，将读入数据存放到新结点的数据域中<br><span class="hljs-number">3</span>.从最后一个结点开始，依次将各结点插入到链表的前端 (头结点的后方)<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ky4r8nwh6Qcuobz.png" srcset="/img/loading.gif" lazyload alt="image-20220322162218117"></p>
<p>算法思路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>创建头结点<br>    L = <span class="hljs-keyword">new</span> LNode;	<span class="hljs-comment">//c++</span><br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));	<span class="hljs-comment">//c</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">2.</span>插入其余结点<br>    p =<span class="hljs-keyword">new</span> LNode;	<span class="hljs-comment">//c++	</span><br>	p-&gt;data=an;<br><span class="hljs-number">3.</span>将头结点后面的东西，放入新结点之后,头结点指针域方新节点<br>    p-&gt;next=L-&gt;next;<br>	L-&gt;next=p;<br><span class="hljs-number">4.</span>插入下一个,循环开始<br>    p=<span class="hljs-keyword">new</span> LNode;<br>	p-&gt;data=<span class="hljs-built_in">a</span>(n<span class="hljs-number">-1</span>)<br>    p-&gt;next = L-&gt;next;<br>	L-&gt;next=p;<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> n)</span></span>&#123;		<span class="hljs-comment">//n为结点数，插入次数(循环次数)</span><br>    L=<span class="hljs-keyword">new</span> LNode;<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;	<span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    <span class="hljs-keyword">for</span>(i=n;i&gt;<span class="hljs-number">0</span>;--i)&#123;<br>        p=<span class="hljs-keyword">new</span> LNode;	<span class="hljs-comment">//生成新结点 c p=(LNode*)malloc(sizeof(LNode));</span><br>        cin&gt;&gt;p-&gt;data;	<span class="hljs-comment">//输入元素值 c scanf(&amp;p-&gt;data);</span><br>        p-&gt;next=L-&gt;next;	<span class="hljs-comment">//插入到表头</span><br>        L-&gt;next=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">头插法——时间复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p>元素插入在链表尾部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>从一个空表开始，将新结点逐个插入到链表的尾部，<span class="hljs-string">&quot;尾指针r&quot;</span>指向链表的尾结点<br><span class="hljs-number">2.</span>初始时，r同L均指向头节点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点<br>        p-&gt;data=ai	p-&gt;next=<span class="hljs-literal">NULL</span><br>        r-&gt;next=p;	r=p;<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/TLRsnG1zwuhVCIP.png" srcset="/img/loading.gif" lazyload alt="image-20220322170116369" style="zoom: 67%;" />

<p>正位序输入n个元素的值，建立带表头结点的单链表L</p>
<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;	L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    r=L;	<span class="hljs-comment">//尾指针r指向头节点</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        p=<span class="hljs-keyword">new</span> LNode;<br>        cin&gt;&gt;p-&gt;data;	<span class="hljs-comment">//生成新节点，输入元素值</span><br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<br>        r-&gt;next=p;		<span class="hljs-comment">//插入到表尾</span><br>        r=p;			<span class="hljs-comment">//尾指针r指向新的尾结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">尾插法——时间复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表:是一种头尾相接的链表(即:表中最后一个结点的指针域指向头节点,整个链表形成一个环)</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">优点:从表中任一结点出发均可找到表中其他结点。<br><br>循环链表中没有NULL指针，故遍历操作的终止条件是判断其是否等于头指针。<br>	<span class="hljs-function"><span class="hljs-title">p</span>!=NULL   		---&gt;</span>&gt;&gt;		p！= L;<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>!=NULL	---&gt;</span>&gt;&gt;		<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>next!=L<br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">经常对首位经行操作采用：尾指针,<br>	首元节点位置 ：R-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>	<span class="hljs-regexp">//</span>尾指针指向头结点 再指向首元<br>		 尾节点 ：R<br></code></pre></td></tr></table></figure>

<h3 id="带尾指针的循环链表合并"><a href="#带尾指针的循环链表合并" class="headerlink" title="带尾指针的循环链表合并"></a>带尾指针的循环链表合并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">将带尾指针的链表进行合并：		<br><span class="hljs-comment">//Ta为链表1为指针，Tb为链表2尾结点</span><br>	<span class="hljs-number">1.</span>p存头节点<br>    <span class="hljs-number">2.</span>Tb表头连接到Ta表尾<br>	<span class="hljs-number">3.</span>释放Tb头结点<br>	<span class="hljs-number">4.</span>修改尾指针<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">p = Ta-&gt;next;	<span class="hljs-comment">//存Ta头节点</span><br>Ta-&gt;next = Tb-&gt;next-&gt;next;<br><span class="hljs-keyword">delete</span> Tb -&gt; next;<br>Tb-&gt;next = p;<br></code></pre></td></tr></table></figure>

<p>带尾指针的循环链表合并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>	p = Ta-&gt;next;	<br>    Ta-&gt;next = Tb-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> Tb -&gt; next;<br>    Tb-&gt;next = p;<br>    <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="双向列表"><a href="#双向列表" class="headerlink" title="双向列表"></a>双向列表</h2><p>在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，使链表形参有两个不同方向的链</p>
<h3 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>    Elemtype	data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior, *next;<br>&#125;DuLNode,*DuLinkList;<br></code></pre></td></tr></table></figure>

<p>双向循环链表</p>
<p>让头结点的前驱指针指向链表的最后一个结点</p>
<p>让最后一个结点的后继指针指向头结点</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">双向链表结构的对称性(设指针p指向某一结点):<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = p = p -&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior<br></code></pre></td></tr></table></figure>

<p>求长度，于获取元素和单链表相同，单插入删除则略有不同</p>
<h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">只需要找到第i个元素，i-<span class="hljs-number">1</span>通过指针prior寻找<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = p-&gt;</span>prior;	<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span>next = s;		<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span>next = p;<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>prior=s;<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsert_Dul</span><span class="hljs-params">(DulinkList &amp;L,<span class="hljs-type">int</span> i,Elemtype e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElemP_Dul</span>(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>	s = <span class="hljs-keyword">new</span> DuLNode;<br>	s-&gt;data = e;<br>	<br>	s-&gt;prior = p-&gt;prior;	<br>    p-&gt;prior-&gt;next = s;<br>    <br>    s-&gt;next = p;<br>    p-&gt;prior=s;<br>    <span class="hljs-keyword">return</span> OK<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h3><p>算法思想</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> -&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = p-&gt;</span>next;<br> 	<span class="hljs-comment">//删除结点的prior是其前驱节点，再将其前驱节点，与后半部分相连</span><br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = p-&gt;</span>prior<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">void ListDelete_Dul(DuLink &amp;L, int i ,ElemType &amp;e)&#123;<br>	<span class="hljs-keyword">if</span>(!(p=GetElemP_DuL(L,i))) return ERROR;<br>	<span class="hljs-function"><span class="hljs-title">e</span> = p-&gt;</span><span class="hljs-keyword">data</span>;<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = p-&gt;</span>next;<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = p-&gt;</span>prior;<br>	free(p);<br>	return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Eba4pUCdv1oQTer.png" srcset="/img/loading.gif" lazyload alt="image-20220326221130903"></p>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>优点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">结点空间可以动态的申请和释放<br>数据元素的逻辑次序靠结点的指针来指示，删除和插入时不需要移动数据元素<br></code></pre></td></tr></table></figure>

<p>缺点</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">存储密度小，每个结点的指针域需要额外占存储空间，每个结点的数据域所占字节不多，指针域所占存储空间比重大<br>	存储密度 <span class="hljs-operator">=</span> 结点数据所占空间/结点所占空间<br>		存储密度越大，存储空间利用率越高，顺序表密度为<span class="hljs-number">1</span><br>		<br>链式存储结构是非随机存储结构，对任一结点的操作都要从头指针依指针链查找到该结点<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/sGkJTrOoe8Bmy2i.png" srcset="/img/loading.gif" lazyload alt="image-20220326224722636"></p>
<h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="线性表的合并"><a href="#线性表的合并" class="headerlink" title="线性表的合并"></a>线性表的合并</h3><p>算法思想</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">依次取出Lb中的每个元素<br>	1.在<span class="hljs-keyword">La</span>中查找该元素<br>	2.如果找不到，则将其插入到<span class="hljs-keyword">La</span>的最后<br></code></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(List &amp;La, List Lb)</span></span>&#123;<br>    La_len=<span class="hljs-built_in">ListLength</span>(La);<br>    Lb_len=<span class="hljs-built_in">ListLength</span>(Lb);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;Lb_len;i++)&#123;<br>        <span class="hljs-built_in">GetElem</span>(Lb,i,e);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LocateElem</span>(La,e))&#123;<br>            <span class="hljs-built_in">ListInsert</span>(&amp;La,++La_len,e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">时间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">ListLength</span>(<span class="hljs-variable">La</span>)*<span class="hljs-title">ListLength</span>(<span class="hljs-variable">Lb</span>))</span><br></code></pre></td></tr></table></figure>

<h3 id="有序表的合并"><a href="#有序表的合并" class="headerlink" title="有序表的合并"></a>有序表的合并</h3><h4 id="顺序表实现"><a href="#顺序表实现" class="headerlink" title="顺序表实现"></a>顺序表实现</h4><p>算法思想</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">1.创建一个空表<br>2.依次从<span class="hljs-keyword">La</span>或Lb中&#x27;摘取&#x27;元素值较小的结点插入到表Lc的最后，直至其一个表为空表为止<br>3.继续将<span class="hljs-keyword">La</span>或Lb其中一个表剩余结点插入在Lc表的最后<br>	注：<span class="hljs-keyword">La</span>和Lb为有序表<br>	比较<span class="hljs-keyword">La</span>与Lb的元素，较小的加入<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_Sq</span><span class="hljs-params">(SqList LA,SqList LB,SqList &amp;LC)</span></span>&#123;<br>    pa = LA.elem;<br>    pb = LB.elem;		<span class="hljs-comment">//指针pa和pb的初值分别指向两个表的第一个元素</span><br>    LC.length = LA.length + LB.length;		<span class="hljs-comment">//新表长度为待合并两表的长度之和</span><br>    LC.elem = <span class="hljs-keyword">new</span> ElemType[LC.length];		<span class="hljs-comment">//分配空间</span><br>    pc=Lc.elem;<br>    pa_Last = LA.elem+LA.length<span class="hljs-number">-1</span>;		<span class="hljs-comment">//相当于LA.elem[0+La.length-1]</span><br>    pb_Last = LB.elem+LB.length<span class="hljs-number">-1</span>;		<span class="hljs-comment">//pa_Last 指向最后一个元素</span><br>    <br>    <span class="hljs-keyword">while</span>(pa&lt;=pa_last &amp;&amp; pb &lt;= pb_last)&#123;	<span class="hljs-comment">//两表都为空</span><br>        <span class="hljs-keyword">if</span>(*pa&lt;=*pb)*pc++ = *pa++;		<span class="hljs-comment">//依次”摘取“两表中值较小的结点</span><br>        <span class="hljs-keyword">else</span> *pc++ = *pb++;<br>	&#125;<br>    		<span class="hljs-comment">//注：其为后置++，先取值后加1</span><br>    <span class="hljs-keyword">while</span>(pa&lt;=pa_last) *pc++ = *pa++;<br>    <span class="hljs-keyword">while</span>(pb&lt;=pb_last) *pc++ = *pv++;		<span class="hljs-comment">//将剩余非空表，剩余元素加入Lc</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">时间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">ListLength</span>(<span class="hljs-variable">La</span>)+<span class="hljs-title">ListLength</span>(<span class="hljs-variable">Lb</span>))</span><br>空间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">ListLength</span>(<span class="hljs-variable">La</span>)+<span class="hljs-title">ListLength</span>(<span class="hljs-variable">Lb</span>))</span><br></code></pre></td></tr></table></figure>

<h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_L</span><span class="hljs-params">(LinkList &amp;La,LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;<br>	pa = La-&gt;next;	pb=Lb-&gt;next;<br>	pc=Lc=La;			<span class="hljs-comment">//用La的头结点作为Lc的头结点</span><br>	<span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>        <span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<br>            pc-&gt;next=pa;<br>            pc=pa;<br>            pa=pa-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>			pc-&gt;next=pb;<br>            pc=pb;<br>            pb=pb-&gt;next;<br>        &#125;<br>    &#125;<br>    pc-&gt;next = pa?pa:pb;	<span class="hljs-comment">//插入剩余段</span><br>    <span class="hljs-keyword">delete</span> Lb;		<span class="hljs-comment">//释放Lb的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(ListLength(La)+<span class="hljs-built_in">ListLength</span>(Lb))<br>空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),不需要额外空间<br></code></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈和队列是限定插入和删除只能再表的”端点”进行的 线性表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">栈：插入和删除只能在表尾进行，后进先出<br>队列：插入只能在表尾，但删除要从表头开始，先进先出<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/taTp9LxmwC5Wj7r.png" srcset="/img/loading.gif" lazyload alt="image-20220327192904293"></p>
<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈：特殊的线性表，限定仅在一端(通常是表尾)，进行插入删除操作的线性表，后进先出的线性表，简称LIFO结构</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">栈进再表尾进行插入，删除操作的线性表<br>	表尾(an端)称为栈顶<span class="hljs-attribute">Top</span>;表头(a1端)称为栈底Base<br><br>插入元素到栈顶的操作，叫入栈	<span class="hljs-built_in">PUSH</span>(x)<br>从栈顶删除最后一个元素的操作，称为出栈	<span class="hljs-built_in">POP</span>(y)<br><br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/TyE3hDBJiaLOvYW.png" srcset="/img/loading.gif" lazyload alt="image-20220330143326998" style="zoom: 33%;" />

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">逻辑结构：同线性表相同，仍为一对一关系<br>存储结构：用顺序栈或链栈存储即可，但以顺序栈更常见<br><br>与一般线性表的区别：只有运算规则不同<br></code></pre></td></tr></table></figure>

<h2 id="队列定义"><a href="#队列定义" class="headerlink" title="队列定义"></a>队列定义</h2><p>队列是先进先出的线性表，一端插入，令一端删除，在对尾插入，对头删除</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">逻辑结构：同线性表相同，仍为一对一关系<br>存储结构：用顺序队或链队存储即可，但以顺序队列更常见<br><br>与一般线性表的区别：只有运算规则不同<br></code></pre></td></tr></table></figure>

<h2 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">ADT Stack&#123;<br>	数据对象：<br>		D=&#123;ai|ai《 ElemSet，i=<span class="hljs-number">1</span>,<span class="hljs-number">2.</span>.&#125;<br>	数据关系：<br>		R1=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai《 D&#125;<br>		约定an为栈顶，a1为栈底<br>	基本操作：初始化，进栈，出栈，取出栈顶元素<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ilEHr9nTAegvI1X.png" srcset="/img/loading.gif" lazyload alt="image-20220330152226040"></p>
<h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">储存方式：同一般线性表的顺序存储结构完全相同，<br>		利用一组地址连续的存储单元依次存放自栈底到栈顶的元素<br>		top指针，指示栈顶元素在顺序栈中的位置<br>		base指针，指示栈底元素在顺序栈中的位置<br>	<span class="hljs-comment">//注：为了方便操作，通常top指示真正的栈顶元素之上的下标地址（最后一个元素之后的单元）</span><br>    	stacksize表示栈的可使用的最大容量<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">空栈：base <span class="hljs-operator">=</span><span class="hljs-operator">=</span> top是栈空标志<br>栈满：top - base <span class="hljs-operator">=</span> stacksize<br>	栈满时的处理方法：<br>		<span class="hljs-number">1</span>.报错，返回操作系统<br>		<span class="hljs-number">2</span>.分配更大的空间，作为栈的存储空间，将原栈的内容移入新栈<br>		<br>使用数组作为顺序栈存储方式特定：<br>	简单方便，但容易产生溢出<br>上溢：栈已满，又要压入元素<br>下溢：栈已空，还要弹出元素<br>	注：上溢为一种错误，使问题处理无法进行，而下溢为一种结束条件<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	SElemType *base;	<span class="hljs-comment">//栈底指针</span><br>	SElemTypr *top;		<span class="hljs-comment">//栈顶指针</span><br>	<span class="hljs-type">int</span> stacksize;		<span class="hljs-comment">//栈可用最大容量</span><br>&#125;SqStack;<br><br>栈中元素个数 = top-base = <span class="hljs-number">5</span>；<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;	<span class="hljs-comment">//构造一个空栈</span><br>	S.base = <span class="hljs-keyword">new</span> SElemType[MAXSIZE];	<span class="hljs-comment">//c++</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span> (OVERFLOW);	<span class="hljs-comment">//存储分配失败</span><br>    S.top = S.base;<br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><p>空栈：base &#x3D;&#x3D; top是栈空标志</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>		<span class="hljs-comment">//若栈为空，返回TRUE;否则返回FALSE;</span><br>	<span class="hljs-keyword">if</span>(S.top == S.base)<br>		<span class="hljs-keyword">return</span> TRUE;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求栈的长度"><a href="#求栈的长度" class="headerlink" title="求栈的长度"></a>求栈的长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span>(S.top - S.base);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="清空顺序栈"><a href="#清空顺序栈" class="headerlink" title="清空顺序栈"></a>清空顺序栈</h3><p>将top指针指向栈底</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.base)S.top = S.base;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="销毁顺序栈"><a href="#销毁顺序栈" class="headerlink" title="销毁顺序栈"></a>销毁顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(S.base)&#123;<br>		<span class="hljs-keyword">delete</span> []S.base;		<span class="hljs-comment">//释放了内存</span><br>		S.stacksize = <span class="hljs-number">0</span>;<br>	   <span class="hljs-string">&quot;S.base = S.top = NULL;&quot;</span>	<span class="hljs-comment">//若不将指针置为空，则会称为野指针</span><br>	&#125;							<span class="hljs-comment">//野指针：访问一个已经销毁或者访问受限的内存区域的指针</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的入栈"><a href="#顺序栈的入栈" class="headerlink" title="顺序栈的入栈"></a>顺序栈的入栈</h3><p>算法思想：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.判断是否栈满，若满则出错（上溢）<br><span class="hljs-attribute">2</span>.元素e压入栈顶<br><span class="hljs-attribute">3</span>.栈顶指针加<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S , SELemType e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top - S.base == S.stacksize)	<span class="hljs-comment">//栈满 </span><br>		<span class="hljs-keyword">return</span> ERROR;<br>    <br>	*S.top = e；	<span class="hljs-comment">// *p  指 对p指针所指的空间进行操作, *p该指针空间内的元素	</span><br>    S.top++；<br>        	<span class="hljs-comment">//两部何为一部 *S.top++ = e;	</span><br>   <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的出栈"><a href="#顺序栈的出栈" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h3><p>算法思想</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">top</span>指针下移，元素出栈<br><span class="hljs-number">1</span>.判断是否空栈，若空栈则出错(下溢)<br><span class="hljs-number">2</span>.栈顶元素指针减一，(此时刚好top指针指向栈顶元素)<br><span class="hljs-number">3</span>.获取栈顶元素<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top == S.base)<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//等价于if(StackEmpty(S))</span><br>	--S.top;<br>	e = *S.top;			<span class="hljs-comment">//e = *--S.top;</span><br>	<span class="hljs-keyword">return</span> OK;		<br>&#125;<br><span class="hljs-comment">//若栈不为空，则删除S的栈顶元素，用e返回其值</span><br></code></pre></td></tr></table></figure>

<h2 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h2><p>链栈是运算受限的单链表，只能在链表头部进行</p>
<h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">StackNode</span>&#123;<br>	SElemType data;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-type">StackNode</span> *next;<br>&#125;StackNode, *LinkStack;<br>LinkStack S;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">注意：<br>	<span class="hljs-number">1.</span>链表的头指针就是栈顶<br>	<span class="hljs-number">2.</span>不需要头节点<br>	<span class="hljs-number">3.</span>基本不存在栈满情况<br>	<span class="hljs-number">4</span>，空栈相当于头指针指向空<br>	<span class="hljs-number">5.</span>插入和删除仅在栈顶处执行<br></code></pre></td></tr></table></figure>

<h3 id="链栈的初始化"><a href="#链栈的初始化" class="headerlink" title="链栈的初始化"></a>链栈的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span></span>&#123;<br>	<span class="hljs-comment">//构造一个空栈，栈顶指针置为空</span><br>	S = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断链栈是否为空"><a href="#判断链栈是否为空" class="headerlink" title="判断链栈是否为空"></a>判断链栈是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> TRUE;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链栈的入栈"><a href="#链栈的入栈" class="headerlink" title="链栈的入栈"></a>链栈的入栈</h3><p>头插法？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span></span>&#123;<br>	p = <span class="hljs-keyword">new</span> StackNode;		<span class="hljs-comment">//生成新节点</span><br>	p-&gt;data = e;		<span class="hljs-comment">//填入数据域</span><br>	p-&gt;next = S;		<span class="hljs-comment">//将新结点插入栈顶</span><br>	S = p;			<span class="hljs-comment">//修改栈顶指针</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;<br>    p = S;			<span class="hljs-comment">//保留栈顶地址，没有头结点</span><br>    S = S-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S!=<span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><p>递归：若一个对象部分的包含它自己，或用它自己给自己定义，则称这个对象是递归的</p>
<p>若一个过程直接地或者间接的调用自己，则称这个过程是递归的过程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">递归调用函数 遵循后调用先返回<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">递归<br>优点：结构清晰，程序易读<br>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息，时间开销大。<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">如果时间效率要求，可以将递归转化<br>递归-》非递归<br>方法1：尾递归，单项递归-》循环结构<br>方法2：自用栈模拟系统的运行时栈<br><br>单项递归：有一处以上的递归，但语句只和主调函数有关，相互之间参数无关，并且这些递归调用语句位于算法的最后<br></code></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>仅在表尾进行插入操作，在表头进行删除操作的线性表</p>
<p>表尾an队尾，a1队头，先入先出</p>
<p>插入元素称为入队，删除元素称为出队，</p>
<h2 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h2><p>用一维数组base[MAXQSIZE]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br>Typedef <span class="hljs-keyword">struct</span>&#123;<br>	QElemtype *base;	<span class="hljs-comment">//初始化的动态分配存储空间</span><br>						<span class="hljs-comment">//base指向数组的首元素</span><br>	<span class="hljs-type">int</span> front;		<span class="hljs-comment">//头指针，指向队头元素的下标</span><br>	<span class="hljs-type">int</span> rear;		<span class="hljs-comment">//尾指针，指向对尾元素的小标</span><br>&#125;SqQueue;<br><span class="hljs-comment">//注：front rear代表元素下标</span><br></code></pre></td></tr></table></figure>

<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>初始化：front = rear = <span class="hljs-number">0</span><br><br><span class="hljs-number">2.</span>入队：base[rear] = x; rear++;<br><br><span class="hljs-number">3.</span>出队： x = base[front];	front++;<br>		空队标志：front == rear<br>            <br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题：当rear = MAXQSIZE时发生越界<br>            若front = <span class="hljs-number">0</span> rear=MAXQSIZE再入队——真溢出<br>            若front != <span class="hljs-number">0</span> rear=MAXQSIZE再入队——假溢出<br>    <br>解决假上溢<br>    <span class="hljs-number">1.</span>将队中元素依次向队头方向移动<br>    		缺点：浪费时间，每移动一次，队中元素都要移动<br>    <br>    <span class="hljs-number">2.</span>将队空间设想成一个循环的表，即分配给队列m个储存单元可以循环使用，<br>    	当rear为MAXQSIZE时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize同理<br>    <br>    	若rear+<span class="hljs-number">1</span> = MAXQSIZE，则令rear = <span class="hljs-number">0</span><br>    <span class="hljs-comment">//利用 模（mod，c语言中：%）运算</span><br>eg.插入运算<br>	Q.base[Q.rear] = x;<br>	Q.rear = (Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE;	<span class="hljs-number">6</span>%<span class="hljs-number">6</span> = <span class="hljs-number">0</span><br>   删除运算<br>	x = Q.base[s.front];<br>	Q.front = (Q.front+<span class="hljs-number">1</span>)%MASQSIZE;<br><br>循环队列：循环使用为队列分配储存空间<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题<span class="hljs-number">2</span>：<br>	队空：front == rear<br>	队满：front == rear 两个判断条件相同，如何区别队满和对空<br>    <br>解决方法：<br>    <span class="hljs-number">1.</span>另外设置一个标志以区别队空、队满<br>    	（加元素判断标志为<span class="hljs-number">0</span>则变为<span class="hljs-number">1</span>，删元素如果 front<span class="hljs-number">-1</span> = rear，将标志<span class="hljs-number">1</span>置为<span class="hljs-number">0</span>,标志已经为<span class="hljs-number">0</span>则不能删，用<span class="hljs-number">0</span>，<span class="hljs-number">1</span>判断是否为空）<br>    <br>    <span class="hljs-number">2.</span>令设一个变量，记录元素个数<br>    <br>  <span class="hljs-comment">//3.少用一个元素空间（不用改变struct定义结构）</span><br>    	队满判断：(rear+<span class="hljs-number">1</span>)%MAXQSIZE == front;<br>			尾指针再加<span class="hljs-number">1</span>等于头指针则为满<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Gqe67ozYcTFP8Bh.png" srcset="/img/loading.gif" lazyload alt="image-20220404152614541"></p>
<h3 id="循环队列的类型定义"><a href="#循环队列的类型定义" class="headerlink" title="循环队列的类型定义"></a>循环队列的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br>Typedef <span class="hljs-keyword">struct</span>&#123;<br>	QElemtype *base;	<span class="hljs-comment">//初始化的动态分配存储空间</span><br>						<span class="hljs-comment">//base指向数组的首元素</span><br>	<span class="hljs-type">int</span> front;		<span class="hljs-comment">//头指针，指向队头元素的下标</span><br>	<span class="hljs-type">int</span> rear;		<span class="hljs-comment">//尾指针，指向对尾元素的小标</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure>

<h3 id="队列的初始化"><a href="#队列的初始化" class="headerlink" title="队列的初始化"></a>队列的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>	Q.base = <span class="hljs-keyword">new</span> QElemType[MAXQSIZE]	<span class="hljs-comment">//分配数组空间</span><br>	Q.base = (QElemType*)<span class="hljs-built_in">malloc</span>(MAXQSIZE*<span class="hljs-built_in">sizeof</span>(QElemType));<br>    <br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW);	<span class="hljs-comment">//存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;		<span class="hljs-comment">//头指针尾指针置为0，队列为空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求队列的长度"><a href="#求队列的长度" class="headerlink" title="求队列的长度"></a>求队列的长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">return</span>((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);<br>&#125;	<span class="hljs-comment">//当rear &lt; front 时需要加上MAXQSIZE</span><br><br><span class="hljs-comment">//队尾减去队头，如果rear循环 加上MAXQSIZE</span><br></code></pre></td></tr></table></figure>

<h3 id="循环队列入队"><a href="#循环队列入队" class="headerlink" title="循环队列入队"></a>循环队列入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE == Q.front)	<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//队满</span><br>    <br>    Q.base[Q.rear] = e;		<span class="hljs-comment">//新元素加入队尾</span><br>    Q.rear = (Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE;	<span class="hljs-comment">//队尾指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="循环队列出队"><a href="#循环队列出队" class="headerlink" title="循环队列出队"></a>循环队列出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;		<span class="hljs-comment">//队空</span><br>	e = Q.base[Q.front];			<span class="hljs-comment">//保存队头元素</span><br>	Q.front = (Q.front+<span class="hljs-number">1</span>)%MAXQSIZE;		<span class="hljs-comment">//队头指针+1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front != Q.rear)&#123;		<span class="hljs-comment">//队列不为空</span><br>		<span class="hljs-keyword">return</span> Q.base[Q.front];		<span class="hljs-comment">//返回队头指针元素的值，队头指针不变</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p>队列的链式表示和实现</p>
<h3 id="链队列的类型定义"><a href="#链队列的类型定义" class="headerlink" title="链队列的类型定义"></a>链队列的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 	<span class="hljs-comment">//最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span>&#123;<br>	QElemType data;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span> *next;<br>&#125;QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QueuePtr front;	<span class="hljs-comment">//队头指针</span><br>    QueuePtr rear;	<span class="hljs-comment">//队尾指针</span><br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/omVXh3u4DHvpSOJ.png" srcset="/img/loading.gif" lazyload alt="image-20220404165627856"></p>
<h3 id="链队的初始化"><a href="#链队的初始化" class="headerlink" title="链队的初始化"></a>链队的初始化</h3><p>找到一个头结点，首尾指针都指向头节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>	Q.front = Q.rear = (QueuePtr) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span>(!Q.front) <span class="hljs-built_in">exit</span>(OVERFLOW);	<span class="hljs-comment">//判断是否生成成功，可以不要</span><br>    <br>    Q.front -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列的销毁"><a href="#链队列的销毁" class="headerlink" title="链队列的销毁"></a>链队列的销毁</h3><p>从头结点开始，依次释放所有的结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestroyQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(Q.front)&#123;<br>		p = Q.front-&gt;next;<br>		<span class="hljs-built_in">free</span>(Q.front);<br>		Q.front = p;<br>        <br>        <span class="hljs-comment">//也可以不使用新指针p，直接使用尾指针rear</span><br>        Q.rear = Q.front-&gt;next;<br>        <span class="hljs-built_in">free</span>(Q.front);<br>        Q.front = Q.rear;<br>	&#125;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列的入队"><a href="#链队列的入队" class="headerlink" title="链队列的入队"></a>链队列的入队</h3><p>只能放在队尾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;<br>	p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    p-&gt;data = e; p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;	<span class="hljs-comment">//将新结点接入链表</span><br>    Q.rear = p;		<span class="hljs-comment">//尾指针指向最后</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列的出队"><a href="#链队列的出队" class="headerlink" title="链队列的出队"></a>链队列的出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;e, QElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <br>    <span class="hljs-keyword">if</span>(Q.rear==p)Q.rear = Q.front;	<span class="hljs-comment">//如果最后一个元素出队，则需要将尾指针指向头结点</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列队头元素"><a href="#链队列队头元素" class="headerlink" title="链队列队头元素"></a>链队列队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue Q, QElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>	e = Q.front-&gt;next-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h1><p>串：内容受限的线性表，内容只能为字符</p>
<p>数组和广义表是线性表的推广</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串：零个或者多个任意字符组成的有限序列</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a1a2····an&quot;</span><br></code></pre></td></tr></table></figure>

<p>子串：串中任意个连续字符组成的子序列（含空串）称为该串的子串</p>
<p>主串：包含子串的串相应的称为主串</p>
<p>字符位置：字符在序列中的序号为该字符在串中的位置</p>
<p>子串位置：子串的第一个字符在主串中的位置</p>
<p>空格串：由一个或多个空格组成的串，与空串不同</p>
<p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p>​		所有的空串都是相等的</p>
<h2 id="串的类型定义"><a href="#串的类型定义" class="headerlink" title="串的类型定义"></a>串的类型定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">ADT String&#123;<br>	数据对象 <br>	数据关系：前驱和后继<br>	基本操作：<br>		<span class="hljs-built_in">StrAssign</span>(&amp;T,chars)		<span class="hljs-comment">//串赋值</span><br>		<span class="hljs-built_in">StrCompare</span>(S,T)			<span class="hljs-comment">//串比较</span><br>		<span class="hljs-built_in">StrLength</span>(S)			<span class="hljs-comment">//求串长</span><br>		<span class="hljs-built_in">Concat</span>(&amp;T,S1,S2)		<span class="hljs-comment">//串连结</span><br>		<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/U92OwhGAI1ja5CB.png" srcset="/img/loading.gif" lazyload alt="image-20220412105342766" style="zoom: 40%;" />

<h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.顺序串<br>2.链串<br></code></pre></td></tr></table></figure>

<h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	<span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];		<span class="hljs-comment">//存储串的一维数组</span><br>	<span class="hljs-type">int</span> length;		<span class="hljs-comment">//串当前长度</span><br>&#125;SString;<br>		<span class="hljs-comment">//注：为了算法描述方便，下标为0的位置不用,所以MAXLEN+1</span><br></code></pre></td></tr></table></figure>

<h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优点：操作方便		缺点：存储密度较低<br>	可以将多个字符放在一个节点中，以克服其缺点<br></code></pre></td></tr></table></figure>

<p>所有采用块链结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80	<span class="hljs-comment">//块的大小可以由用户定义</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>	<span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span> *next;<br>&#125;Chunk;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    Chunk *head,*tail;		<span class="hljs-comment">//串的头指针和尾指针</span><br>    <span class="hljs-type">int</span> curlen;				<span class="hljs-comment">//串的当前长度</span><br>&#125;LString;					<span class="hljs-comment">//字符串的块链结构</span><br><br></code></pre></td></tr></table></figure>

<h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h2><p>确定主串中所含子串(模式串)第一次出现的位置（定位）</p>
<p>​	应用：搜索引擎，拼写，语言翻译，数据压缩</p>
<p>算法种类：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BF算法：暴力破解</span><br><span class="hljs-keyword"></span>KMP算法（特点速度快）<br></code></pre></td></tr></table></figure>

<h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>穷举法</p>
<p>算法思路：从主串的每一个字符开始依次与T的字符进行匹配</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">INdex</span>(S,<span class="hljs-built_in">T</span>,pos)<br>将主串的第pos个字符和模式串的第一个字符比较，<br>	若相等，继续逐个比较后续字符；<br>	若不等，从主串的下一字符其，重新与模式串的第一个字符比较<br>	<br>	直到主串的一个连续字符序列与模式串相等，返回值为S中与<span class="hljs-built_in">T</span>匹配的子序列第一个字符的序号，即匹配成功。<br>	否则匹配失败，返回值<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString SString, SString T,(<span class="hljs-type">int</span> pos))</span></span>&#123; <span class="hljs-comment">//pos表示从中间的某个地方开始寻找</span><br>	<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>(pos),j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;<br>        <span class="hljs-keyword">if</span>(s.ch[i] == t.ch[j])&#123;<br>            i++;j++;	<span class="hljs-comment">//主串和子串依次匹配下一个字符</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>			i = i-j+<span class="hljs-number">2</span> ;		<span class="hljs-comment">// i = i - (j-1) + 1 (没有0号位置)</span><br>            j = <span class="hljs-number">1</span>;		<span class="hljs-comment">//主串、子串指针回溯重新开始下一次匹配</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt;= T.length) <span class="hljs-keyword">return</span> i-T.length;	<span class="hljs-comment">//返回匹配的第一个字符的下标</span><br>    		???匹配成功的判断条件，需要仔细考虑，没有 == <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<span class="hljs-comment">//匹配失败</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">算法复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>*<span class="hljs-variable">m</span>)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span> Index_BF(string S, string T)&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ,j = <span class="hljs-number">1</span>;  <span class="hljs-comment">//下标从1开始</span><br>    <span class="hljs-keyword">while</span> (i &lt;= S.<span class="hljs-built_in">length</span>() &amp;&amp; j &lt;= T.<span class="hljs-built_in">length</span>())<br>    &#123;   <br>       <span class="hljs-keyword">if</span>(S[i] == T[j])&#123;<br>            i++;j++;<br>       &#125; <span class="hljs-keyword">else</span>&#123;<br>        i = i - (j<span class="hljs-number">-1</span>) +<span class="hljs-number">1</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-comment">//匹配成功 返回下标</span><br>    <span class="hljs-keyword">if</span>(j&gt;T.<span class="hljs-built_in">length</span>()) <span class="hljs-keyword">return</span> i-T.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="*KMP算法"></a>*KMP算法</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzuuoo666/p/9028287.html">参考文章：很详尽KMP算法（厉害）</a></p>
<p>当匹配失败的时候，每次移动一个字符位置时间时间复杂度高，<strong>模式串以匹配成功部分的 后缀 可能与 起前缀有一部分是相同的 可将其直接向后移动</strong> 以达到不向前移动 i的目的</p>
<p><strong>移动位数 &#x3D;  以匹配字符数 - 对应的部分匹配值</strong></p>
<p>kmp算法关键 要对 模式串进行预处理 <strong>计算每一位的部分匹配值，即next数组</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">jNNNNjNNNN<br>next[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<p>ac模板next求法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>    <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>    ne[i] = j;<br>&#125;   <span class="hljs-comment">// ne[0] 为0默认值</span><br></code></pre></td></tr></table></figure>

<p>i &#x3D; next[]</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>非线性结构：树形结构（一个前驱多个后继）</p>
<p>​						图形结构（多个前驱多个后继）</p>
<p>树形结构：结点之间有分支，具有层次结构</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">树：是<span class="hljs-built_in">n</span>(<span class="hljs-comment">n&gt;=0</span>)个结点的有限集<br>	若<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span>，空树<br>	若<span class="hljs-built_in">n</span> &gt; <span class="hljs-number">0</span>,则满足<br>		<span class="hljs-number">1</span>.有且仅有一个特定的称为根的结点<br>		<span class="hljs-number">2</span>.其余结点可分为m(m&gt;=<span class="hljs-number">0</span>)个互不相交的有限集<span class="hljs-symbol">T1</span>，<span class="hljs-symbol">T2</span>，<span class="hljs-symbol">T3</span>...其中没一个集合本身都是一颗树，并称为根的的字树。<br>树的定义是一个递归的定义<br></code></pre></td></tr></table></figure>

<h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">结点：数据元素以及指向字数的分支<br>	根节点：非空树中无前驱结点的结点<br><br><span class="hljs-number">1.</span>结点的度：结点拥有的子树数（后继结点）<br><span class="hljs-number">2.</span>数的度：树内各结点的度的最大值<br>    叶子节点：度为<span class="hljs-number">0</span>的节点——终端节点<br>	度 != <span class="hljs-number">0</span> 分支节点，根节点以外的分支结点称为内部结点<br><br>结点的子树称为该节点的孩子，该节点称为孩子的双亲。  ———— 上下关系<br>    兄弟节点：<br>    堂兄弟节点：双亲在同一层的节点<br>    <br>结点的祖先：从根到该结点所经分支上所有节点<br>结点的子孙：以某结点为根的子树中的任一结点。<br>    <br>    树的深度：树中结点的最大层次<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/HX69JuDIPkdEynw.png" srcset="/img/loading.gif" lazyload alt="image-20220414001908089"></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">有序树：树中结点的各子树从左至右有次序（最左边的为第一个孩子）<br>无序树：树中结点的各子树无次序<br><br>森林：是m（m &gt;<span class="hljs-operator">=</span><span class="hljs-number">0</span>) 课互不相交的树的集合<br>	给森林的各子树加上一个双亲结点，森林就变成了树<br>	树一定是森林，森林不一定是树<br></code></pre></td></tr></table></figure>

<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树的结构简单，规律性最强</p>
<p>多叉树可以转化为二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">二插树是n&gt;=<span class="hljs-number">0</span>个结点的有限集，它或者是空集（n=<span class="hljs-number">0</span>）,或者由由一个根结点及两颗互不相交的分别称作这个根的左子树和右子树<br>特点：<br>	<span class="hljs-number">1.</span>每个结点最多有两个孩子（二叉树中不存在度大于<span class="hljs-number">2</span>的节点）<br>	<span class="hljs-number">2.</span>子树有左右之分，其次序不能颠倒<br>	<span class="hljs-number">3.</span>二叉树可以是空集合，根可以有空的左子树或空的右子树<br>    <br><span class="hljs-comment">//注：二叉树不是树的特殊情况，他们是两个概念</span><br>    	要区分左子树，和右子树<br>    虽然二叉树与树的概念不同，但是关于树的基本术语都试用<br>    <br>二叉树中每个结点的位置或者说次序是固定的，可以为空，但不可以说它没有位置<br></code></pre></td></tr></table></figure>

<h2 id="二叉树抽象数据类型定义"><a href="#二叉树抽象数据类型定义" class="headerlink" title="二叉树抽象数据类型定义"></a>二叉树抽象数据类型定义</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">ADT BinaryTree&#123;<br>	数据对象D:具有相同特性的元素集合<br>	数据关系R：空集，二元关系<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>在二叉树的第i层上至多有<span class="hljs-number">2</span> <span class="hljs-built_in">pow</span>(i<span class="hljs-number">-1</span>)个结点，最少一个结点<br><br><span class="hljs-number">2.</span>深度为k的二叉树 至多 有<span class="hljs-number">2</span> <span class="hljs-built_in">pow</span>(k)<span class="hljs-number">-1</span> 个结点。(k&gt;=<span class="hljs-number">1</span>),最少k个结点<br>    <br><span class="hljs-number">3.</span>对于任何一颗二叉树T，其叶子树为n0，度为<span class="hljs-number">2</span>的结点树为n2，则n0 = n2 + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>满二叉树</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">一个深度为k且有<span class="hljs-number">2</span> <span class="hljs-built_in">pow</span>(k) -<span class="hljs-number">1</span> 个结点的二叉树称为满二叉树。<br>特点：<br>	<span class="hljs-number">1</span>.每一层上的结点数都是最大结点数（即每层都满）<br>	<span class="hljs-number">2</span>.叶子节点全部在最底层<br>	<br>满二叉树在同样深度的二叉树中结点个数最多<br>满二叉树在同样深度的二叉树中叶子结点个数最多<br></code></pre></td></tr></table></figure>

<p>完全二叉树</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中的编号<span class="hljs-number">1</span>~n的结点一一对应时，称为完全非二叉树。<br><br>特点：<br>	<span class="hljs-number">1</span>.叶子只可能分布在层次最大的两次上<br>	<span class="hljs-number">2</span>.对任一结点，如果其右子树的最大层次为<span class="hljs-selector-tag">i</span>，其左子树的最大层次必为<span class="hljs-selector-tag">i</span>或<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">性质<span class="hljs-number">4</span><br>	具有n个结点的完全二叉树的深度为 log2n 的底 + <span class="hljs-number">1</span><br>		注：x的底，表示不大于x的最大整数<br>	性质<span class="hljs-number">4</span>表明了完全二叉树<span class="hljs-string">&#x27;结点数n&#x27;</span>与完全二叉树<span class="hljs-string">&#x27;深度k&#x27;</span>之间的关系<br>    <br>    <br>性质<span class="hljs-number">5</span>：<br>    说明了<br>   <span class="hljs-string">&#x27;完全二叉树&#x27;</span>中<span class="hljs-string">&#x27;双亲结点编号&#x27;</span>与<span class="hljs-string">&#x27;孩子结点编号&#x27;</span>之间的关系<br>    第i个节点<br>    <span class="hljs-number">1.</span>双亲结点i/<span class="hljs-number">2</span><br>    <span class="hljs-number">2.</span>左孩子节点<span class="hljs-number">2</span>i<br>    <span class="hljs-number">3.</span>右孩子节点<span class="hljs-number">2</span>i+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树顺序存储表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100</span><br>Typedef TElemType SqBiTree[MAXSTIZE];<br>SqBiTree bt;		<span class="hljs-comment">//Binary Tree 二叉树</span><br><br><span class="hljs-number">1.</span>完全二叉树——按编号依次存储即可<br><span class="hljs-number">2.</span>如果是非完全二叉树—— 则需要补上空值，顺序存储<br></code></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">缺点：<br>	最坏情况：深度为<span class="hljs-variable">k</span>的且只有<span class="hljs-variable">k</span>个结点的单支树需要长度为<span class="hljs-number">2</span><span class="hljs-built_in">K</span><span class="hljs-operator">-</span><span class="hljs-number">1</span>的一维数组<br>	<br>特点：	<br>	结点间关系蕴含在其存储位置中<br>	浪费空间，适于存满二叉树和完全二叉树<br></code></pre></td></tr></table></figure>

<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">特点：一个双亲parent，一个数据域<span class="hljs-class"><span class="hljs-keyword">data</span>，一个左孩子lchild，一个右孩子rchild</span><br></code></pre></td></tr></table></figure>

<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<br>	TElemType data;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span> *Ichild, *rchild;		<span class="hljs-comment">//左右孩子指针	</span><br>&#125;BiNode,*BiTree;<br><br><span class="hljs-comment">//嵌套定义 </span><br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">在<span class="hljs-built_in">n</span>个结点的二叉链表中，有<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>个空指针域<br>	<span class="hljs-number">2</span><span class="hljs-built_in">n</span>-（<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>） = <span class="hljs-built_in">n</span>+<span class="hljs-number">1</span><br>	<span class="hljs-number">2</span><span class="hljs-built_in">n</span>是共有链域，<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>是出了根结点都有双亲，剩余则就是空指针域<br></code></pre></td></tr></table></figure>

<h4 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h4><p>三个指针域parent，data，lchild，rchild</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef struct <span class="hljs-type">TriTNode</span>&#123;<br>	<span class="hljs-type">TElemType</span> data;<br>	struct <span class="hljs-type">TriTNode</span> *<span class="hljs-type">Ichild</span>,*parent,*rchild;		  	<br>&#125;<span class="hljs-type">TriTNode</span>,*<span class="hljs-type">TriTree</span>;<br></code></pre></td></tr></table></figure>

<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均背访问一次，且仅被访问一次</p>
<p>遍历是二叉树一切算法的核心</p>
<p>遍历方法：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">依次遍历二叉树中的三个组成部分，变是遍历了整个二叉树<br><span class="hljs-variable">L</span>：遍历左子树 <span class="hljs-built_in">D</span><span class="hljs-operator">:</span>访问根结点，<span class="hljs-variable">R</span>：遍历右子树<br><span class="hljs-variable">DLR</span>、<span class="hljs-variable">LDR</span>、<span class="hljs-variable">LRD</span>、<span class="hljs-variable">DRL</span>、<span class="hljs-variable">RDL</span>、<span class="hljs-variable">RLD</span> 六种<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">DLR——先序遍历 ——根左右<br>LDR——中序遍历 ——左根右<br>LRD——后序遍历 ——左右根<br><br>ABDGCEHF<br>DGBAEHCF<br>GDBHEFCA<br><br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/BfIOeWkb7XdaqRP.png" srcset="/img/loading.gif" lazyload alt="image-20220414135424489" style="zoom:33%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">先序：-+axb-cd/ef		前缀表达式<br>中序：a+bxc-d-e/f		中缀表达式<br>后序：abcd-x+ef/-		后缀表达式<br></code></pre></td></tr></table></figure>

<p>根据遍历序列确定二叉树</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的<br><br>由二叉树的先序序列和后序，或者后序和中序可以确定唯一二叉树<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">先序和中序：<br>	由先序序列确定根；由中序序列确定左右子树，逐渐夹逼<br>	<br>中序和后续<br>	后续遍历，根结点必在后序序列尾部<br></code></pre></td></tr></table></figure>

<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><h4 id="先序遍历-—-实现"><a href="#先序遍历-—-实现" class="headerlink" title="先序遍历 — 实现"></a>先序遍历 — 实现</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">DLR<br>若二叉树为空：则空操作<br>若二叉树非空,<br>	访问根节点<span class="hljs-comment">(D)</span><br>	前序遍历左子树<span class="hljs-comment">(L)</span><br>	前序遍历右子树<span class="hljs-comment">(R)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);		<span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);	<span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild);	<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="中序遍历-—-实现"><a href="#中序遍历-—-实现" class="headerlink" title="中序遍历 — 实现"></a>中序遍历 — 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">INOrderTraverse</span>(T-&gt;lchild);	<span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T);		<span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">INOrderTraverse</span>(T-&gt;rchild);	<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="后序遍历-—-实现"><a href="#后序遍历-—-实现" class="headerlink" title="后序遍历 — 实现"></a>后序遍历 — 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);	<span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild);	<span class="hljs-comment">//递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T);		<span class="hljs-comment">//访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或者说三中算法的访问路径是完全相同的，只是访问的时机不同。</p>
<img src="https://s2.loli.net/2024/02/24/K9GFNCRrkfSymVI.png" srcset="/img/loading.gif" lazyload alt="image-20220414150959949" style="zoom:33%;" />

<p>每个节点经过三次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">时间复杂度O(n)	<span class="hljs-comment">//每个结点只访问一次</span><br>空间复杂度O(n)		<span class="hljs-comment">//栈所占用的最大辅助空间</span><br>		<span class="hljs-comment">//内存中需要一个储存栈</span><br></code></pre></td></tr></table></figure>

<h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><p>中序遍历二叉树：</p>
<p>二叉树中序遍历的非递归算法关键：在中序遍历经过某结点的整个左子树后，如何找到该结点的根和右子树</p>
<p>基本思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>建立一个栈<br><span class="hljs-number">2.</span>根结点进栈，遍历左子树<br><span class="hljs-number">3.</span>根结点出栈，输出根结点，遍历右子树<br>    <br>遇到结点，先入栈，访问左子树，当左子树为空，根节点出栈，访问右子树，右子树为空查询栈是否为空，不为空出栈继续访问，为空则为整个树都访问完成<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	BiTree p;<br>	<span class="hljs-built_in">InitStack</span>(S);		<span class="hljs-comment">//初始化一个栈</span><br>	p=T;	<span class="hljs-comment">//指向根节点</span><br>	<span class="hljs-keyword">while</span>(p||!<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>		<span class="hljs-keyword">if</span>(p)&#123;<br>			<span class="hljs-built_in">Push</span>(S,p); p = p-&gt;Ichild;<br>		&#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">Pop</span>(S,q);	<span class="hljs-comment">//p为空就用q接收栈顶元素</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, q-&gt;data;)<br>            p = q-&gt;rchild;	<span class="hljs-comment">//继续访问右子树</span><br>            <br>        &#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 注：这里栈中存储的数据为树的指针</span><br></code></pre></td></tr></table></figure>

<h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>对于一个二叉树，从根节点开始，从上到下，从左到右的顺序访问每一个节点</p>
<p>​		没个节点仅访问一层</p>
<p>算法思想</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">使用一个队列<br><span class="hljs-number">1</span>.将根结点进队<br><span class="hljs-number">2</span>.队不空时循环:从队列中出列一个结点*p,访问它;<br>	<span class="hljs-number">1</span>.若它有左孩子结点，将左孩子结点进队<br>	<span class="hljs-number">2</span>.若它有右孩子结点，将右孩子结点进队<br></code></pre></td></tr></table></figure>

<p>实现</p>
<p>队列类型定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	BiNode data[MaxSize];		<span class="hljs-comment">//存放队中元素</span><br>	<span class="hljs-type">int</span> front, rear;			<span class="hljs-comment">//队头和队尾指针</span><br>&#125;SqQueue;		<span class="hljs-comment">//顺序循环队列类型</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LeverOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    <br>	BTNode *p;	SqQueue qu;<br>    <span class="hljs-built_in">InitQueue</span>(qu);		<span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b);		<span class="hljs-comment">//根结点指针进入队列</span><br>    <br>    <br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;		<span class="hljs-comment">//队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p);				<span class="hljs-comment">//出队结点p</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p-&gt;data);		<span class="hljs-comment">//访问结点p</span><br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>			<span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild);<br>        &#125;			<span class="hljs-comment">//有左孩子时将其进队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">enQueue</span>(qu, p-&gt;rchild);<br>        &#125;			<span class="hljs-comment">//有右孩子时将其进队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>遍历算法的应用</p>
<p>用 先序遍历序列 建立二叉树的二叉链表</p>
<p>先序序列逆推二叉树不是唯一的，要确保唯一性用空节点补充 #<br>        ABC##DE#G##F###</p>
<p>ABD#G###CE#H##F##</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&quot;#&quot;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(!(T=(BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode))))<br>            <span class="hljs-built_in">exit</span>(OVERFLOW);		<span class="hljs-comment">// T = new BiTNode;</span><br>        T-&gt;data = ch;	<span class="hljs-comment">//生成根结点</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);	<span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h3><p>算法思想</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">如果是空树，递归结束<br>否则，申请新的结点空间，复制根结点<br>	递归复制左子树<br>	递归复制右子树<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T, BiTree &amp;New T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>		NewT = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>		NewT = <span class="hljs-keyword">new</span> BiTNode;<br>        NewT-&gt;data = T-&gt;data;<br>        <br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild, NewT-&gt;lchild);<br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild, NewT-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h3><p>思想</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">如果是空树，则深度为<span class="hljs-number">0</span><br>否则，递归计算左子树的深度记为m，递归计算右子树的深度记为<span class="hljs-built_in">n</span>，二叉树的深度则为m与<span class="hljs-built_in">n</span>中较大者加<span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);<br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild); <br>        <span class="hljs-keyword">if</span>(m&gt;n) <span class="hljs-keyword">return</span> (m+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span>(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算二叉树的结点总数"><a href="#计算二叉树的结点总数" class="headerlink" title="计算二叉树的结点总数"></a>计算二叉树的结点总数</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">如果是空树，则结点个数为0;<br>否则,结点个数个数为左子树的结点个数 + 右子树的结点个数再<span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算叶子结点树"><a href="#计算叶子结点树" class="headerlink" title="计算叶子结点树"></a>计算叶子结点树</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">如果是空树，则叶子结点个数为0<br>否则，为左子树的叶子结点个数 + 右子树的叶子结点个数<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;	<span class="hljs-comment">//如果是叶子结点返回1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>&#125;<br>	<span class="hljs-comment">//通过递归，叶子结点返回1，一个一个相加</span><br></code></pre></td></tr></table></figure>

<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>问题：如何寻找特定遍历序列中二叉树结点的前驱和后继</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">解决方法：<br><span class="hljs-number">1.</span>通过遍历寻找			——费时间<br><span class="hljs-number">2.</span>再增设前驱、后继指针域	——增加了存储负担<br><span class="hljs-number">3.</span>利用二叉链表的空的指针域<br><br>	如果某个结点的左孩子为空，则将空的左孩子指针域改为<span class="hljs-string">&#x27;指向其前驱&#x27;</span>；如果某结点的右孩子为空，则将空的右孩子指针域改为<span class="hljs-string">&#x27;指向其后继&#x27;</span><br>    	——<span class="hljs-string">&#x27;这种改变指向的指针称为&quot;线索&quot;&#x27;</span><br>    线索二叉树——Threaded Binary Tree<br><br>对二叉树按某种遍历次序使其变为线索二叉树的过程叫<span class="hljs-string">&#x27;线索化&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p>森林是m(m&gt;&#x3D;0)课互不相交的树的集合</p>
<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">实现：定义<span class="hljs-string">&#x27;结构数组&#x27;</span>，存放树的结点、没个结点含两个域<br>	数据域：存放结点本身的信息<br>	双亲域:指示本结点的双亲结点在数组中的位置<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">特点：找双亲容易，找孩子难<br></code></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>	TElemType data;<br>	<span class="hljs-type">int</span> parent;		<span class="hljs-comment">//双亲位置域</span><br>&#125;PTNode;<br><br>树结构：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	PTNode nodes[MAX_TREE_SIZE];<br>	<span class="hljs-type">int</span> r, n; <span class="hljs-comment">//根结点的位置和结点个数</span><br>&#125;PTree；<br></code></pre></td></tr></table></figure>

<h3 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储<br>则<span class="hljs-built_in">n</span>个结点有<span class="hljs-built_in">n</span>个孩子链表(叶子的孩子链表为空表)，孩子链表设头指针<br>而<span class="hljs-built_in">n</span>个头指针又组成一个线性表，用顺序表（含<span class="hljs-built_in">n</span>个元素的结构数组）存储。<br></code></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">孩子结点结构：<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>	<span class="hljs-type">int</span>  child;		<span class="hljs-comment">//孩子节点下标的位置</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next;	<span class="hljs-comment">//下一个孩子的指针</span><br>&#125;*ChildPtr;<br>双亲结点结构：<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	TElemType	data;<br>	ChildPtr firstchild;		<span class="hljs-comment">//孩子链表头指针</span><br>&#125;CTBox;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">特点：找孩子容易，找双亲难<br></code></pre></td></tr></table></figure>

<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>二叉树表示法，二叉链表表示法</p>
<p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef struct <span class="hljs-type">CsSNode</span>&#123;<br>	<span class="hljs-type">ElemType</span> data；<br>	struct <span class="hljs-type">CSNode</span> *firstchild，*nextsibling;<br>&#125;<span class="hljs-type">CSNode</span>,*<span class="hljs-type">CSTree</span>;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Ua8oW61pOSC5DNP.png" srcset="/img/loading.gif" lazyload alt="image-20220424180352061"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">左孩子，右兄弟<br>但不利于找双亲<br></code></pre></td></tr></table></figure>

<h3 id="树与二叉树的转化"><a href="#树与二叉树的转化" class="headerlink" title="树与二叉树的转化"></a>树与二叉树的转化</h3><p><img src="https://s2.loli.net/2024/02/24/xFDhO2vfTWycSp9.png" srcset="/img/loading.gif" lazyload alt="image-20220424181505568"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>加线：在兄弟加一条线<br><span class="hljs-number">2.</span>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系<br><span class="hljs-number">3.</span>旋转：以树的根结点为轴心，将整树顺时针转<span class="hljs-number">45</span><br><br>树变二叉树：兄弟相连留长子		<span class="hljs-string">&#x27;长兄如父&#x27;</span><br>    <br><br>二叉树变树：左孩右右连双亲，去掉原来右孩线<br></code></pre></td></tr></table></figure>

<h3 id="森林转化成二叉树"><a href="#森林转化成二叉树" class="headerlink" title="森林转化成二叉树"></a>森林转化成二叉树</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">1.将各棵树分别转换成二叉树<br>2.将每棵树的根结点用线相连<br>3.以第一颗树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构<br><br>树变二叉根相连<br><br>二叉树变森林：去掉全部右孩线，孤立二叉再还原<br><br></code></pre></td></tr></table></figure>

<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p>树：</p>
<p>三种方式：先根，后根，层次遍历</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">先跟遍历：若树不为空，先访问根的结点，然后依次先根遍历各课子树<br>后跟遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点<br>层次遍历：若树不空，则自上而下自左至右访问树中每个结点（队列）<br></code></pre></td></tr></table></figure>

<p>森林：</p>
<p>看成三部分构成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.森林中第一课树的根结点<br>2.森林中第一课树的子树森林<br>3.森林中其他树构成的森林<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">先根：依次从左至右对森林中的每一棵树进行先根遍历<br>中序遍历：<br>	<span class="hljs-number">1.</span>中序遍历森林中第一棵树的子树森林<br>	<span class="hljs-number">2.</span>访问森林中第一颗树的根节点<br>	<span class="hljs-number">3.</span>中序遍历森林中，除第一颗树之外其余树构成的森林<br>		<span class="hljs-string">&#x27;依次从左至右对森林中的每一棵树进行h根遍历&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径<br><br>		结点的路径长度：两结点间路径上的分支数<br><br><span class="hljs-number">2.</span>数的路径长度：从树根到每一个结点的路径长度之和<br>		结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树<br><br><span class="hljs-number">3.</span>权：将树中结点赋给一个有着某种含义的数值，这个数组成为该结点的权<br>		结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积<br>		树的带权路径长度：树中所有叶子结点的带权路径长度之和。<br>    <br>哈夫曼树：最优二叉树（带权路径长度 (WPL)最短的二叉树）<br>    注：<span class="hljs-number">1.</span>满二叉树不一定是哈夫曼树<br>       <span class="hljs-string">&#x27;2.哈夫曼树中权越大的叶子离根近&#x27;</span><br>       <span class="hljs-number">3.</span>具有相同带权结点的哈夫曼树不唯一<br></code></pre></td></tr></table></figure>

<h3 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">贪心算法：构造哈夫曼树时首先选择权值小的叶子结点<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.构造森林全是根<br><span class="hljs-attribute">2</span>.选用两小造新树<br><span class="hljs-attribute">3</span>.删除两小添新人<br><span class="hljs-attribute">4</span>.重复<span class="hljs-number">2</span>，<span class="hljs-number">3</span>剩单根<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>哈夫曼树的结点度数为<span class="hljs-number">0</span>或<span class="hljs-number">2</span>，没有度为<span class="hljs-number">1</span>的结点<br>  	度：结点的子树<br><span class="hljs-number">2.</span>包含n个叶子结点的哈夫曼树中共用<span class="hljs-number">2</span>n<span class="hljs-number">-1</span>个结点<br></code></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">采用顺序存储结构 —— 一维结构数组<br></code></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-type">int</span> weight;<br>	<span class="hljs-type">int</span> parent,lch,rch;<br>&#125;NTNode,*HuffmanTree;<br><br></code></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>初始化HT[<span class="hljs-number">1.</span>.<span class="hljs-number">.2</span>n<span class="hljs-number">-1</span>]: lch = rch = parent =<span class="hljs-number">0</span>;<br><span class="hljs-number">2.</span>输入n个叶子结点：置HT[<span class="hljs-number">1.</span>...n]的weight值<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHUffmanTree</span><span class="hljs-params">(HuffmanTree &amp;HT, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br>    m = <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;		<span class="hljs-comment">//数组共2n-1个元素</span><br>    <br>    HT = <span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];	??/<span class="hljs-number">0</span>不使用所以申请<span class="hljs-number">2</span>n长度 ，<span class="hljs-string">&quot;为啥是2n？？？？？？&quot;</span><br>        <br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;		<span class="hljs-comment">//将2n-1个元素lch = rch = parent =0</span><br>        HT[i].lch = <span class="hljs-number">0</span>;<br>        HT[i].rch = <span class="hljs-number">0</span>;<br>        HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n,i++)&#123;<br>        cin&gt;&gt;HT[i].weight;	<span class="hljs-comment">//输入前n个元素的weight值</span><br>    &#125;<br>&#125;<span class="hljs-comment">//初始化结束，开始建立哈夫曼树</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3.</span>进行以下n<span class="hljs-number">-1</span>次合并，依次产生n<span class="hljs-number">-1</span>个结点HT[i],i=n+<span class="hljs-number">1.</span>..<span class="hljs-number">.2</span>n<span class="hljs-number">-1</span><br>	a) 在HT[<span class="hljs-number">1.</span>..i<span class="hljs-number">-1</span>]中选两个未被选过(从parent == <span class="hljs-number">0</span>的结点中选)的weight最小的两个结点HT[s1]和HT[s2],s1,s2为两个最小结点下标<br>	b)修改HT[s1]和HT[s2]的parent值：HT[s1].parent=i;HT[s2].parent=i;<br>	c)修改新产生的HT[i]<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>		HT[i].lch = s1; HT[i].rch = s2;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i = n+<span class="hljs-number">1</span>; i&lt;m;i++)&#123;<br>	<span class="hljs-built_in">Select</span>(HT,i<span class="hljs-number">-1</span>,s1,s2);	<span class="hljs-comment">//在HT[k](1&lt;=k&lt;=i-1)中选择两个双亲域为0，</span><br>    						<span class="hljs-comment">//且权值最小的结点，并返回他们在HT中的序号 s1和s2</span><br>    <br>    HT[s1].parent=i;HT[s2].parent=i;<span class="hljs-comment">//表示从表F中删除</span><br>    <br>    HT[i].lch = s1; HT[i].rch = s2;		<span class="hljs-comment">//s1,s2为i左右孩子</span><br>    HT[i].weight = HT[s1].weight + HT[s2].weight;	<span class="hljs-comment">//i的权值为左右孩子的权值之和</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><img src="https://s2.loli.net/2024/02/24/OzAbcQmNFWXDBhe.png" srcset="/img/loading.gif" lazyload alt="image-20220501143636920"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">1.为什么哈夫曼编码能够保证是前缀编码？<br>	因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的前缀<br>2.为什么哈夫曼编码能保证字符编码总长最短？<br>	因为哈夫曼树的带权路径长度最短，故字符编码的总长最短<br>	<br>	任一字符的编码都不是另一个字符的编码的前缀—— 前缀编码<br>性质：1.哈夫曼编码是前缀编码<br>	 2.哈夫曼编码是最优前缀码<br>	 <br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanCode</span><span class="hljs-params">(HuffmanTree HT,HuffmanCode &amp;HC,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br>    <br>	HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> *[n+<span class="hljs-number">1</span>];	<span class="hljs-comment">//分配n个字符编码的头指针矢量</span><br>    cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];		<span class="hljs-comment">//分配临时存放编码的动态数组空间</span><br>    cd[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;			<span class="hljs-comment">//编码结束符</span><br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;		<span class="hljs-comment">//逐个字符求哈夫曼编码</span><br>		start = n<span class="hljs-number">-1</span>; c=i; f=HT[i].parent;<br>        <br>        <span class="hljs-keyword">while</span>(f!=<span class="hljs-number">0</span>)&#123;		<span class="hljs-comment">//从叶子结点开始向上回溯，直到根结点</span><br>            --start;		<span class="hljs-comment">//回溯一次start向前指向一个位置</span><br>            <span class="hljs-keyword">if</span>(HT[f].lchild == c)&#123;<br>                cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;	<span class="hljs-comment">//左孩子生成0</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;	<span class="hljs-comment">//又孩子生成1</span><br>            &#125;<br>            c=f; f=HT[f].parent;	<span class="hljs-comment">//继续向上回溯</span><br>        &#125;<span class="hljs-comment">//求出第i个字符的编码</span><br>        HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n - start]; <span class="hljs-comment">//为第i个字符编码分配空间</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);	<span class="hljs-comment">//将求得编码从cd中复制到HC中</span><br>    &#125;<span class="hljs-comment">//for循环结束</span><br>    <br>    <span class="hljs-keyword">delete</span> cd;		<span class="hljs-comment">//s</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">图：<span class="hljs-built_in">G</span>(V,E)<br>	V:顶点(数据元素)的有穷非空集合<br>	E:边的有穷集合<br>	<br>无向图:每条边都是无方向的<br>有向图：每条边都是有方向的<br>完全图：任意两个点都有一条边相连<br>	无向完全图：n个顶点，<span class="hljs-built_in">n</span>(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>条边<br>	有向完全图：n个顶点，<span class="hljs-built_in">n</span>(n<span class="hljs-number">-1</span>)条边<br>	<br>稀疏图：有很少边或弧的图<br>稠密图：有较多边或弧的图<br>网:	边/弧带权的图<br>邻接：有边/弧相连的两个顶点之间的关系<br>		存在(vi,vj),称vi和vj互为邻接点；无先后关系<br>		存在&lt;vi,vj&gt;,称vi邻接到vj，vj邻接于vi；（有序，有先后关系）<br>关联(依附)：边/弧于顶点之间的关系<br>		存在(vi,vj)/&lt;vi,vj&gt;,称该边/弧关联于vi和vj<br>		<br>顶点的度：与该顶点相关联的边的数目，记为TD<br>		在有向图中，顶点的度等于该顶点的入度<span class="hljs-built_in">ID</span>(v)和出度<span class="hljs-built_in">OD</span>(v)之和<br>		<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">有向图中仅一个顶点的入度为0，其余顶点的入度均为1 —— 有向树<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++">路径：连续的边构成的顶点序列<br>路径长度：路径上边弧的数目/权值之和<br>回路(环)：第一个顶点和最后一个顶点相同的路径<br>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径<br>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径<br><br>联通图(强连通图)<br>	在图中，若任何两个顶点v,u都存在v到u的路径，则称G为联通图<br>		无向图——联通图<br>		有向图任意两点联通——强联通图<br>		<br>权和网<br>	图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费<br>		带权的图称为网<br>		<br><br>子图：边和顶点为子集<br><br>联通分量	<span class="hljs-string">&#x27;要求顶点&#x27;</span><br>	无向图G的极大联通子图称为G的连通分量<br>	极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中<span class="hljs-string">&#x27;顶点&#x27;</span>加入，子图不在连通<br>    	（一个非连通图内，拆开后有几部分是连通的）<br>    <br>    有向图G的极大强连通子图称为G的强连通分量<br>    极大强连通子图意思是：该子图是G强连通子图，将G的任何不在该子图中<span class="hljs-string">&#x27;顶点&#x27;</span>加入，子图不在强连通<br>    <br>    <br>极小连通子图:该子图是G的连通子图，在该子图中删除任何一条边，该子图不在连通 <span class="hljs-string">&#x27;要求边&#x27;</span><br>    <br>生成树：包含无向图G所有顶点的极小连通子图<br>    生成森林：对非连通图，由各个连通分量的生成树的集合<br></code></pre></td></tr></table></figure>

<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">多对多的逻辑结构<br><br>图没有顺序存储结构，但可以借助二维数组来表示元素间的关系—— 数组表示法（邻接矩阵）<br><br>链式存储结构—— 多重链表—— 邻接表、邻接多重表，十字链表<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;无向图&#x27;</span><br>无向图的邻接矩阵是对称的<br>	顶点i的度=第i行(列)中<span class="hljs-number">1</span>的个数<br>完全图的邻接矩阵中，对角元素为<span class="hljs-number">0</span>，其余为<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Wzup9jJZVdnBrFe.png" srcset="/img/loading.gif" lazyload alt="image-20220504193841256"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;有向图&#x27;</span><br>第i行含义：以结点vi为尾的弧 (出度边)<br>第i列含义：以结点vi为头的弧 (入度边)<br>    <br>有向图的邻接矩阵可能不是对称的<br>顶点的度 = 第i行元素之和 + 第i列元素之和    <br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/zTGZ8kWb4D179CF.png" srcset="/img/loading.gif" lazyload alt="image-20220504193953459"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;网&#x27;</span> ——有权图<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ki4dEZPHVe81IbJ.png" srcset="/img/loading.gif" lazyload alt="image-20220504193422542"></p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵的存储表示：用两个数组分别存储  顶点表  和  邻接矩阵</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767		<span class="hljs-comment">//表示极大值，即∞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100 			<span class="hljs-comment">//最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;	<span class="hljs-comment">//设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;		<span class="hljs-comment">//假设边的权值类型为整形</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    VerTexType vexs[MVNum];		<span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];		<span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;			<span class="hljs-comment">//图的当前点数和边数</span><br>&#125;AMGraph;		<br>		<span class="hljs-comment">///Adjacency Matrix Graph</span><br></code></pre></td></tr></table></figure>

<h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>邻接矩阵表示法创建无向网</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">算法思想<br><span class="hljs-number">1.</span>输入总顶点数和总边数<br><span class="hljs-number">2.</span>依次输入点的信息存入顶点表中<br><span class="hljs-number">3.</span>初始化邻接矩阵，使每个权值初始化为极大值<br><span class="hljs-number">4.</span>构造邻接矩阵<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span></span>&#123;<br>    					<span class="hljs-comment">//采用邻接矩阵表示法，创建无向网G</span><br>	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;	<span class="hljs-comment">//输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)&#123;<br>        cin&gt;&gt;G.vexs[i];		<span class="hljs-comment">//依次输入点的信息</span><br>    &#125;<br>    	<br>    <span class="hljs-comment">//初始化邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.vexnum;++j)&#123;<br>            G.arcs[i][j] = MaxInt;	<span class="hljs-comment">//边的权值均置为极大值</span><br>        &#125;<br>    &#125;<br>    	<br>    <span class="hljs-comment">//构造邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.arcnum;++k)&#123;<br>        cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;  <span class="hljs-comment">//输入一条边所依附的顶点及边的权值</span><br>        <br>        i = <span class="hljs-built_in">LocateVex</span>(G,v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G,v2);		<span class="hljs-comment">//确定v1和v2在G中的位置(顶点表vexs[]下标)</span><br>        <br>        G.arcs[i][j] = w;  		<span class="hljs-comment">// 边&lt;v1,v2&gt;的权值置为w</span><br>        G.arcs[j][i] = G.arcs[i][j]		<span class="hljs-comment">//置&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;权值为w</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>补充算法——查找顶点的下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;G.vexnum;++i)&#123;<br>		<span class="hljs-keyword">if</span>(u==G.vexs[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/OraH5CPNcod8ELh.png" srcset="/img/loading.gif" lazyload alt="image-20220504231426847"></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl">邻接矩阵：<br>优点：直观，简单，好理解<br>	 方便检查任意<br>	 <br>缺点：不利于增加和删除顶点<br>	 浪费空间——存稀疏图，有大量无效元素<br>	 		——对稠密图（特别是完全图）还是合算的<br>	浪费时间——统计稀疏图中一共有多少条边，<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>^<span class="hljs-number">2</span>)</span><br></code></pre></td></tr></table></figure>

<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><img src="https://s2.loli.net/2024/02/24/RdQyF6umpXecsSC.png" srcset="/img/loading.gif" lazyload alt="image-20220505144317856"></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">无向图：<br>特点：<br>	<span class="hljs-number">1</span>.邻接表不唯一<br>	<span class="hljs-number">2</span>.若无向图中有<span class="hljs-built_in">n</span>个顶点，e条边，则其邻接表需要<span class="hljs-built_in">n</span>个头结点和<span class="hljs-number">2</span>e个表结点，事宜存稀疏图。<br>	<span class="hljs-number">3</span>.无向图顶点的度vi为第i个单链表中的结点数<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">有向图：<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/i5CkE7VyeXARS9g.png" srcset="/img/loading.gif" lazyload alt="image-20220505235315869"></p>
<h4 id="邻接表建立定义"><a href="#邻接表建立定义" class="headerlink" title="邻接表建立定义"></a>邻接表建立定义</h4><p>顶点的结点结构</p>
<pre><code class="hljs"> data + firstarc
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span>&#123;<br>	VerTexType data;		<span class="hljs-comment">//顶点信息</span><br>	ArcNode *firstarc;		<span class="hljs-comment">//指向第一条依附该顶点的边的指针</span><br>&#125;VNode，AdjList[NVNum];		<span class="hljs-comment">//AdjList 表示邻接表类型</span><br></code></pre></td></tr></table></figure>

<p>边结点结构</p>
<p>​	adjvex + nextarc + info</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100			<span class="hljs-comment">//最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>&#123;		<span class="hljs-comment">//边结点</span><br>    <span class="hljs-type">int</span> adjvex;			<span class="hljs-comment">//该边所指向的顶点的位置</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> *nextarc;	<span class="hljs-comment">//指向的下一条边的指针</span><br>    OtherInfo info;			<span class="hljs-comment">//和边相关的信息 ——权</span><br>&#125;ArcNode;<br></code></pre></td></tr></table></figure>

<p>图的结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	AdjList vertices;		<span class="hljs-comment">//顶点集</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;	<span class="hljs-comment">//图的当前顶点数和弧数</span><br>&#125;ALGraph; <br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/CoZmHnP7t9iykG8.png" srcset="/img/loading.gif" lazyload alt=" "></p>
<h4 id="创建无向网"><a href="#创建无向网" class="headerlink" title="创建无向网"></a>创建无向网</h4><p>算法思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>输入顶点数和总边数<br><span class="hljs-number">2.</span>建立顶点表<br>	依次输入点的信息存入顶点表中<br>	使每个表头结点的指针域初始化为<span class="hljs-literal">NULL</span><br><span class="hljs-number">3.</span>创建邻接表<br>	依次输入每条边依附的两个顶点<br>	<span class="hljs-string">&#x27;确定两个顶点的序号i和j，建立边结点&#x27;</span><br>	<span class="hljs-string">&#x27;将此边结点分别插入到vi和vj对应的两个边链表的头部&#x27;</span><br></code></pre></td></tr></table></figure>

<p>临界表示法创建无向图G</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span></span>&#123;   <br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;	<span class="hljs-comment">//输入总顶点数和边数</span><br>    <br>    <span class="hljs-comment">//输入各点，构造表头结点表</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)&#123;			<br>        cin&gt;&gt;G.vertices[i].data;		<span class="hljs-comment">//输入点值</span><br>        G.vertices[i].firstarc=<span class="hljs-literal">NULL</span>;	<span class="hljs-comment">//初始化表头结点的指针域</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//输入各边，构造邻接表</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.arcnum;++k)&#123;<br>        cin&gt;&gt;v1&gt;&gt;v2;<br>        i = <span class="hljs-built_in">LocateVex</span>(G,v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G,v2);<br>        <br>        p1 = <span class="hljs-keyword">new</span> ArcNode;		<span class="hljs-comment">//生成一个新的边结点*p1</span><br>        p1-&gt;adjvex=j;			<span class="hljs-comment">//邻接点序号为j</span><br>        q<br>        <br>        G.vertices[i].firstarc=p1;	<span class="hljs-comment">//*p1插入顶点vi的边表头部</span><br>        	<span class="hljs-comment">//1.先接上屁股，2在把头拼回去</span><br>        <br>        <span class="hljs-comment">//为无向图，所以i-&gt;j的边建立完成还需建立j-&gt;i的边</span><br>        p2 = <span class="hljs-keyword">new</span> ArcNode;		<br>        p2-&gt;adjvex=i;			<br>        p1-&gt;nextarc = G.vertices[j].firstarc;		<br>        G.vertices[j].firstarc=p2;   <br>    &#125;<span class="hljs-comment">//for</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="邻接表特点"><a href="#邻接表特点" class="headerlink" title="邻接表特点"></a>邻接表特点</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>.方便查找任一顶点的所有<span class="hljs-string">&quot;邻接点&quot;</span><br><span class="hljs-number">2</span>.节约稀疏图的空间<br><span class="hljs-number">3</span>.方便计算任意节点的度<br>	对于无向图：是的<br>	有向图：只能计算出度；构造<span class="hljs-string">&quot;逆邻接表&quot;</span> 方便计算<span class="hljs-string">&quot;入度&quot;</span><br></code></pre></td></tr></table></figure>

<p>邻接矩阵和邻接表的区别</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">对于任一确定的无向图<br>	邻接矩阵是唯一的，但邻接表不唯一<br>空间复杂度<br>	邻接矩阵<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>) 邻接表<span class="hljs-built_in">O</span>(n+e)<br></code></pre></td></tr></table></figure>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p><img src="https://s2.loli.net/2024/02/24/kupao5rOqfG2UiJ.png" srcset="/img/loading.gif" lazyload alt="image-20220506170015188"></p>
<p>十字链表是有向图的另一种链式存储结构，可以看成是邻接表和逆邻接表结合起来的一链表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">在顶点节点中增加一个指针域<br>	同时计算入度和出度<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/9pau1L7JDh86UqN.png" srcset="/img/loading.gif" lazyload alt="image-20220507100258033"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><img src="https://s2.loli.net/2024/02/24/nqDkcUEzlQI7h83.png" srcset="/img/loading.gif" lazyload alt="image-20220507100941657"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 DFS"></a>深度优先遍历 DFS</h3><p>邻接矩阵实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    cout &lt;&lt; v;	visited[v] = <span class="hljs-literal">true</span>;		<span class="hljs-comment">//访问第v个顶点, visited辅助数组,确保只访问一次</span><br>    <span class="hljs-keyword">for</span>(w = <span class="hljs-number">0</span>; w &lt; G.vexnum; w++)&#123;<br>        <span class="hljs-keyword">if</span>((G.arcs[v][M]!=<span class="hljs-number">0</span>)&amp;&amp;(!visited[w]))&#123;<br>            <span class="hljs-built_in">DFS</span>(G,w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">从图的某一顶点出发,依次访问该结点所有邻接点,在按这些顶点被访问的先后次序访问与他们相邻接的所有未被访问的顶点<br>		<span class="hljs-comment">//类似于层次遍历</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/1NaRXr8OpVAjLdc.png" srcset="/img/loading.gif" lazyload alt="image-20220507112122764"></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">生成树<span class="hljs-symbol">:</span>所有顶点均连接在一起，但不存在回路的图<br>生成树特点：<br>	<span class="hljs-number">1</span>.顶点个数与图相同<br>	<span class="hljs-number">2</span>.生成树是图的极小连通子图，去掉一条边则非连通<br>	<span class="hljs-number">3</span>.一个有<span class="hljs-built_in">n</span>个顶点的连通图的生成树有<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>条边<br>	<span class="hljs-number">4</span>.在生成树中在加一条边必然形成回路<br>	<span class="hljs-number">5</span>.生成树两个顶点间的路径是唯一的<br>	<br>最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为该网的最小生成树，也叫最小代价生成树<br></code></pre></td></tr></table></figure>

<h3 id="构造最小生成树"><a href="#构造最小生成树" class="headerlink" title="构造最小生成树"></a>构造最小生成树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">MST性质：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)d<br><br>图中n个顶点分为两个集合：<br>	已落在生成树上的顶点集: U<br>	尚未落在生成树上的顶点集：V-U<br>在所有连通U中顶点和V-U中顶点的边中选取<span class="hljs-string">&#x27;权值最小的边&#x27;</span><br></code></pre></td></tr></table></figure>

<h4 id="Prim-普里姆算法"><a href="#Prim-普里姆算法" class="headerlink" title="Prim 普里姆算法"></a>Prim 普里姆算法</h4><p>算法思想</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>.设<span class="hljs-built_in">N</span>=(V,E)是连通网，TE是<span class="hljs-built_in">N</span>上最小生成树中边的集合<br><span class="hljs-number">2</span>.初始令U=&#123;<span class="hljs-symbol">u0</span>&#125;顶点集,(<span class="hljs-symbol">u0</span>属于V)，TE=&#123;&#125;边权为<br><span class="hljs-number">3</span>.在剩余边集中选择一条代价最小的(<span class="hljs-symbol">u0</span>,<span class="hljs-symbol">v0</span>)边 ，(已经在生成树上的点与为在生成树上的点边权最小的边)<br><span class="hljs-number">4</span>.将(<span class="hljs-symbol">u0</span>,<span class="hljs-symbol">v0</span>)并入集合TE，同时<span class="hljs-symbol">v0</span>并入顶点集U<br><span class="hljs-number">5</span>.重复操作直至 U=V为至，则<span class="hljs-built_in">T</span>=(V,TE)为<span class="hljs-built_in">N</span>的最小生成树<br></code></pre></td></tr></table></figure>

<h4 id="kruskal-克鲁斯卡尔算法"><a href="#kruskal-克鲁斯卡尔算法" class="headerlink" title="kruskal 克鲁斯卡尔算法"></a>kruskal 克鲁斯卡尔算法</h4><p><img src="https://s2.loli.net/2024/02/24/c8bMn7I4AZ6w1q9.png" srcset="/img/loading.gif" lazyload alt="image-20220508203509087"> </p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>问题：在有向网中A点到B点的所有路径的中，寻找一条边权最小的路径，及最短路径</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">单源最短路径——<span class="hljs-keyword">Dijkstra </span>迪杰斯特拉算法<br>所有顶点之间——Floyd 弗洛伊德算法<br></code></pre></td></tr></table></figure>

<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>算法思想</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.初始化：先找出从源点<span class="hljs-built_in">v0</span>到各终点vk的直达路径（<span class="hljs-built_in">v0</span>,vk），即通过一条弧到达的路径<br>		无法到达的点，路径长度设为无穷大<br><span class="hljs-number">2</span>.选择：从这些路径中找出一条长度最短的路径（<span class="hljs-built_in">v0</span>,u)<br><br><span class="hljs-number">3</span>.更新：然后对其余各条路径进行适当调整<br>		若在图中存在弧（u,vk），且（<span class="hljs-built_in">v0</span>,u）+（u，vk）&lt; (<span class="hljs-built_in">v0</span>,vk)<br>		则以路径(<span class="hljs-built_in">v0</span>,u,vk)代替(<span class="hljs-built_in">v0</span>,vk)<br>		<br>		已经找到顶点的集合放在 S集合，为找到路径顶点放在T集合 = V-S<br>在调整之后的各条路径中，再寻找长度最短的路径。..<br></code></pre></td></tr></table></figure>

<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Dijkstra:</span>按路径长度递增次序产生最短路径<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/FyxQdHh1Zpef86w.png" srcset="/img/loading.gif" lazyload alt="image-20220530221933287"></p>
<p><img src="https://s2.loli.net/2024/02/24/jGtdF3zlaPmKHQR.png" srcset="/img/loading.gif" lazyload alt="image-20220530222918295"></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>在查找表中找：</p>
<p>​		查找表是由同一类型的数据构成的集合。由于”集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">查找表分为两类：<br>	静态查找表，动态查找表<br>	<br>ASL	： 平均查找长度<br></code></pre></td></tr></table></figure>

<h2 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>​	应用范围：顺序表或线性链表表示的静态查找表</p>
<p>​	表内元素之间无序</p>
<p>数据元素类型定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	KeyType key;	<span class="hljs-comment">//关键字域</span><br>	....			<span class="hljs-comment">//其他域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	ElemType *R;	<span class="hljs-comment">//表基质</span><br>	<span class="hljs-type">int</span> length;		<span class="hljs-comment">//表长</span><br>&#125;SSTable;<br>SSTable ST <span class="hljs-comment">//定义顺序表</span><br></code></pre></td></tr></table></figure>

<p>在顺序表ST中查找值为key的数据元素，从最后一个元素开始比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST ,KeyType Key)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(i=ST.length; i&gt;=<span class="hljs-number">1</span>; --i)&#123;<br>		<span class="hljs-keyword">if</span>(ST.R[i].key == key ) <span class="hljs-keyword">return</span> i;		<span class="hljs-comment">//返回的是下标的位置</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST ,KeyType Key)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(i=ST.length; ST.R[i].key != key; --i)<br>        <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;		<span class="hljs-comment">//未找到元素从这里结束</span><br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种算法每次都需要比较两次，</p>
<p>可以引入“监视哨”（将关键字key存入表头），从而免去没一步都需要检查是否查找完毕</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//设置监视哨的顺序查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST ,KeyType Key)</span></span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-keyword">for</span>(i=ST.length; ST.R[i].key != key; --i);	<span class="hljs-comment">//此循环体没有语句</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ST.length较大时，此改进可以使查找时间缩短一半<br><br><span class="hljs-string">&#x27;时间复杂度：（n+1）/2&#x27;</span>	查找概率相等<br>空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/TYwmCyPUj9sqON8.png" srcset="/img/loading.gif" lazyload alt="image-20220605113121244"></p>
<p>优点：算法简单，逻辑次序无要求，不同储存结构都适用</p>
<p>缺点：ASL太长，时间效率太低</p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>​	——二分法 </p>
<p>元素是有序的</p>
<p>折半查找：每次将待查找记录所在区间缩小一半</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">初始：令low=<span class="hljs-number">1</span>， high = n; mid = (low+high)/<span class="hljs-number">2</span> 的底<br><br>mid = (low+high)/<span class="hljs-number">2</span><br>key&lt;mid 则：high = mid <span class="hljs-number">-1</span><br>key&gt;mid 则：low = mid + <span class="hljs-number">1</span><br>key == mid ,找到<br><br>high &lt; low ,查找失败<br></code></pre></td></tr></table></figure>

<p>二分法，折半查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, keyType key)</span></span>&#123;<br>    low = <span class="hljs-number">1</span>; high = ST.length;	<span class="hljs-comment">//置区间初值</span><br>    <br>    <span class="hljs-keyword">while</span> (low &lt;= high)&#123;	<br>        mid = (low + high)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span>(ST.R[mid].key == key)&#123;<br>            <span class="hljs-keyword">return</span> mid;		<span class="hljs-comment">//查找成功</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key)&#123;	<span class="hljs-comment">//缩小查找区间</span><br>            high = mid <span class="hljs-number">-1</span>;	<span class="hljs-comment">//在前半区继续查找</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            low = mid +<span class="hljs-number">1</span>; 	<span class="hljs-comment">//在后半取继续查找</span><br>        &#125;       <br>    &#125;<span class="hljs-comment">//循环结束条件：1.查找成功 2.low &gt;high</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<span class="hljs-comment">//不存在查找元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>递归算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, keyType key， <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<span class="hljs-comment">//找不到时返回0</span><br>    mid = (low + high)/<span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">if</span>(key = ST.R[mid].key) <span class="hljs-keyword">return</span> mid;	<span class="hljs-comment">//查询成功 返回值</span><br>    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key)&#123;<br>        high = mid <span class="hljs-number">-1</span>;	<span class="hljs-comment">//缩小查找区间</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST, key, low, high);	<span class="hljs-comment">//在前半区查找</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        low = mid + <span class="hljs-number">1</span>;	<span class="hljs-comment">//缩小查找区间</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST, key, low, high);	<span class="hljs-comment">//在后半区查找</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/deOR5ojfVENrZtT.png" srcset="/img/loading.gif" lazyload alt="image-20220605120459531"></p>
<p><img src="https://s2.loli.net/2024/02/24/mS1MZ9BDVOtrHPe.png" srcset="/img/loading.gif" lazyload alt="image-20220605122150613"></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">ASL = lo<span class="hljs-name">g2</span><span class="hljs-comment">(n+1)</span> - <span class="hljs-number">1</span><br>优点：效率比较高 <br>缺点：只适用于有序表，且限于顺序储存结构（对线性链表无效）<br></code></pre></td></tr></table></figure>

<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>索引顺序表的查找</p>
<p>条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>将表分成几块，且表或者有序， 或者<span class="hljs-string">&quot;分块有序&quot;</span>(块内无序，块间有序)<br>    若i&lt;j,则第j块中所有记录的关键字均大于第i块中的最大关键字<br><br><span class="hljs-number">2.</span>建立索引表<br>    （每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）<br>    <br>查找过程：先确定待查记录所在块，再在块内查找<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/dzVOjlTKtiRgMsP.png" srcset="/img/loading.gif" lazyload alt="image-20220605124023172"></p>
<p><img src="https://s2.loli.net/2024/02/24/tw3iJ5NlASLhekE.png" srcset="/img/loading.gif" lazyload alt="image-20220605124255146"></p>
<h2 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h2><p>当表插入、删除操作频繁操作时，为维护表的有序性，需要移动表中记录，</p>
<p>改用动态查找表——</p>
<p>表结构在查找过程中动态生成</p>
<p>对于给定key 若表中存在，则成功返回，否则，插入关键字等于key的记录</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树：又称为二叉搜索树，二叉查找树</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.若其左子树非空，则左子树上所有结点的值均小于根结点的值<br>2.若其右子树非空，则右子树上所有结点的值均大于根节点的值<br>3.其左右子树本身又各是一颗二叉排序树<br></code></pre></td></tr></table></figure>

<p>存储结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	KeyType key;<br>	InfoType otherinfo;<br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span>&#123;<br>    ElemType data;		<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;	<span class="hljs-comment">//左右孩子指针</span><br>&#125;BSTNode, *BSTree;<br><br>BSTree T;	<span class="hljs-comment">//定义二叉排序树</span><br></code></pre></td></tr></table></figure>

<p>算法思想：递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree, KeyType key)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((!T)||key==T-&gt;data.key) <span class="hljs-keyword">return</span> T;	<span class="hljs-comment">//找到返回</span><br>    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild ,key);	<span class="hljs-comment">//在左子树中继续查找</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild ,key);	<span class="hljs-comment">//在右子树中继续查找</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>二叉排序的查找</p>
<p>查找效率看树的深度有关</p>
<p><img src="https://s2.loli.net/2024/02/24/LEtnxGCUqg6Iy4o.png" srcset="/img/loading.gif" lazyload alt="image-20220607140344084"></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>算法思想</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">若二叉排序树为空，则插入结点作为根结点插入到空树中<br>否则，继续在其左右子树上查找<br>	树中已有，不再插入<br>	树中没有<br>		查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或者右孩子<br></code></pre></td></tr></table></figure>



<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">一个无序序列可以通过构造二叉排序树从而变成一个有序序列<br>	插入的结点均为叶子结点，故无需移动其他结点<br>	<br>	但：关键字的输入顺序不同，建立的二叉树不同<br></code></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">注意的问题：<br>	1.将因删除结点而断开的二叉链表重新链接起来<br>	2.防止重新链接后树的高度增加<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.删除结点是叶子结点：直接删除该结点<br>2.被删除结点只有左子树或者只有右子树，则用其左子树或者右子树替换他<br>3.被删除的结点既有左子树又有右子树<br>	用其中序前驱值替换，在删除前驱结点（采用递归）<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/qzwBTPu3s6oyfSc.png" srcset="/img/loading.gif" lazyload alt="image-20220607152918132" style="zoom:25%;" />

<img src="https://s2.loli.net/2024/02/24/Fae6RslHujzrP4J.png" srcset="/img/loading.gif" lazyload alt="image-20220607153008800" style="zoom:25%;" />

<img src="https://s2.loli.net/2024/02/24/LcC1Qrok2m4j98w.png" srcset="/img/loading.gif" lazyload alt="image-20220607153531347" style="zoom:44%;" />

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>解决形态不均衡的二叉排序树的查找效率，做平衡化处理，使其称为平衡二叉树</p>
<p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">平衡二叉树  AVL树<br>一颗平衡二叉树或者空树，或是具有下列性质的二叉排序树<br>	<span class="hljs-number">1.</span>左子树与右子树高度之差的绝对值小于等于<span class="hljs-number">1</span><br>	<span class="hljs-number">2.</span>左子树和右子树也是平衡二叉排序树<br>	<br>为了方便起见， 给每个结点附加一个数字，给出该结点左子树与右子树的高度差 ——平衡因子BF<br>	平衡因子 = 结点左子树的高度 - 结点右子树的高度 （<span class="hljs-number">-1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当我们在一个平衡二叉排序树上插入一个结点，可能会导致失衡<br></code></pre></td></tr></table></figure>

<h4 id="平衡调整"><a href="#平衡调整" class="headerlink" title="平衡调整"></a>平衡调整</h4><p><img src="https://s2.loli.net/2024/02/24/7FOLdp3sY9ySBt8.png" srcset="/img/loading.gif" lazyload alt="image-20220607161143042"></p>
<p><img src="https://s2.loli.net/2024/02/24/3Xt1UGZ97Ty6JVP.png" srcset="/img/loading.gif" lazyload alt="image-20220607161209790"></p>
<p>调整原则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.降低高度<br>2.保持二叉树排序性质 （老二作根）<br></code></pre></td></tr></table></figure>



<h2 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h2><p>基本思想：记录存储位置与关键字之间的关系</p>
<p>散列函数——Hash</p>
<p>优点：查找效率高 O（1），空间效率低</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode">散列方法：<br>	选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放，查找时，由同一个函数对给定值计算地址<br>	将k与地址单元中元素是关键码进行比，确定查找是否成功<br>	<br>散列函数：散列方法中使用的转化函数<br>散列表：按上述方法构成的表<span class="hljs-comment">(数组)</span><br><br>冲突：不同的关键码映射到同一个散列地址<br>		key<span class="hljs-number">1</span> != key<span class="hljs-number">2</span>  但 H<span class="hljs-comment">(key1)</span> = H<span class="hljs-comment">(key2)</span><br></code></pre></td></tr></table></figure>

<h3 id="散列函数构造"><a href="#散列函数构造" class="headerlink" title="散列函数构造"></a>散列函数构造</h3><p>考虑因素</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1.执行速度<br>2.关键字长度<br>3.散列表的大小<br>4.关键字的分布频率<br>5.查找频率<br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">要求：<span class="hljs-number">1</span>.<span class="hljs-built_in">n</span>个数据原仅占用<span class="hljs-built_in">n</span>个地址，虽然散列查找是以空间换时间，但仍希望散列的空间尽量小<br>	<span class="hljs-number">2</span>.无论用什么方法存储，目的都是尽量均匀的存放元素，以避免冲突<br>	<br>构造方法：<br>	<span class="hljs-number">1</span>.直接定值法 <span class="hljs-number">5</span>.除留余数法<br></code></pre></td></tr></table></figure>

<h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hash</span><span class="hljs-params">(key)</span></span> = a*key + <span class="hljs-selector-tag">b</span><br>优点：key的线性函数为散列地址，不会产生冲突<br>缺点：要占用连续地址空间，空间效率低<br></code></pre></td></tr></table></figure>

<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(key)</span></span> = key mod <span class="hljs-selector-tag">p</span> (p是一个整数)<br>关键：如何选取合适的p？<br>技巧：设表长为m，取p&lt;=m且为质数<br></code></pre></td></tr></table></figure>

<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">有冲突时就去寻找下一个空的散列地址值，只要散列列表足够大，肯定能找到<br>	除留余数法 ： <span class="hljs-string">&#x27;Hi = (Hash(key)+di) mod m  di 为增量序列&#x27;</span><br>	<br>	di确定常用方法：	<br> q<br>	<span class="hljs-number">2.</span>二探测法：di为 <span class="hljs-number">1</span>^<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>^<span class="hljs-number">2</span>, <span class="hljs-number">2</span>^<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>^<span class="hljs-number">2</span>,...二次序列<br>	<span class="hljs-number">3.</span>伪随机探测法：di为伪随机数序列<br></code></pre></td></tr></table></figure>

<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">基本思想：散列地址相同的记录成一单链表<br>m个散列表地址就设m个单链表，然后用一个数组将m个单链表的表头指针储存起来<br></code></pre></td></tr></table></figure>

<p>建立步骤</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>.取关键字<span class="hljs-keyword">key</span> ，计算其散列函数值（地址）若该地址对应链表为空，则将元素插入链表，否则执行<span class="hljs-number">2</span><br><span class="hljs-number">2</span>，根据冲突处理，计算关键字<span class="hljs-keyword">key</span>的下一个存储地址，若该地址对应链表不为空，则利用链表前插/或后插<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优点：非同义词不会冲突，无聚集现象<br>链表上结点空间动态申请，更适合于表长不确定情况<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/SeoREfLG3D76Nzv.png" srcset="/img/loading.gif" lazyload alt="image-20220608120351760"></p>
<p><img src="https://s2.loli.net/2024/02/24/Fe9tDahKXl5nC7B.png" srcset="/img/loading.gif" lazyload alt="image-20220608120403125"></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">插入排序：直接插入排序，折半插入排序，希尔排序<br>交换排序：冒泡排序，快速排序<br>选择排序：简单选择排序，堆排序<br>归并排序：2-路归并排序<br>基数排序<br></code></pre></td></tr></table></figure>

<p>储存结构——记录序列以顺序表存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;		<span class="hljs-comment">//定义每个数据元素的结构</span><br>	KeyType key;<br>	InfoType  otherinfo;<br>&#125;RedType;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;		<span class="hljs-comment">//定义顺序表的结构</span><br>	RedType r[MAXSIZE + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span> length;<br>&#125;SqList<br></code></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>前半段有序，后半段无序</p>
<p>寻找插入位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">顺序法确定 	—— 直接插入排序<br>二分法确定	—— 二分插入排序<br>缩小增量多遍插入排序		—— 希尔排序<br></code></pre></td></tr></table></figure>

<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>复制插入元素<br>	x=a[i]<br><span class="hljs-number">2.</span>记录后移，查找插入位置<br>    <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;a[j];j--)&#123;<br>        a[j+<span class="hljs-number">1</span>] = a[i];		<span class="hljs-comment">//向后移动</span><br>    &#125;<br><span class="hljs-number">3.</span>插入到正确位置 a[j+<span class="hljs-number">1</span>] = x;<br></code></pre></td></tr></table></figure>

<p>使用哨兵 </p>
<p>​	顺序表0号位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>复制为哨兵 L.r[<span class="hljs-number">0</span>] = L.r[i]<br><span class="hljs-number">2.</span>记录后移，查询插入位置<br>	<span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;L.r[<span class="hljs-number">0</span>].key&lt;L.r[j];j--)&#123;<br>		L.r[j+<span class="hljs-number">1</span>] = L.r[j];<br>    &#125;<br><span class="hljs-number">3.</span>插入到正确位置<br>    L.r[j+<span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=L.lengthl;++i)&#123;<br>		<span class="hljs-keyword">if</span>(L.r[i].key &lt; L.r[i<span class="hljs-number">-1</span>].key)&#123;<br>            L.r[<span class="hljs-number">0</span>] = L.r[i]		<span class="hljs-comment">//哨兵</span><br>			<span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;L.r[<span class="hljs-number">0</span>].key&lt;L.r[j];j--)&#123;	<span class="hljs-comment">//寻找移动</span><br>				L.r[j+<span class="hljs-number">1</span>] = L.r[j];<br>    		&#125;	<br>            L.r[j+<span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];		<span class="hljs-comment">//插入</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">原始数据越接近有序，排序速度越块<br>最坏情况下	<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)	最后情况<span class="hljs-built_in">O</span>(n)	平均情况<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)<br><br>空间复制度 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 只需要一个哨兵<br></code></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p><img src="https://s2.loli.net/2024/02/24/gZxR3h7f6MqVXvk.png" srcset="/img/loading.gif" lazyload alt="image-20220610151850605"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">改进了查找sulv，但仍需移动，时间f<br></code></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>定义增量Dk，对每个Dk-间隔进行插入排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span> <span class="hljs-params">(SQlist &amp;L, <span class="hljs-type">int</span> dlta[], <span class="hljs-type">int</span> t)</span></span>&#123;<br>	<span class="hljs-comment">//按增量序列dlta[0..t-1]对顺序表L作希尔排序</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;t; ++k)<br>        <span class="hljs-built_in">Shelllnsert</span>(L, dlta[k]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shelllnsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dk)</span></span>&#123;	<span class="hljs-comment">//步长为dk的插入排序</span><br>    <span class="hljs-keyword">for</span>(i=dk+<span class="hljs-number">1</span>; i&lt;=L.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(r[i].key &lt; r[i-dk].key)&#123;<br>            r[<span class="hljs-number">0</span>]=r[i];<br>            <span class="hljs-keyword">for</span>(j=i-dk; j&gt;<span class="hljs-number">0</span> &amp;&amp; (r[<span class="hljs-number">0</span>].key &lt; r[j].key); j=j-dk)<br>                r[j+dk] = r[j];<br>            r[j+dk] = r[<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">希尔排序是一种不稳定的排序算法<br>	增量序列，最后一位必须为0<br></code></pre></td></tr></table></figure>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span>个记录，总共需要<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>趟<br>第m趟需要比较<span class="hljs-built_in">n</span>-m次<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n<span class="hljs-number">-1</span>; m++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n-i; j++)<br>            <span class="hljs-keyword">if</span>(r[j].key &gt; r[j+<span class="hljs-number">1</span>].key)&#123;<br>                x=r[j];<br>                r[j]=r[j+<span class="hljs-number">1</span>]<br>				r[j+<span class="hljs-number">1</span>] = x<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">优点：每趟结束，选最大放倒最后面<br>时间复杂度：<br>	最好正序 比较<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>，移动<span class="hljs-number">0</span>	<span class="hljs-built_in">n</span>(<span class="hljs-comment"></span>)<br>	最坏 O(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>任取一个元素为中心<br><span class="hljs-number">2.</span>所以比他小的元素前放，比它大的元素一律后放，形成左右两个子表<br><span class="hljs-number">3.</span>对各子表重新选择中心并依此规则调整<br><span class="hljs-number">4.</span>直到每个子表的元素只剩一个<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.每一趟的子表的形成是采用从两头向中间交替式逼近法<br>2,每趟中对各子表的操作都相似，可采用递归算法<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">QSort</span>(L,<span class="hljs-number">1</span>,L.length);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SQList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;	<span class="hljs-comment">//长度大于1 (子表中元素只剩一个时停止)</span><br>        pivotloc = <span class="hljs-built_in">Partition</span>(L,low,high);<br>        <span class="hljs-comment">//将线性表分成两部分，pivotloc为枢轴元素排好序位置 （中间值）</span><br>        <br>        <span class="hljs-built_in">QSort</span>(L,low,pivotloc<span class="hljs-number">-1</span>);	<span class="hljs-comment">//对低子表递归排序</span><br>        <span class="hljs-built_in">QSort</span>(L,pivotloc+<span class="hljs-number">1</span>, high);	<span class="hljs-comment">//对高子表递归排序</span><br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span> <span class="hljs-params">(SQList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    L.r[<span class="hljs-number">0</span>] = L.r[low];  <span class="hljs-comment">//哨兵（选第一个元素作为枢轴 填入哨兵位置）</span><br>    pivotkey = L.r[low].key;	<span class="hljs-comment">//中间值</span><br>    <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>		<span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) --high;<br>        L.r[low] = L.r[high];	<span class="hljs-comment">//找一个大的往前放</span><br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) ++low;<br>        L.r[high] = L.r[low];	<span class="hljs-comment">//找一个小的往后放</span><br>    &#125;	<span class="hljs-comment">//大小交替进行，直至low = high</span><br>    L.r[low] = L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//枢轴填入</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">时间复杂度	： <span class="hljs-built_in">O</span>(nlog2n)<br><br>空间复杂度：快速排序不是原地排序<br>	使用了递归，需要调用栈的支持，栈的长度取决于调用的深度<br>	平均情况下：需要<span class="hljs-built_in">O</span>(logn) 最坏<span class="hljs-built_in">o</span>(n)<br>	<br>快速排序不适合 原本有序的排列方式<br><br>输入数据次序越乱，快排越快，快排不是自然排序方法<br></code></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在待排序的数据中选出最大（小）的元素放在其最终的位置<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/tIB3gq9MVN6n4EO.png" srcset="/img/loading.gif" lazyload alt="image-20220612174328041"></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">时间复杂度： <span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)<br><br>简单选择排序是不稳定排序<br></code></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://s2.loli.net/2024/02/24/NLt3nUiXRkJrzj7.png" srcset="/img/loading.gif" lazyload alt="image-20220612184403867"></p>
<p>堆顶元素拿走之后， 调整剩余元素使其成为堆</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">小根堆：<br>输出根并以最后一个元素代替之，比较其左右孩子的大小，并与其中较小者交换，直至到叶子结点<br></code></pre></td></tr></table></figure>



<p><img src="https://s2.loli.net/2024/02/24/anBkNv1zrGPJ2Eb.png" srcset="/img/loading.gif" lazyload alt="image-20220612192544910"></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl">时间复杂度 <br>	一次重新堆化时间不超过 <span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">logn</span>)</span><br>	<span class="hljs-variable">n</span>-<span class="hljs-number">1</span>次循环所需时间不超过<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>)</span><br>	 <span class="hljs-function"><span class="hljs-title">Tw</span>(<span class="hljs-variable">n</span>) = <span class="hljs-title">O</span>(<span class="hljs-variable">logn</span>) + <span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>) = <span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>)</span><br>	 与数据记录顺序无关， 最好最坏时间复杂度一样<br>	 <br>	 空间复杂度 ：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-number">1</span>)</span><br>	 不稳定排序方式<br></code></pre></td></tr></table></figure>

<h2 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h2><p><img src="https://s2.loli.net/2024/02/24/ukEmTn96axJCvsL.png" srcset="/img/loading.gif" lazyload alt="image-20220612193502836"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/408/" class="category-chain-item">408</a>
  
  
    <span>></span>
    
  <a href="/categories/408/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a>
      
        <a href="/tags/%E8%80%83%E7%A0%94/" class="print-no-link">#考研</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构</div>
      <div>http://example.com/2023/03/03/考研/数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Crx</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月3日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年2月24日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/03/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/" title="常用算法模板">
                        <span class="hidden-mobile">常用算法模板</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
