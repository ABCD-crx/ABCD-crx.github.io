<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客框架搭建</title>
    <url>/2021/10/03/Init/</url>
    <content><![CDATA[<p>Hexo 框架终于创建完成！！！！！</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo clean   <span class="hljs-comment">#清除缓存文件 db.json 和已生成的静态文件 public</span><br><br><br></code></pre></td></tr></table></figure>

<h3 id="创建静态文件"><a href="#创建静态文件" class="headerlink" title="创建静态文件"></a>创建静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo g       <span class="hljs-comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br></code></pre></td></tr></table></figure>

<h3 id="创建本地预览"><a href="#创建本地预览" class="headerlink" title="创建本地预览"></a>创建本地预览</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure>

<h3 id="发布上线"><a href="#发布上线" class="headerlink" title="发布上线"></a>发布上线</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo d       <span class="hljs-comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Fluid</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis笔记</title>
    <url>/2022/09/03/Java/MyBatis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul>
<li>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li>
<li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</li>
</ul>
<h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol>
<li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li>
<li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li>
</ol>
<h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul>
<li><a href="https://github.com/mybatis/mybatis-3">MyBatis下载地址</a></li>
<li><img src="https://s2.loli.net/2024/02/24/ZyuXdb9FEAh5gO6.png"></li>
</ul>
<h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><ul>
<li>JDBC  <ul>
<li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  </li>
<li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  </li>
<li>代码冗长，开发效率低</li>
</ul>
</li>
<li>Hibernate 和 JPA<ul>
<li>操作简便，开发效率高  </li>
<li>程序中的长难复杂 SQL 需要绕过框架  </li>
<li>内部自动生产的 SQL，不容易做特殊优化  </li>
<li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  </li>
<li>反射操作太多，导致数据库性能下降</li>
</ul>
</li>
<li>MyBatis<ul>
<li>轻量级，性能出色  </li>
<li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  </li>
<li>开发效率稍逊于HIbernate，但是完全能够接受</li>
</ul>
</li>
</ul>
<h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>IDE：idea 2019.2  </li>
<li>构建工具：maven 3.5.4  </li>
<li>MySQL版本：MySQL 5.7  </li>
<li>MyBatis版本：MyBatis 3.5.7</li>
</ul>
<h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul>
<li><p>打包方式：jar</p>
</li>
<li><p>引入依赖</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- Mybatis核心 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><blockquote>
<p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>  <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span>  </span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>	<span class="hljs-comment">&lt;!--设置连接数据库的环境--&gt;</span>  <br>	<span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>		<span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>			<span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>  <br>			<span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>  <br>			<span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <br>		<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>  <br>	<span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>  <br>	<span class="hljs-comment">&lt;!--引入映射文件--&gt;</span>  <br>	<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>		<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  <br>	<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><blockquote>
<p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mybatis.mapper;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;  <br>	<span class="hljs-comment">/**  </span><br><span class="hljs-comment">	* 添加用户信息  </span><br><span class="hljs-comment">	*/</span>  <br>	<span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul>
<li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  <ul>
<li>对象：Java的实体类对象  </li>
<li>关系：关系型数据库  </li>
<li>映射：二者之间的对应关系</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Java概念</th>
<th>数据库概念</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>属性</td>
<td>字段&#x2F;列</td>
</tr>
<tr>
<td>对象</td>
<td>记录&#x2F;行</td>
</tr>
</tbody></table>
<ul>
<li>映射文件的命名规则<ul>
<li>表所对应的实体类的类名+Mapper.xml</li>
<li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li>
<li>因此一个映射文件对应一个实体类，对应一张表的操作</li>
<li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li>
<li>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</li>
</ul>
</li>
<li>MyBatis中可以面向接口操作数据，要保证两个一致<ul>
<li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li>
<li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>  <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span>  </span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  <br>	<span class="hljs-comment">&lt;!--int insertUser();--&gt;</span>  <br>	<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span>  <br>		insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  <br>	<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul>
<li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li>
<li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li>
<li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//读取MyBatis的核心配置文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-comment">//获取SqlSessionFactoryBuilder对象</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is);<br>        <span class="hljs-comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span><br>        <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span><br>	    <span class="hljs-comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span><br>		<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//通过代理模式创建UserMapper接口的代理实现类对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser();<br>        <span class="hljs-comment">//提交事务</span><br>        <span class="hljs-comment">//sqlSession.commit();</span><br>        System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交</li>
</ul>
<h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ol>
<li>加入依赖 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>加入log4j的配置文件<ul>
<li>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</li>
<li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">log4j</span>:configuration <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;log4j.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">log4j:configuration</span> <span class="hljs-attr">xmlns:log4j</span>=<span class="hljs-string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Encoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.ibatis&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">log4j:configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><blockquote>
<p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        typeAlias：设置某个具体的类型的别名</span><br><span class="hljs-comment">        属性：</span><br><span class="hljs-comment">        type：需要设置别名的类型的全类名</span><br><span class="hljs-comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span><br><span class="hljs-comment">        &lt;/typeAlias&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    environments：设置多个连接数据库的环境</span><br><span class="hljs-comment">    属性：</span><br><span class="hljs-comment">	    default：设置默认使用的环境的id</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql_test&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        environment：设置具体的连接数据库的环境信息</span><br><span class="hljs-comment">        属性：</span><br><span class="hljs-comment">	        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql_test&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            transactionManager：设置事务管理方式</span><br><span class="hljs-comment">            属性：</span><br><span class="hljs-comment">	            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span><br><span class="hljs-comment">	            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span><br><span class="hljs-comment">	            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            dataSource：设置数据源</span><br><span class="hljs-comment">            属性：</span><br><span class="hljs-comment">	            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span><br><span class="hljs-comment">	            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span><br><span class="hljs-comment">	            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span><br><span class="hljs-comment">	            type=&quot;JNDI&quot;：调用上下文中的数据源</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--设置驱动类的全类名--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的连接地址--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的用户名--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的密码--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入映射文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span><br><span class="hljs-comment">        注意：</span><br><span class="hljs-comment">			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span><br><span class="hljs-comment">			2. mapper接口要和mapper映射文件的名字一致</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><img src="https://s2.loli.net/2024/02/24/jFwPG2n6O3SWihH.png"></li>
</ul>
<h1 id="默认的类型别名"><a href="#默认的类型别名" class="headerlink" title="默认的类型别名"></a>默认的类型别名</h1><p><img src="https://s2.loli.net/2024/02/24/4EIPNYBWJTyCROm.png"><br><img src="https://s2.loli.net/2024/02/24/krKIZCce7WEHY16.png"></p>
<h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ol>
<li>添加 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertUser();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>	insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>删除 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int deleteUser();--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span><br>       delete from t_user where id = 6<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>修改 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int updateUser();--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>       update t_user set username = &#x27;张三&#x27; where id = 5<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>查询一个实体类对象 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">  <span class="hljs-comment">&lt;!--User getUserById();--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  <br>	select * from t_user where id = 2  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>查询集合 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>注意：</p>
<ol>
<li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul>
<li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li>
<li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li>
</ul>
</li>
<li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li>
</ol>
</li>
</ul>
<h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul>
<li>MyBatis获取参数值的两种方式：${}和#{}  </li>
<li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li>
<li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li>
</ul>
<h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul>
<li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUsername(String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username = #&#123;username&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUsername(String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>  <br>	select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul>
<li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p>
<ol>
<li>以arg0,arg1…为键，以参数为值；</li>
<li>以param1,param2…为键，以参数为值；</li>
</ol>
</li>
<li><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</p>
</li>
<li><p>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username,String password);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>  <br>	select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username,String password);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul>
<li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLoginByMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLoginByMap</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">ParameterMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(ParameterMapper.class);<br>	Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>	map.put(<span class="hljs-string">&quot;usermane&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>	map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>	<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.checkLoginByMap(map);<br>	System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul>
<li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertUser(User user);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>	insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">ParameterMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(ParameterMapper.class);<br>	<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>);<br>	mapper.insertUser(user);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul>
<li><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 </p>
<ol>
<li>以@Param注解的value属性值为键，以参数为值；</li>
<li>以param1,param2…为键，以参数为值；</li>
</ol>
</li>
<li><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;CheckLoginByParam&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLoginByParam</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">ParameterMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(ParameterMapper.class);<br>	mapper.CheckLoginByParam(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>建议分成两种情况进行处理</p>
<ol>
<li>实体类类型的参数</li>
<li>使用@Param标识参数</li>
</ol>
</li>
</ul>
<h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><ol>
<li>如果查询出的数据只有一条，可以通过<ol>
<li>实体类对象接收</li>
<li>List集合接收</li>
<li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li>
</ol>
</li>
<li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol>
<li>实体类类型的LIst集合接收</li>
<li>Map类型的LIst集合接收</li>
<li>在mapper接口的方法上添加@MapKey注解</li>
</ol>
</li>
</ol>
<h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据用户id查询用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="查询一个List集合"><a href="#查询一个List集合" class="headerlink" title="查询一个List集合"></a>查询一个List集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 查询用户的总记录数  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span><br><span class="hljs-comment"> * 例如：java.lang.Integer--&gt;int|integer  </span><br><span class="hljs-comment"> * 例如：int--&gt;_int|_integer  </span><br><span class="hljs-comment"> * 例如：Map--&gt;map,List--&gt;list  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int getCount();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;_integer&quot;</span>&gt;</span><br>	select count(id) from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 根据用户id查询用户信息为map集合  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment"> */</span>  <br>Map&lt;String, Object&gt; <span class="hljs-title function_">getUserToMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>	select * from t_user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="查询多条数据为map集合"><a href="#查询多条数据为map集合" class="headerlink" title="查询多条数据为map集合"></a>查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 查询所有用户信息为map集合  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span><br><span class="hljs-comment"> */</span>  <br>List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getAllUserToMap</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>  <br>	select * from t_user  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">	结果：</span><br><span class="hljs-comment">	[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span><br><span class="hljs-comment">	&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span><br><span class="hljs-comment">	&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户信息为map集合</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="hljs-doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br>Map&lt;String, Object&gt; <span class="hljs-title function_">getAllUserToMap</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">	结果：</span><br><span class="hljs-comment">	&#123;</span><br><span class="hljs-comment">	1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span><br><span class="hljs-comment">	2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span><br><span class="hljs-comment">	3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据用户名进行模糊查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/26 21:56</span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">getUserByLike</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  <br>	<span class="hljs-comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  <br>	select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的</li>
</ul>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><ul>
<li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id批量删除</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ids </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> int</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/26 22:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteMore</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> String ids)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMore&quot;</span>&gt;</span><br>	delete from t_user where id in ($&#123;ids&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteMore</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">SQLMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(SQLMapper.class);<br>	<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mapper.deleteMore(<span class="hljs-string">&quot;1,2,3,8&quot;</span>);<br>	System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><ul>
<li>只能使用${}，因为表名不能加单引号<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询指定表中的数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> tableName </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/27 14:41</span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">getUserByTable</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByTable&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from $&#123;tableName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul>
<li>使用场景<ul>
<li>t_clazz(clazz_id,clazz_name)  </li>
<li>t_student(student_id,student_name,clazz_id)</li>
</ul>
<ol>
<li>添加班级信息  </li>
<li>获取新添加的班级的id  </li>
<li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li>
</ol>
</li>
<li>在mapper.xml中设置两个属性<ul>
<li>useGeneratedKeys：设置使用自增的主键</li>
</ul>
<ul>
<li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> user </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/27 15:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--void insertUser(User user);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>	insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">SQLMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(SQLMapper.class);<br>	<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;ton&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;123@321.com&quot;</span>);<br>	mapper.insertUser(user);<br>	System.out.println(user);<br>	<span class="hljs-comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul>
<li><p>resultMap：设置自定义映射  </p>
<ul>
<li>属性：  <ul>
<li>id：表示自定义映射的唯一标识，不能重复</li>
<li>type：查询的数据要映射的实体类的类型</li>
</ul>
</li>
<li>子标签：  <ul>
<li>id：设置主键的映射关系  </li>
<li>result：设置普通字段的映射关系  </li>
<li>子标签属性：  <ul>
<li>property：设置映射关系中实体类中的属性名  </li>
<li>column：设置映射关系中表中的字段名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllEmp&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empResultMap&quot;</span>&gt;</span><br>	select * from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  </p>
<ol>
<li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致   <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllEmp&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select eid,emp_name empName,age,sex,email from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><blockquote>
<p>查询员工信息以及员工所对应的部门信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span> &#123;  <br>	<span class="hljs-keyword">private</span> Integer eid;  <br>	<span class="hljs-keyword">private</span> String empName;  <br>	<span class="hljs-keyword">private</span> Integer age;  <br>	<span class="hljs-keyword">private</span> String sex;  <br>	<span class="hljs-keyword">private</span> String email;  <br>	<span class="hljs-keyword">private</span> Dept dept;<br>	<span class="hljs-comment">//...构造器、get、set方法等</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptResultMapOne&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept.did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept.deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span><br>	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><ul>
<li>association：处理多对一的映射关系</li>
<li>property：需要处理多对的映射关系的属性名</li>
<li>javaType：该属性的类型<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span><br>	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4><ul>
<li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li>
<li>column：设置分步查询的条件<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//EmpMapper里的方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，员工及所对应的部门信息</span><br><span class="hljs-comment"> * 分步查询第一步：查询员工信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/27 20:17</span><br><span class="hljs-comment"> */</span><br>Emp <span class="hljs-title function_">getEmpAndDeptByStepOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span><br>	select * from t_emp where eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DeptMapper里的方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，员工及所对应的部门信息</span><br><span class="hljs-comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/27 20:23</span><br><span class="hljs-comment"> */</span><br>Dept <span class="hljs-title function_">getEmpAndDeptByStepTwo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;did&quot;)</span> Integer did)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span><br>	select * from t_dept where did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dept</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer did;<br>    <span class="hljs-keyword">private</span> String deptName;<br>    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;<br>	<span class="hljs-comment">//...构造器、get、set方法等</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul>
<li>collection：用来处理一对多的映射关系</li>
<li>ofType：表示该属性对饮的集合中存储的数据的类型<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DeptAndEmpResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptAndEmp&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span><br>	select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，查询部门及对应的所有员工信息</span><br><span class="hljs-comment"> * 分步查询第一步：查询部门信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> did </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/27 22:04</span><br><span class="hljs-comment"> */</span><br>Dept <span class="hljs-title function_">getDeptAndEmpByStepOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;did&quot;)</span> Integer did)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;emps&quot;</span></span><br><span class="hljs-tag">				<span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span><br><span class="hljs-tag">				<span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span><br>	select * from t_dept where did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，查询部门及对应的所有员工信息</span><br><span class="hljs-comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> did</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/2/27 22:10</span><br><span class="hljs-comment"> */</span><br>List&lt;Emp&gt; <span class="hljs-title function_">getDeptAndEmpByStepTwo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;did&quot;)</span> Integer did)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp where did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul>
<li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：<ul>
<li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  </li>
<li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li>
</ul>
</li>
<li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getEmpAndDeptByStepOne</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>	<span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="hljs-number">1</span>);<br>	System.out.println(emp.getEmpName());<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>关闭延迟加载，两条SQL语句都运行了<img src="https://s2.loli.net/2024/02/24/bXNEQHosYZeStF5.png"></p>
</li>
<li><p>开启延迟加载，只运行获取emp的SQL语句<br><img src="https://s2.loli.net/2024/02/24/HC2VsbpGN8tQ9Zq.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getEmpAndDeptByStepOne</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>	<span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="hljs-number">1</span>);<br>	System.out.println(emp.getEmpName());<br>	System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);<br>	System.out.println(emp.getDept());<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>开启后，需要用到查询dept的时候才会调用相应的SQL语句<img src="https://s2.loli.net/2024/02/24/ZqfKouEIhOXmRCQ.png"></p>
</li>
<li><p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul>
<li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul>
<li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li>
<li>在where后面添加一个恒成立条件<code>1=1</code><ul>
<li>这个恒成立条件并不会影响查询的结果</li>
<li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时<ul>
<li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错</li>
<li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp where 1=1<br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and emp_name = #&#123;empName&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and age = #&#123;age&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and sex = #&#123;sex&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and email = #&#123;email&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul>
<li><p>where和if一般结合使用：</p>
<ul>
<li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  </li>
<li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp<br>	<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>			emp_name = #&#123;empName&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>			and age = #&#123;age&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span><br>			and sex = #&#123;sex&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span><br>			and email = #&#123;email&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意：where标签不能去掉条件后多余的and&#x2F;or</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>emp_name = #&#123;empName&#125; and<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>	age = #&#123;age&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul>
<li>trim用于去掉或添加标签中的内容  </li>
<li>常用属性<ul>
<li>prefix：在trim标签中的内容的前面添加某些内容  </li>
<li>suffix：在trim标签中的内容的后面添加某些内容 </li>
<li>prefixOverrides：在trim标签中的内容的前面去掉某些内容  </li>
<li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li>
</ul>
</li>
<li>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp<br>	<span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>			emp_name = #&#123;empName&#125; and<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>			age = #&#123;age&#125; and<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span><br>			sex = #&#123;sex&#125; or<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span><br>			email = #&#123;email&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getEmpByCondition</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">DynamicSQLMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);<br>	List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>));<br>	System.out.println(emps);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/02/24/OHuXK1aBpgAP3Jl.png"></li>
</ul>
<h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul>
<li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li>
<li>when至少要有一个，otherwise至多只有一个<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp<br>	<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span><br>				emp_name = #&#123;empName&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span><br>				age = #&#123;age&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span><br>				sex = #&#123;sex&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span><br>				email = #&#123;email&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>				did = 1<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getEmpByChoose</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">DynamicSQLMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);<br>	List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;123@qq.com&quot;</span>, <span class="hljs-literal">null</span>));<br>	System.out.println(emps);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/02/24/8zFmHCf5GbMk672.png"></li>
<li>相当于<code>if a else if b else if c else d</code>，只会执行其中一个</li>
</ul>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul>
<li><p>属性：  </p>
<ul>
<li>collection：设置要循环的数组或集合  </li>
<li>item：表示集合或数组中的每一个数据  </li>
<li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li>
<li>open：设置foreach标签中的内容的开始符  </li>
<li>close：设置foreach标签中的内容的结束符</li>
</ul>
</li>
<li><p>批量删除</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>	delete from t_emp where eid in<br>	<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>		#&#123;eid&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteMoreByArray</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">DynamicSQLMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);<br>	<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mapper.deleteMoreByArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;);<br>	System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  <img src="/Resources/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png"></p>
</li>
<li><p>批量添加</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMoreByList&quot;</span>&gt;</span><br>	insert into t_emp values<br>	<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>		(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertMoreByList</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>	<span class="hljs-type">DynamicSQLMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);<br>	<span class="hljs-type">Emp</span> <span class="hljs-variable">emp1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>,<span class="hljs-literal">null</span>);<br>	<span class="hljs-type">Emp</span> <span class="hljs-variable">emp2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>,<span class="hljs-literal">null</span>);<br>	<span class="hljs-type">Emp</span> <span class="hljs-variable">emp3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>,<span class="hljs-literal">null</span>);<br>	List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);<br>	<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mapper.insertMoreByList(emps);<br>	System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  <img src="/Resources/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></p>
</li>
</ul>
<h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul>
<li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li>
<li>声明sql片段：<code>&lt;sql&gt;</code>标签<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>引用sql片段：<code>&lt;include&gt;</code>标签<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span> from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul>
<li><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </p>
</li>
<li><p>使一级缓存失效的四种情况：  </p>
<ol>
<li>不同的SqlSession对应不同的一级缓存  </li>
<li>同一个SqlSession但是查询条件不同</li>
<li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li>
<li>同一个SqlSession两次查询期间手动清空了缓存</li>
</ol>
</li>
</ul>
<h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul>
<li><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </p>
</li>
<li><p>二级缓存开启的条件</p>
<ol>
<li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置</li>
<li>在映射文件中设置标签<cache /></li>
<li>二级缓存必须在SqlSession关闭或提交之后有效</li>
<li>查询的数据所转换的实体类类型必须实现序列化的接口</li>
</ol>
</li>
<li><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p>
</li>
</ul>
<h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul>
<li>在mapper配置文件中添加的cache标签可以设置一些属性</li>
<li>eviction属性：缓存回收策略  <ul>
<li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  </li>
<li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  </li>
<li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  </li>
<li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
<li>默认的是 LRU</li>
</ul>
</li>
<li>flushInterval属性：刷新间隔，单位毫秒<ul>
<li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li>
</ul>
</li>
<li>size属性：引用数目，正整数<ul>
<li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li>
</ul>
</li>
<li>readOnly属性：只读，true&#x2F;false<ul>
<li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  </li>
<li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</li>
</ul>
</li>
</ul>
<h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li>
<li>如果二级缓存没有命中，再查询一级缓存  </li>
<li>如果一级缓存也没有命中，则查询数据库  </li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h2 id="整合第三方缓存EHCache（了解）"><a href="#整合第三方缓存EHCache（了解）" class="headerlink" title="整合第三方缓存EHCache（了解）"></a>整合第三方缓存EHCache（了解）</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="各个jar包的功能"><a href="#各个jar包的功能" class="headerlink" title="各个jar包的功能"></a>各个jar包的功能</h3><table>
<thead>
<tr>
<th>jar包名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mybatis-ehcache</td>
<td>Mybatis和EHCache的整合包</td>
</tr>
<tr>
<td>ehcache</td>
<td>EHCache核心包</td>
</tr>
<tr>
<td>slf4j-api</td>
<td>SLF4J日志门面包</td>
</tr>
<tr>
<td>logback-classic</td>
<td>支持SLF4J门面接口的一个具体实现</td>
</tr>
</tbody></table>
<h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><ul>
<li>名字必须叫<code>ehcache.xml</code><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 磁盘保存路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><br><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">&quot;10000000&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">defaultCache</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><ul>
<li>在xxxMapper.xml文件中设置二级缓存类型<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul>
<li>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件<code>logback.xml</code>，名字固定，不可改变<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定日志输出的位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志输出的格式 --&gt;</span><br>            <span class="hljs-comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table>
<thead>
<tr>
<th>属性名</th>
<th>是否必须</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>maxElementsInMemory</td>
<td>是</td>
<td>在内存中缓存的element的最大数目</td>
</tr>
<tr>
<td>maxElementsOnDisk</td>
<td>是</td>
<td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td>
</tr>
<tr>
<td>eternal</td>
<td>是</td>
<td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td>
</tr>
<tr>
<td>overflowToDisk</td>
<td>是</td>
<td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td>
</tr>
<tr>
<td>timeToIdleSeconds</td>
<td>否</td>
<td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td>
</tr>
<tr>
<td>timeToLiveSeconds</td>
<td>否</td>
<td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td>
</tr>
<tr>
<td>diskSpoolBufferSizeMB</td>
<td>否</td>
<td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td>
</tr>
<tr>
<td>diskPersistent</td>
<td>否</td>
<td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td>
</tr>
<tr>
<td>diskExpiryThreadIntervalSeconds</td>
<td>否</td>
<td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td>
</tr>
<tr>
<td>memoryStoreEvictionPolicy</td>
<td>否</td>
<td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出</td>
</tr>
</tbody></table>
<h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul>
<li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li>
<li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  <ul>
<li>Java实体类  </li>
<li>Mapper接口  </li>
<li>Mapper映射文件</li>
</ul>
</li>
</ul>
<h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- MyBatis核心依赖包 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- log4j日志 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- 构建过程中用到的插件 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>			<span class="hljs-comment">&lt;!-- 插件的依赖 --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>				<span class="hljs-comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>				<span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>				<span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul>
<li>文件名必须是：<code>generatorConfig.xml</code><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    targetRuntime: 执行生成的逆向工程的版本</span><br><span class="hljs-comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="hljs-comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库的连接信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mapper接口的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 逆向分析的表 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>        <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><ul>
<li><img src="https://s2.loli.net/2024/02/24/KAC5JObmRfEYngt.png"></li>
<li>如果出现报错：<code>Exception getting JDBC Driver</code>，可能是pom.xml中，数据库驱动配置错误<ul>
<li>dependency中的驱动<img src="https://s2.loli.net/2024/02/24/pkb3C6GxIHzXmcP.png"></li>
<li>mybatis-generator-maven-plugin插件中的驱动<img src="https://s2.loli.net/2024/02/24/qJN9sYh5Bvj3EOb.png"></li>
<li>两者的驱动版本应该相同</li>
</ul>
</li>
<li>执行结果<img src="https://s2.loli.net/2024/02/24/6O5TNxe72gzW1BR.png"></li>
</ul>
<h2 id="QBC"><a href="#QBC" class="headerlink" title="QBC"></a>QBC</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li>
<li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li>
<li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件<br><img src="https://s2.loli.net/2024/02/24/8DHEzjYqwmrUvbx.png"><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMBG</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>	<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>	<span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>	<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is);<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>	<span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>	<span class="hljs-type">EmpExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpExample</span>();<br>	<span class="hljs-comment">//名字为张三，且年龄大于等于20</span><br>	example.createCriteria().andEmpNameEqualTo(<span class="hljs-string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="hljs-number">20</span>);<br>	<span class="hljs-comment">//或者did不为空</span><br>	example.or().andDidIsNotNull();<br>	List&lt;Emp&gt; emps = mapper.selectByExample(example);<br>	emps.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/02/24/WjbCf1KMaGNt8Hw.png"></li>
</ul>
<h3 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h3><ul>
<li><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null<ul>
<li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li>
<li><img src="https://s2.loli.net/2024/02/24/mIgAv1yUiZ8SeLR.png"></li>
</ul>
</li>
<li><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段<ul>
<li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li>
<li><img src="https://s2.loli.net/2024/02/24/l8ravpAtSxCFZIu.png"></li>
</ul>
</li>
</ul>
<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件使用步骤"><a href="#分页插件使用步骤" class="headerlink" title="分页插件使用步骤"></a>分页插件使用步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul>
<li>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</li>
<li><img src="https://s2.loli.net/2024/02/24/EJwiWPOX1oNC2u4.png"><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--设置分页插件--&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><h3 id="开启分页功能"><a href="#开启分页功能" class="headerlink" title="开启分页功能"></a>开启分页功能</h3><ul>
<li>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能<ul>
<li>pageNum：当前页的页码  </li>
<li>pageSize：每页显示的条数<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageHelper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>	<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>	<span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>	<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is);<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>	<span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>	<span class="hljs-comment">//访问第一页，每页四条数据</span><br>	PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);<br>	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="hljs-literal">null</span>);<br>	emps.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/zSMtsh9nQwTopEN.png"></p>
<h3 id="分页相关数据"><a href="#分页相关数据" class="headerlink" title="分页相关数据"></a>分页相关数据</h3><h4 id="方法一：直接输出"><a href="#方法一：直接输出" class="headerlink" title="方法一：直接输出"></a>方法一：直接输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageHelper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>	<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>	<span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>	<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is);<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>	<span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>	<span class="hljs-comment">//访问第一页，每页四条数据</span><br>	Page&lt;Object&gt; page = PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="hljs-literal">null</span>);<br>	<span class="hljs-comment">//在查询到List集合后，打印分页数据</span><br>	System.out.println(page);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>分页相关数据：</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">Page&#123;<span class="hljs-attribute">count</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">pageNum</span>=1, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">startRow</span>=0, <span class="hljs-attribute">endRow</span>=4, <span class="hljs-attribute">total</span>=8, <span class="hljs-attribute">pages</span>=2, <span class="hljs-attribute">reasonable</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">pageSizeZero</span>=<span class="hljs-literal">false</span>&#125;[Emp&#123;<span class="hljs-attribute">eid</span>=1, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;456@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=3&#125;, Emp&#123;<span class="hljs-attribute">eid</span>=2, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;admin2&#x27;</span>, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;456@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=3&#125;, Emp&#123;<span class="hljs-attribute">eid</span>=3, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-attribute">age</span>=12, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;123@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=3&#125;, Emp&#123;<span class="hljs-attribute">eid</span>=4, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-attribute">age</span>=32, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;123@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=1&#125;]<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法二使用PageInfo"><a href="#方法二使用PageInfo" class="headerlink" title="方法二使用PageInfo"></a>方法二使用PageInfo</h4><ul>
<li><p>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据</p>
<ul>
<li>list：分页之后的数据  </li>
<li>navigatePages：导航分页的页码数<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageHelper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>	<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>	<span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>	<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is);<br>	<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>	<span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>	PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="hljs-literal">null</span>);<br>	PageInfo&lt;Emp&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(emps,<span class="hljs-number">5</span>);<br>	System.out.println(page);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分页相关数据：</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">PageInfo&#123;<br><span class="hljs-attribute">pageNum</span>=1, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">size</span>=4, <span class="hljs-attribute">startRow</span>=1, <span class="hljs-attribute">endRow</span>=4, <span class="hljs-attribute">total</span>=8, <span class="hljs-attribute">pages</span>=2, <br><span class="hljs-attribute">list</span>=Page&#123;<span class="hljs-attribute">count</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">pageNum</span>=1, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">startRow</span>=0, <span class="hljs-attribute">endRow</span>=4, <span class="hljs-attribute">total</span>=8, <span class="hljs-attribute">pages</span>=2, <span class="hljs-attribute">reasonable</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">pageSizeZero</span>=<span class="hljs-literal">false</span>&#125;[Emp&#123;<span class="hljs-attribute">eid</span>=1, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;456@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=3&#125;, Emp&#123;<span class="hljs-attribute">eid</span>=2, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;admin2&#x27;</span>, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;456@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=3&#125;, Emp&#123;<span class="hljs-attribute">eid</span>=3, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-attribute">age</span>=12, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;123@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=3&#125;, Emp&#123;<span class="hljs-attribute">eid</span>=4, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-attribute">age</span>=32, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;123@qq.com&#x27;</span>, <span class="hljs-attribute">did</span>=1&#125;], <br><span class="hljs-attribute">prePage</span>=0, <span class="hljs-attribute">nextPage</span>=2, <span class="hljs-attribute">isFirstPage</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">isLastPage</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">hasPreviousPage</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">hasNextPage</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">navigatePages</span>=5, <span class="hljs-attribute">navigateFirstPage</span>=1, <span class="hljs-attribute">navigateLastPage</span>=2, navigatepageNums=[1, 2]&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>其中list中的数据等同于方法一中直接输出的page数据</p>
</li>
</ul>
<h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4><ul>
<li>pageNum：当前页的页码  </li>
<li>pageSize：每页显示的条数  </li>
<li>size：当前页显示的真实条数  </li>
<li>total：总记录数  </li>
<li>pages：总页数  </li>
<li>prePage：上一页的页码  </li>
<li>nextPage：下一页的页码</li>
<li>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页  </li>
<li>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页  </li>
<li>navigatePages：导航分页的页码数  </li>
<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>javaSE</title>
    <url>/2022/02/18/Java/javaSE/</url>
    <content><![CDATA[<h1 id="语法基础复习"><a href="#语法基础复习" class="headerlink" title="语法基础复习"></a>语法基础复习</h1><h3 id="1-1编程语言"><a href="#1-1编程语言" class="headerlink" title="1.1编程语言"></a>1.1编程语言</h3><p>机器语言：一堆二进制数字 </p>
<p>汇编语言：增加了一些关键字，编程过程必须要考虑计算机运行原理</p>
<p>高级编程语言：全部都是英文单词和数字组成，编程过程是不需要考虑计算机底层细节</p>
<p>​	高级编程语言写出的代码不能由计算机直接执行的，必须得进行编译（源代码-》机器码）</p>
<p>静态编译型语言：</p>
<p>​	Java C，C++</p>
<p>​	编译型：在运行前预先编译，生成一份二进制可执行程序</p>
<p>​	静态：在创建变量的适合必须进行数据类型的声明（有严格要求）</p>
<p>动态解释型语言：</p>
<p>​	Python JavaScript PHP Puby Shell</p>
<p>​	解释型：读取一行源码，进行编译（编译所生成的二进制文件可能在内存 可能在硬盘临时存储）</p>
<p>​	动态：不需要声明（没有严格声明）</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">对于一个变量而言，所存储的内存是：<br>	要命存储的是值 或者 数据在堆内存的地址<br>	<br>在动态解释型语言中，任何数据都是对象！所以变量存储的是对象在堆内存中的地址<br>在静态解释型语言中：对于基本数据类型 变量是直接存储值；对于引用数据类型 变量存储是对象在堆内存中的地址<br></code></pre></td></tr></table></figure>



<h3 id="Jre-与Jdk"><a href="#Jre-与Jdk" class="headerlink" title="Jre 与Jdk"></a>Jre 与Jdk</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jre： </span><span class="hljs-keyword">Java </span>runtime Environment <span class="hljs-keyword">Java运行环境</span><br><span class="hljs-keyword"></span>	只运行<span class="hljs-keyword">Java程序，安装jre程序即可 </span><span class="hljs-keyword">jre.exe</span><br><span class="hljs-keyword"></span>	<span class="hljs-keyword">Jre </span>= <span class="hljs-keyword">Jvm </span>+ 核心类库（已经写好的<span class="hljs-keyword">java代码和字节码）</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Jdk:</span> <span class="hljs-keyword">Java </span>Development Kit <span class="hljs-keyword">Java </span>开发工具包<br>	开发<span class="hljs-keyword">Java程序，需要安装Jak程序 </span><span class="hljs-keyword">jak.exe</span><br><span class="hljs-keyword"></span>	<span class="hljs-keyword">jdk </span>= <span class="hljs-keyword">jre </span>+ 开发工具（编译工具 运行工具 打包工具 <span class="hljs-keyword">bin目录下）</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">Jvm： </span><span class="hljs-keyword">Java </span>Vertical Machine <span class="hljs-keyword">Java虚拟机</span><br><span class="hljs-keyword"></span>	<span class="hljs-keyword">Java源代码进行编译后 </span>生成一个字节码文件(.class文件)，但是这个字节码文件不能直接运行在操作系统(win Liunx Mac)上(因为这些操作系统都说是Unix的衍生品，Unix是由c语言编写，所以这些os本身就直接对c系列代码的运行，class字节码文件是不能直接运行在Os上，没系统底层支持)，<br>	<span class="hljs-keyword">JVM充当翻译的角色，将class字结码的内存转化成具体OS平台的指令，然后将这些指令交由计算机底层执行，可以理解为class文件是运行在JVM中，JVM运行在具体的os平台上</span><br><span class="hljs-keyword"></span>	不同的平台，有不同的<span class="hljs-keyword">JVM。 </span>-- 跨平台特性<br></code></pre></td></tr></table></figure>

<p>jdk 目录解析</p>
<p>bin 目录 ：主要存放的是Java开发工具</p>
<p>db工具：database主要存放的操作数据库的工具</p>
<p>include目录：主要存放的是JVM相关的c语言代码的头文件</p>
<p>jre目录：jdk自带的jre环境</p>
<p>lib目录：library库文件包 一本存放的是第三放代码工具 后期对java内容的扩充</p>
<p>src压缩包：java源代码</p>
<h3 id="path与classpath"><a href="#path与classpath" class="headerlink" title="path与classpath"></a>path与classpath</h3><h4 id="path环境变量"><a href="#path环境变量" class="headerlink" title="path环境变量"></a>path环境变量</h4><p>为什么要配置path环境变量？</p>
<ol>
<li><p>从手动编译和运行Java程序的角度而言</p>
<p>开发工具本身在jdk目录中的bin目录里，但这个开发工具虽然是可执行程序但大部分是没有图形化界面的，只能在命令行中运行，在没有配置环境变量的时候，需要先手动切换到开发工具所在的路径下（D:\Java\jdk1.8.0_51\bin) ,<br>但javac和java工具后面要根源文件和字节码文件，而这两个文件不一定存放在bin目录下，所以在文件路径路径是需要给出全路径(D:\Java\jdk1.8.0_51\bin&gt;C:\Users\desktop\demo.java),</p>
<p>这中操作方式比较麻烦，以开发工具为主，还是以文件为主</p>
<p>配置path环境变量的目的就是在控制台中，任何位置都可以找到开发工具</p>
</li>
<li><p>从高级开发工具角度</p>
<p>主要用于识别和区分jdk或jre的环境</p>
<p>对于一个计算机而言，可以安装jdk7也可以安装jdk8，任何版本都可以同时存，但在具体进行编译运行的时候，得确定一个版本，对于高级开发工具而言，从path中确定</p>
</li>
</ol>
<h3 id="classpath环境变量"><a href="#classpath环境变量" class="headerlink" title="classpath环境变量"></a>classpath环境变量</h3><p>如果不进行配置的话，进行编译的时候，所生成的字节码文件在同目录下存储，源码与字节码混合不便于管理，高级开发工具则会分开管理。</p>
<p>分离之后在运行字节码文件，如何寻找？</p>
<ul>
<li>如果不配置classpath：直接在当前目录下寻找</li>
<li>控制台临时配置 set classpath &#x3D; “C:\Users\desktop”</li>
</ul>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>​	1.直接出现在代码中的数据，字面量</p>
<p>​	2.通过创建变量的形式，对变量进行修改的约束，使之变成常量</p>
<p>整数 浮点数 布尔类型 字符 字符串</p>
<p>final 修饰</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量是在内存中开辟的一个临时存储空，用于存储数据（值，址），java中是不通过变量的指针操作变量（java中本身有指针，但是不用，被屏蔽了）java无指针，至于临时存储空间中存什么，取决于数据类型，这个空间多大也取决于数据类型</p>
<h4 id="变量交换问题"><a href="#变量交换问题" class="headerlink" title="变量交换问题"></a>变量交换问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.通用（数据型和引用型 通用)</span><br><span class="hljs-comment">//中间变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>    a = b ;<br>    b = temp<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2. 仅限于数组型 推荐整数 小数存精度问题</span><br><span class="hljs-comment">//加减法</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>    a = a + b;<br>    b = a - b;<br>    a = a - b;	<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 仅限于整数 </span><br><span class="hljs-comment">// 异或  形同则假 不同则真</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>        a = a ^ b;<br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment">        *   0001</span><br><span class="hljs-comment">        *   0010 ^</span><br><span class="hljs-comment">        *   0011 = 3</span><br><span class="hljs-comment">        */</span><br>        b = a ^ b;<br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment">            0011</span><br><span class="hljs-comment">            0010 ^</span><br><span class="hljs-comment">            0001 = 1</span><br><span class="hljs-comment">        */</span><br>        a = a ^ b;<br>        <span class="hljs-comment">/*     </span><br><span class="hljs-comment">            0011</span><br><span class="hljs-comment">            0001 ^</span><br><span class="hljs-comment">            0010 = 2</span><br><span class="hljs-comment">        */</span><br>	<br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure>



<h3 id="数据类型与类型转化"><a href="#数据类型与类型转化" class="headerlink" title="数据类型与类型转化"></a>数据类型与类型转化</h3><p>数据类型</p>
<p>数据类型确定了变量：</p>
<ul>
<li>变量存什么</li>
<li>空间多大</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/23/YVyW8u9eAcvLDKf.png" alt="image-20220831084304425"></p>
<p>基本数据类型(确定了变量中应该存储的数值，并且也确定了变量的大小)</p>
<p>字节是计算中最小计数单位（8比特 &#x3D; 1字节 8bit &#x3D; 1byte）</p>
<ul>
<li><p>整数</p>
<ul>
<li>byte	1字节   -2^7 ~ 2^7-1</li>
<li>short   2字节 -2^15 ~ 2^15 -1</li>
<li>int   4字节</li>
<li>long  8字节</li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li>float	4字节</li>
<li>double   8字节</li>
</ul>
<p>float型:常量后面必须加后缀f或F，例如22.76f。占4字节，取值范围</p>
<p>大约是10-38<del>1038和-1038</del>10-38</p>
<p>double型，常量后面加后缀d或D，但可以省略。占8字节，取值范围</p>
<p>大约是10-308<del>10308和-10308</del>10308</p>
</li>
<li><p>布尔类型 boolean 看JVM（当作但不变量4字节，当作布尔类型数组的一个元素1字节）</p>
</li>
<li><p>字符类型 char 2字节 16为不取负数 0-65535 表示码表中的编</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">字符常量:即用单引号扩起的Unicode表中的一一个字符。<br>转意字符常量:有些字符(如回车符)不能通过键盘输入到字符串或程序中，就需要使用转意字符常量。例如:<br>字符变量:使用关键字<span class="hljs-type">char</span>来声明<span class="hljs-type">char</span>型变量。对于<span class="hljs-type">char</span>型变量，内存分配给<span class="hljs-number">2</span>个字节，占<span class="hljs-number">16</span>位<br></code></pre></td></tr></table></figure></li>
</ul>
<p>引用数据类型(确定了变量中存储的是数据在堆内存中的地址)</p>
<h4 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h4><p>Java中数据的基本类型的(不包括逻辑类型)按精度从“低”到“高”排列:</p>
<p>Byte: 1字节	Short: 2字节	Char: 2字节	Int: 4字节	</p>
<p>Long: 8字节 	Float: 4字节	Double: 8字节</p>
<ol>
<li><p>自动类型转换也称加宽转换，它是指将具有较少位数(低精度)的数据类型转换为具有较多位数(高精度)的数据类型，</p>
<p><img src="https://s2.loli.net/2024/02/23/oHej3QhgmdJDE6Z.png" alt="image-20220831085700055"></p>
</li>
<li><p>强制类型转换:将位数较多的数据类型转换为位数较少的数据类型。其语法是用圆括号运算符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">200.5</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)d;<br></code></pre></td></tr></table></figure>
</li>
<li><p>表达式类型提示</p>
<ul>
<li><p>除了赋值可能发生类型转换外，在含有变量的表达式中也有类型转换的问题</p>
</li>
<li><p>表达式求值时，Java自动的隐含的将每个byte、short或char操作数提升为int类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">btye</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>, b = <span class="hljs-number">50</span>;<br><span class="hljs-comment">//byte c = a+b;	错误</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span>  <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>) a+b;	<span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a+b;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不兼容的类型: 从int转换到byte可能会有损失</span><br>    <span class="hljs-comment">//128常量默认int类型 4字节</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    00000000 00000000 00000011 10100101  int</span><br><span class="hljs-comment">    						   00000000  byte</span><br><span class="hljs-comment">    						   两位丢失</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; error<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    00000000 00000000 00000000 00000100</span><br><span class="hljs-comment">    						   00000000</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; Ok<br>        <br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> + <span class="hljs-number">4</span>;<span class="hljs-comment">//常量7没有超范围 直接跟常量</span><br>		<span class="hljs-comment">//不兼容的类型: 从int转换到byte可能会有损失</span><br>	<span class="hljs-type">byte</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>) (b1 + b2); <span class="hljs-comment">//error </span><br>		<span class="hljs-comment">//对于b4而言b1和b2的值是不确定 有可能超 也有可能没超</span><br><br><span class="hljs-number">2.</span><br>	<br>	System.out.println(<span class="hljs-string">&quot;b4 = &quot;</span> + b4);<br>	<span class="hljs-comment">//将b1+b2的值进行强制转换</span><br>	<span class="hljs-comment">//byte short int之间进行计算 结果一律为int</span><br>	<span class="hljs-type">byte</span> <span class="hljs-variable">b5</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>	<span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>		<span class="hljs-comment">//不兼容的类型: 从int转换到short可能会有损失</span><br>	<span class="hljs-type">short</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> b5 + s1; <span class="hljs-comment">//error</span><br>	<br><span class="hljs-number">3.</span><br><br>	<span class="hljs-type">short</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    s3 += <span class="hljs-number">1</span>; <span class="hljs-comment">//后面跟着的是常量 确定没超范围</span><br>        <br>		<span class="hljs-comment">//不兼容的类型: 从int转换到short可能会有损失</span><br>    s3 = s3 + <span class="hljs-number">1</span>; <span class="hljs-comment">// error s3变量不确定是否超范围</span><br><br><span class="hljs-number">4.</span><br><br>	<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;	<span class="hljs-comment">//int类型最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> i1 + i2; <span class="hljs-comment">//左右两边都是int型</span><br>        <span class="hljs-comment">//就算超过了int的范围 也会进行强制的阉割</span><br>    System.out.println(i3);<span class="hljs-comment">//整数溢出</span><br>输出--》》 -<span class="hljs-number">2147483648</span><br>    当超出范围时，会将 超位阉割， 阉割后最高位变化 ，最高位代表 z<br><br>System.out.println(i1);<br>System.out.println((Integer.toBinaryString(i1)));<br>System.out.println(i2);<br>System.out.println(Integer.toBinaryString(i2));<br>System.out.println(i3);<br>System.out.println(Integer.toBinaryString(i3));<span class="hljs-comment">//整数溢出</span><br><br>输出<br><span class="hljs-number">2147483647</span><br><span class="hljs-number">1111111111111111111111111111111</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>-<span class="hljs-number">2147483648</span><br><span class="hljs-number">10000000000000000000000000000000</span><br></code></pre></td></tr></table></figure>



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>​	+- * &#x2F; % ++ –  </p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">自增++自减<span class="hljs-comment">--运算符</span><br>	<span class="hljs-built_in">num</span>++ 先使用<span class="hljs-built_in">num</span>的值，后加<span class="hljs-number">1</span><br>	++<span class="hljs-built_in">num</span> 先加<span class="hljs-number">1</span>，后使用<span class="hljs-built_in">num</span>的值<br>等效于 <span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span> + <span class="hljs-number">1</span>，让变量自身加<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>对于后缀++，在内存中的操作步骤：</p>
<ol>
<li>开辟一个临时存储区</li>
<li>将变量i的值赋值进临时存储区</li>
<li>将变量i自身加1</li>
<li>临时存储区的值等待被调用（输出、赋值、运算）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">   <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>   i = i++;<br>   System.out.println(i);  <span class="hljs-comment">// 1</span><br>   i = i++;<br>   System.out.println(i); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//临时存储区的值等待被调用</span><br></code></pre></td></tr></table></figure>

<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>  +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D;  %&#x3D;  </p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p> &gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D;<br>&#x3D;&#x3D; 计算结果肯定为布尔类型 </p>
<p>对于 &#x3D;&#x3D; 的强调：永远比的是两个变量中存储的数据<br>（对于基本数据类型而言-数值，对于引用数据类型而言-地址）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;   <span class="hljs-comment">//字符串常量池 不存在则创建 存着则复用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(num1 == num2); <span class="hljs-comment">//数值 true</span><br>System.out.println(s1 == s2); <span class="hljs-comment">//地址 true</span><br><span class="hljs-string">&#x27;为什么为ture&#x27;</span><br>System.out.println(o1 == o2); <span class="hljs-comment">//地址 false</span><br><br>String <span class="hljs-string">&#x27;字符串常量池&#x27;</span> 字符串创建时 不存在则创建 存在时复用 地址相同<br></code></pre></td></tr></table></figure>

<p>引用数据类型之间能否用&gt; &gt;&#x3D; &lt; &lt;&#x3D;？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">//二元运算符 <span class="hljs-string">&#x27;&gt;&#x27;</span> 的操作数类型错误<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(o1 &gt; o2);<br></code></pre></td></tr></table></figure>

<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp; | ! ^ &amp;&amp; ||</p>
<p>与：遇假则假，全真则真<br>或：遇真则真，全假则假<br>非：取反<br>异或：相同则假，不同则真<br>&amp; 和 &amp;&amp;：&amp;的左右都执行，&amp;&amp;左边一旦为假右边就不执行了</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp; 和 &amp;&amp;区别： </span><br>        <span class="hljs-meta">&amp; ：无论左边结果是什么，右边都参与运算。</span><br>        <span class="hljs-meta">&amp;&amp;:短路与，如果左边为false，那么右边不参数与运算。</span><br></code></pre></td></tr></table></figure>

<p>| 和 || ：|的左右都执行， ||或的左边一旦为真右边不执行了</p>
<p>目的：减少一些计算量</p>
<h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><blockquote>
<p>&amp; | ! ^ &gt;&gt; &lt;&lt;</p>
</blockquote>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>数据类型 变量 &#x3D; 布尔表达式 ? 值1:值2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span> == <span class="hljs-literal">true</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br> ==&gt; <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><p>if-else语句 if（）中必须为true类型的值</p>
<p>switch语句：可以进行选择的数据 byte short int char String 枚举类型<br>两者的区别：</p>
<ul>
<li>对于switch，它只能对固定的几个值进行判断，不能对区间值进行判断</li>
<li>对于if-else，它不仅能对固定的值进行判断，也能对区间值进行判断</li>
</ul>
<p>特殊对switch而言，从入口进入到合适的case向下走直到碰见break则跳出，或者直接跑到default语句退出</p>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>for循环<br>while循环<br>do-while循环</p>
<p>再讨论循环问题是，必须要认清这四个要素：</p>
<ul>
<li>循环的初始化：循环从哪里开始</li>
<li>循环的继续条件：循环是否继续，循环到哪里结束</li>
<li>循环体：需要循环执行的代码片段</li>
<li>循环的步长、周期：当前轮次的循环与下一轮次循环之间的关系 要素控制循环的进度</li>
</ul>
<h3 id="函数内存运行原理"><a href="#函数内存运行原理" class="headerlink" title="函数内存运行原理"></a>函数内存运行原理</h3><p>函数内存运行原理</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">权限修饰符 函数类型 返回值类型 函数名(参数列表) &#123;<br>函数体<span class="hljs-comment">;</span><br>return 返回值<span class="hljs-comment">;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>权限修饰符：public private protect 默认不写 </li>
<li>函数类型：static abstract native 默认不写</li>
<li>返回值类型：取决于返回值的类型，如果没有返回值写void</li>
<li>参数列表：可有可无，形式参数（是作为函数的局部变量）</li>
<li>函数体：被封装的独立功能代码片段</li>
<li>return：return仅仅表示函数结束 如果没有返回值的话 return可以默认不写但是是在函数最后一行存在的隐藏的。</li>
<li>返回值：必须跟在return之后，如果没有则不写</li>
</ul>
<p>函数是基于栈运行的！</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>含义：在同一个类里面，可以允许出现同名函数的</p>
<p>目的：就是为了拓展函数的功能和使用的场景</p>
<p>函数中形式参数的数据类型可以向下兼容的（只要实际参数的类型可以向上转成形式参数的类型，就可以匹配）</p>
<p>在调用函数的时候，实际参数优先匹配最接近的形式参数类型的<br>函数的返回值类型确实是由返回值来决定的，根形式参数的数据类型关系不大。但是，归根结底，函数返回值的类型是由函数内部的逻辑决定的！</p>
<p>重载的前提就是在同一个类中有 ‘同名同类型函数’ ，如何区分是否是重载关系呢，评判的唯一标准“参数类型的数量和顺序”<br>与形式参数名字、返回值类型、权限修饰符都没关系！</p>
<h4 id="递归函数在内存中的过程"><a href="#递归函数在内存中的过程" class="headerlink" title="递归函数在内存中的过程"></a>递归函数在内存中的过程</h4><p>从语法结构而言，是一种函数调用自身的情况</p>
<p>函数是基于栈内存运行的，每一个函数称之为栈帧，简单地说是栈中的元素。对于一个函数帧而言，它 也占用了内存空间（函数的定义信息占用内存，函数内部需要占用内存函数体）如果一个函数中的内容 太多的话，它所占用的内存也就非常多。</p>
<p>注意：在使用递归的时候，一定要先确定他的边界条件</p>
<h2 id="数组及其运行原理"><a href="#数组及其运行原理" class="headerlink" title="数组及其运行原理"></a>数组及其运行原理</h2><h3 id="一维数组内存原理"><a href="#一维数组内存原理" class="headerlink" title="一维数组内存原理"></a>一维数组内存原理</h3><p>数组特点</p>
<ul>
<li><p>数组本质上就是由多个变量组成的连续空间 </p>
</li>
<li><p>这些变量的大小和存储的数值必须是一致的，数组只能存储同一类型的数据，这些变量的数据类型 是一致的（向下兼容）</p>
</li>
<li><p>这些变量的地址也就跟着连续了，空间大小也一样，好处就在于可以更方便的访问某个变量 An &#x3D; A1 + (n - 1) * d 第n个元素的地址 &#x3D; 第1个元素的地址 + （n - 1）* 变量大小，可以在O(1)时间 复杂度内快速访问某一个变量 </p>
</li>
<li><p>数组的大小一旦确定，则不能更改 </p>
</li>
<li><p>数组在Java中是属于对象类型，它所存储的空间在堆内存 </p>
</li>
<li><p>但凡在堆内存空间中的数据，都会有默认的初始化 </p>
</li>
<li><p>对于数组变量而言，它存储的是数组第一个元素的地址 </p>
</li>
<li><p>对于数组元素的访问，Java只支持角标访问，不支持指针访问， </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">*p = a[<span class="hljs-number">0</span>]<br>p++ ;	<span class="hljs-comment">//指针访问</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>index &#x3D; n - 1表示的就是该元素 与第1个元素之间的距离 An &#x3D; A1 + index * d arr[0]含义：数组中与第1个元素距离为0的元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//创建长度为10的int型数组，没有指定值，但是有默认初始化的值</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//创建int型数组，指定元素为1,2,3,所以长度也就为3</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="二维数组内存原理"><a href="#二维数组内存原理" class="headerlink" title="二维数组内存原理"></a>二维数组内存原理</h3><p>二维数组，本质上就是一个一维数组，只不过该一维数组中的没一个元素，是由其他的一维数组 组成而已</p>
<p>二维数组 &#x3D; 元素为一维数组的一维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] matrix = &#123;<br>	&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>	&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;,<br>	&#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br>&#125;;<br>IndexOutofRangeException 数组越界<br></code></pre></td></tr></table></figure>

<h3 id="数组常用操作——数组复制"><a href="#数组常用操作——数组复制" class="headerlink" title="数组常用操作——数组复制"></a>数组常用操作——数组复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.copyOf()  <span class="hljs-comment">// </span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copy(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-type">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        newArr[i] = arr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        arr = resize(arr, arr.length + <span class="hljs-number">1</span>);<br>        arr[arr.length - <span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i]);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] resize(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> len) &#123;<br>    <span class="hljs-type">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    	newArr[i] = arr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p>面向对象和面向过程都是解决问题的思想</p>
<ul>
<li>​	面向过程：执行者 费时间费精力 结果不一定完美</li>
<li>​    面向对象：指挥者 省时间省精力 各种角色各司其职</li>
</ul>
<p>如果Java没有需要的类，我们得自己创建</p>
<ul>
<li>封装：将具有重复性，规律性的代码进行封装，避免代码冗余</li>
<li>函数：将具有独立性。功能性的代码进行封装，避免代码冗余</li>
<li>类：将所要描述的事务的属性和行为经行封装</li>
</ul>
<p>设计类的时候，主要描述：</p>
<p>- </p>
<ul>
<li>数值——属性——变量&#x2F;常量——成员变量&#x2F;实例变量</li>
<li>行为——动作——函数&#x2F;方法——成员函数&#x2F;实例函数</li>
</ul>
<p>private 私有化 被修饰的成员只能在类的内部被访问，外部访问不到，一般会将变量进行私有化处理，为了避免对属性进行随意修改，于是就有了 修改器setter和访问器getter，可以在setXxx()函数中进行赋值的逻辑判断</p>
<p><img src="https://s2.loli.net/2024/02/23/zPYOb576jJghF1p.png" alt="image-20220819205828766"></p>
<p><strong>构造函数</strong></p>
<p>在创建对象时候给对象进行赋值</p>
<ul>
<li><p>没返回值（没void）</p>
</li>
<li><p>构造函数中有没有return进表示弹栈解释</p>
</li>
<li><p>名称必须与类名一致</p>
</li>
<li><p>在创建对象时调用</p>
<ul>
<li>构造函数能调用其他构造函数 this(…)，不能回调</li>
<li>构造函数可以调用成员函数，<br>   1.如果构造函数太长，可以把部分代码进行函数的封装，封装的结果也是一个成员函数，但是默认是private的，不能算是对象的行为。<br>    2.如果构造函数中为了避免代码功能性的冗余而重复调用该功能时，此时为public；</li>
<li>成员函数不能直接调用构造函数 （可以通过创建对象调用）</li>
<li>成员函数能调用成员函数</li>
</ul>
</li>
<li><p>构造函数可以重载</p>
</li>
<li><p>如果一个类中没有明显定义构造函数，有隐藏无参构造函数</p>
</li>
<li><p>对于构造函数，第一句要么是super()[隐藏的]，要么是this(…)手写，不可能同时存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>);   <span class="hljs-comment">//调用双参的构造函数</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name , <span class="hljs-type">int</span> sge)</span>&#123;<br>        <span class="hljs-built_in">super</span>();    <span class="hljs-comment">//默认隐藏</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="文件运行过程"><a href="#文件运行过程" class="headerlink" title="文件运行过程"></a>文件运行过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123; <span class="hljs-comment">//主类 主要负责运行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">20</span>);<br>        p1.speak();<br>        p2.speak();<br>        p1.setName(<span class="hljs-string">&quot;王五&quot;</span>);<br>        p1.setAge(<span class="hljs-number">30</span>);<br>        p1.speak();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-comment">//实体类 用于描述事物</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>(name, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-built_in">this</span>.age);<br>        print();<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//    public void Person()&#123;&#125;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        Person();</span><br><span class="hljs-comment">//        Person p = new Person();</span><br>        System.out.println(<span class="hljs-string">&quot;A person has been created!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是&quot;</span> + name + <span class="hljs-string">&quot;今年&quot;</span> + age + <span class="hljs-string">&quot;岁&quot;</span> + num);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.age = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125; <br><br></code></pre></td></tr></table></figure>



<ol>
<li><p>通过javac 进行命令进行编译  javac Test.java 一个类中有两个类，则会根据不同的类生成两个字节码文件</p>
</li>
<li><p>通过java命令进行运行 javaTest</p>
</li>
<li><p>将相关的字节码文件Test.class Person.class 加载进方法区</p>
</li>
<li><p>通过第二步提示 去test.class所在的内存中 找主函数， 加载进栈 开始运行</p>
</li>
<li><p>Person  p1 &#x3D; new Person( ); 先执行赋值好的右边</p>
</li>
<li><p>在堆内存中开辟一个存储空间</p>
</li>
<li><p>按照person.class字节码的定义 在该空间中，对成员变量进行创建</p>
</li>
<li><p>由于是在堆内存中  任何数据都有【默认初始化】 null  0</p>
</li>
<li><p>从person.class字节码文件 提取对应的构造函数Person()  进栈运行</p>
</li>
<li><p>为了区分那个对象调用该构造函数 构造函数中有一个this字段，区分那个对象调用</p>
</li>
<li><p>内部又调用this(String , int) 所以构造函数内部也又一个this字段， 形参也是举报变量</p>
</li>
<li><p>this(String, int) 第一句第一句是super() 调用完毕之后 立即【显示初始化】 age &#x3D; 10</p>
</li>
<li><p>接着执行this(String, int)的后面语句</p>
</li>
<li><p>【针对性初始化】this.age &#x3D; age; this.name &#x3D; name; 将局部变量的值给对象(this)中的变量</p>
</li>
<li><p>构造函数执行完毕后 弹栈</p>
</li>
<li><p>在主函数中创建p1变量 接收该对象的地址</p>
</li>
<li><p>p1.speak() 从Person.class字节码中调用</p>
</li>
<li><p>speak函数进栈 为了区分 this 0x123</p>
</li>
<li><p>由于speak函数中 没有局部变量name age 找对象中有木有name age</p>
<p>【局部-&gt;对象-&gt;静态-&gt;父类】</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/23/GtYlCByImxg1STE.png" alt="image-20220713102001520"></p>
<h4 id="this关键字以及成员变量与局部变量区别"><a href="#this关键字以及成员变量与局部变量区别" class="headerlink" title="this关键字以及成员变量与局部变量区别"></a>this关键字以及成员变量与局部变量区别</h4><ul>
<li>存储位置<ul>
<li>成员变量：存储在堆内存中，对象所属的空间</li>
<li>局部变量：存储在栈内存中，函数所属的空间</li>
</ul>
</li>
<li>生命周期<ul>
<li>成员变量：随着对象的创建而产生，随着对象的消亡而消失</li>
<li>局部变量：随着函数的进栈而产生，随着函数的弹栈而消失</li>
</ul>
</li>
<li>初始化<ul>
<li>成员变量：默认初始化，显示初始化，针对性初始化</li>
<li>局部变量：必须先赋值才能调用</li>
</ul>
</li>
<li>作用域<ul>
<li>成员变量：在类中全局</li>
<li>局部变量：在函数中，在函数中的代码快</li>
</ul>
</li>
</ul>
<p>成员变量和局部变量重名 this区分</p>
<h4 id="静态函数与静态变量"><a href="#静态函数与静态变量" class="headerlink" title="静态函数与静态变量"></a>静态函数与静态变量</h4><p>静态变量：其实就是对象们之间的共享数据</p>
<p>静态函数：只要函数内部不直接调用对象的成员，就可以定义为静态函数</p>
<p>静态的内容主要存在方法区：静态方法区 非静态方法区<br>            主函数是静态的 static</p>
<p>静态相关的内容随着类的加载而存在，随着类的消亡而消亡</p>
<p>静态也可以称为类成员，可以通过类名调用，也可以对象调用静态</p>
<h4 id="静态变量与成员变量区别"><a href="#静态变量与成员变量区别" class="headerlink" title="静态变量与成员变量区别"></a>静态变量与成员变量区别</h4><ul>
<li>存储位置<ul>
<li>存储在堆内存中，对象所属的空间</li>
<li>静态变量存储在静态方法区终端某一个字节码里</li>
</ul>
</li>
<li>生命周期<ul>
<li>成员变量：随着对象的创建而产生，随着对象的消亡而消失</li>
<li>静态变量随着类的加载而创建，随着类的消失而消失</li>
</ul>
</li>
<li>初始化<ul>
<li>成员变量：默认初始化，显示初始化，针对性初始化</li>
<li>静态变量：默认-显示-针对</li>
</ul>
</li>
<li>调用方式<ul>
<li>成员变量在内部由其非静态他成员直接调用，在外部创建对象调用</li>
<li>静态变量在内部由其他所有成员直接带哦有，在外部，类 或者 对象带哦有</li>
</ul>
</li>
</ul>
<h4 id="构造代码块与静态代码块"><a href="#构造代码块与静态代码块" class="headerlink" title="构造代码块与静态代码块"></a>构造代码块与静态代码块</h4><p><strong>11:00</strong></p>
<p>构造代码块是对 对象的初始化， 静态代码块 对</p>
<p>1.类只加载一次，静态代码块只执行一次</p>
<ol start="2">
<li></li>
</ol>
<h4 id="单例模式的设计思想"><a href="#单例模式的设计思想" class="headerlink" title="单例模式的设计思想"></a>单例模式的设计思想</h4><p>设计模式：他不是随着Java的诞生而出现的，而是后期Java的使用者通过实在经验</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过**extends **来声明继承父类即可。类不需要重新定义这些属性和方法，只需要通过扩展了来声明继承父类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">class 子类 extends 父类&#123;<br>	<span class="hljs-number">1.</span>子类拥有父类定义属性和方法<br>	<span class="hljs-number">2.</span>父类 叫 超类，基类<br>	<span class="hljs-number">3.</span>子类叫派生类<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>私有属性不能再子类中直接访问，需要通过公共方法去访问</p>
</li>
<li><p>子类必须调用父类的构造器，完成父类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">先调用父类构造器， 再调用子类构造器<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">()</span> &#123;<br>	 supur();	<span class="hljs-comment">//默认调用父类的无参构造器,不写也默认这个</span><br>        <br>	 supur(<span class="hljs-number">12</span>,<span class="hljs-number">32</span>);	<span class="hljs-comment">//指定调用父类 带参数构造器</span><br>       xxxx<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器,则必须在子类的构造器中用<strong>super</strong> 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下</p>
</li>
<li><p>super在使用时， 需要放在构造器第一行</p>
</li>
<li><p>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>java所有类都是Object类的子类，Object是所有类的基类</p>
</li>
<li><p>父类构造器的调用不限于直接父类!将一直往上追溯直到Object类(顶级父类)</p>
</li>
<li><p>子类最多<strong>只能继承一个父类</strong>(指直接继承)，即java中是单继承机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java 单继承 <br>	所以不存在 c++ python 多继承中 钻石继承问题<br></code></pre></td></tr></table></figure>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p>
</li>
</ol>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super代表父类的引用，用于访问父类的属性、方法、构造器</p>
<p>基本语法</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.访问父类的属性 ： super.属性名<br><span class="hljs-number">2</span>.访问父类的方法： super.方法名(参数列表)<br><span class="hljs-number">3</span>.访问父类的构造器：super(参数列表) 只能防止子类构造器第一句<br></code></pre></td></tr></table></figure>

<p>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使super去访问爷爷类的成员;如果多个基类(上级类)中都有同名的成员，使用supe访问遵循就近原则。A-&gt;B-&gt;C</p>
<p><img src="https://s2.loli.net/2024/02/23/Sy6RUeCMN9afusV.png" alt="image-20220820180222826"></p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p> 简单的说:方法覆盖(重写)就是子类有一个方法,和父类的某个方法的<strong>名称、返回类型、参数</strong>一样,那么我们就说子类的这个方法覆盖了父类的方法</p>
<p>注意：</p>
<ol>
<li><p>子类的方法的参数方法名称，要和父类方法的参数,方法名称完全一样。</p>
</li>
<li><p>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">abc</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">ab</span><span class="hljs-params">()</span>&#123;&#125;<br>		<span class="hljs-comment">// 满足重写规范</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>子类方法不能缩小父类方法的访问权限</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/23/PXJu4ya6VSI3rbW.png" alt="image-20220820181818612"></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<p>方法的多态</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">方法重载体现多态<br>方法重写体现多态<br></code></pre></td></tr></table></figure>

<p>对象的多态</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">一个对象的编译类型和运行类型可以不一致<br>编译类型在定义对象时，就确定了，不能改变<br>运行类型是可以变化的。<br>编译类型看定义时<span class="hljs-operator">=</span>号的左边，运行类型看<span class="hljs-operator">=</span>号的右边<br></code></pre></td></tr></table></figure>

<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>父类的引用指向了子类的对象</p>
<p>语法	父类类型	引用名 &#x3D; new 子类类型</p>
<p>特点：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">编译类型看左边，运行类型看右边。<br>可以调用父类中的所有成员(需遵守访问权限)，<br>	不能调用子类中特有成员;<br>最终运行效果看子类的具体实现!<br></code></pre></td></tr></table></figure>



<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>1)语法:子类类型	引用名&#x3D;	(子类类型) <strong>父类引用</strong>;</p>
<p>2)只能强转父类的<strong>引用</strong>，不能强转父类的对象</p>
<p>3)要求父类的引用必须指向的是当前目标类型的对象</p>
<p>4)可以调用子类类型中所有的成员</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">animal</span> <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span><br>animal.cry()<span class="hljs-comment">;</span><br><br>Cat cat <span class="hljs-operator">=</span> (Cat) animal<span class="hljs-comment">;  // animal 本身就指向Cat</span><br></code></pre></td></tr></table></figure>



<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">instanceOf</span> 比较操作符，判断对象的运行类型是否尾 xx类型 或 xx类型的子类型<br><br>属性看编译类型， 方法看运行类型<br></code></pre></td></tr></table></figure>

<h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><p>java 动态绑定机制</p>
<ol>
<li>当调用对象方法时候，该方法会和对象的内存地址&#x2F;<strong>运行类型</strong> 绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">属性看编译类型， 方法看运行类型<br><br></code></pre></td></tr></table></figure>

<h3 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h3><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">persons[i].study() <span class="hljs-comment">// 子类中方法 不能直接访问</span><br><span class="hljs-comment">// 编译类型为父类， 运行类型为子类</span><br><span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Student) &#123;<br>	<span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> (Student)persion[i].study();	<span class="hljs-comment">//向下转型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h3><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h3><p>&#x3D;&#x3D; 与 equels 区别：</p>
<p>&#x3D;&#x3D; </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">==：既可以判断基本类型，又可以判断引用类型<br><span class="hljs-number">1.</span>	如果判断基本类型，判断的是值是否相等。<br>			示例: <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>; <span class="hljs-type">double</span> d=<span class="hljs-number">10.0</span>;<br><span class="hljs-number">2.</span>	如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象<br></code></pre></td></tr></table></figure>

<p>equels：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">equals</span>:是Objecl类中的方法， 只能判断引用类型，<br>	默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如<span class="hljs-built_in">Integer</span>,<span class="hljs-built_in">String</span> <span class="hljs-meta">[</span>看看<span class="hljs-built_in">String</span> 和<span class="hljs-built_in">Integer</span>的<span class="hljs-keyword">equals</span> 源代码<span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure>



<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>​	哈希值&#x2F;哈希码&#x2F;哈希编码</p>
<p>任何一个对象都可以存入到哈希表这个映射HashMap Hashtable</p>
<p>返回对象的哈希码值。 支持这种方法是为了散列表，如[<code>HashMap</code>提供的那样</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>​	返回对象的字符串表现形式</p>
<p>默认返回:全类名+ @ +哈希值的十六进制，</p>
<p>子类往往重写<code>toString</code>方法，用于返回对象的属性信息</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><code class="hljs mercury"><span class="hljs-number">1</span>.当对象被回收时，系统自动调用该对象的<span class="hljs-keyword">finalize</span>方法。子类可以重写该方法，<br><span class="hljs-number">2</span>.什么时候被回收:当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用<span class="hljs-keyword">finalize</span>方法。<br><span class="hljs-number">3</span>.垃圾回收机制的调用，是由系统来决定(即有自己的GC算法)，也可以通过System.gc()主动触发垃圾回收机制，<br></code></pre></td></tr></table></figure>

<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="类变量-和-类方法"><a href="#类变量-和-类方法" class="headerlink" title="类变量 和 类方法"></a>类变量 和 类方法</h3><p>类变量</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi">什么时候需要用类变量<br>当我们需要让某个类的所有对象都共享一个变量时， 就可以考虑使用类变量(静态变量):比如:定义学生类，统计所有学生共交多少钱。Student (<span class="hljs-keyword">name</span>, fee)<br><br>类变量与实例变量(普通属性)区别<br>类变量是该类的所有对象共享的，而实例变量是每个对象独享的。<br><br><span class="hljs-number">3</span>.加上<span class="hljs-keyword">static</span>称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量<br><br><span class="hljs-number">4</span>.类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐 我们使用类名.类变量名方式访问。[前提是 满足访问修饰符的访问权限和范围]<br></code></pre></td></tr></table></figure>



<p>类方法</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">类方法经典的使用场景<br>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。<br></code></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>)类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:<br>	类方法中无<span class="hljs-keyword">this</span>的参数<br>	普通方法中隐含着<span class="hljs-keyword">this</span>的参数<br><span class="hljs-number">2</span>)类方法可以通过类名调用，也可以通过对象名调用。<br><span class="hljs-number">3</span>)普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类用。<br><span class="hljs-number">4</span>)类方法中不允许使用和对象有关的关键字，比如<span class="hljs-keyword">this</span>和<span class="hljs-keyword">super</span>。 普通方法(成员方法)可以。<br><span class="hljs-number">5</span>)类方法(静态方法)中只能访问静态变量或静态方法<br><span class="hljs-number">6</span>)普通成员方法，既可以访问非静态成员，也可以访问静态成员。<br></code></pre></td></tr></table></figure>

<p>小结:静态方法，只能访问静态的成员,非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>深入理解main方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript">解释main方法的形式: <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)&#123;&#125;<br><span class="hljs-number">1.</span> main方法时虚拟机调用<br><span class="hljs-number">2.</span> java虚拟机需要调用类的<span class="hljs-title function_">main</span>(方法， 所以该方法的访问权限必须是<span class="hljs-keyword">public</span><br><span class="hljs-number">3.</span> java虚拟机在执行<span class="hljs-title function_">main</span>(方法时不必创建对象，所以该方法必须是<span class="hljs-keyword">static</span><br><span class="hljs-number">4.</span>该方法接收<span class="hljs-title class_">String</span>类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，案例演示，接收参数.<br><span class="hljs-number">5.</span> java 执行的程序参数<span class="hljs-number">1</span>参数<span class="hljs-number">2</span>参数<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p> 代码化块又称为初始化块,属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</p>
<p>基本语法</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">[修饰符]&#123;<br>	代码<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>)修饰符可选，要写的话，也只能写static<br><span class="hljs-number">2</span>)代码块分为两类，使用static 修饰的叫静态代码块，没有static修饰的，叫普通代码块。<br><span class="hljs-number">3</span>)逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)<br><span class="hljs-number">4</span>);号可以写上，也可以省略。<br><br></code></pre></td></tr></table></figure>

<p>注意事项</p>
<p>总结：<br>static 代码块是随着类加载进行<br>普通代码块是在创建对象时调用，创建一次调用一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) <span class="hljs-keyword">static</span>代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象， 就执行。<br><br><span class="hljs-number">2</span>)**** 类什么时候被加载  ****<br>	①创建对象实例时(<span class="hljs-keyword">new</span>)<br>	②创建子类对象实例，父类也会被加载<br>	③使用类的静态成员时(静态属性，静态方法)<br>	<br><span class="hljs-number">3</span>)普通的代码块，在创建对象实例时，会被隐式的调用。<br>	被创建一次，就会调用一次。<br>	如果只是使用类的静态成员时，普通代码块并不会执行。<br>总结：<br><span class="hljs-keyword">static</span> 代码块是随着类加载进行<br>普通代码块是在创建对象时调用，创建一次调用一次<br>    <br><span class="hljs-number">4</span>)创建一个对象时，在一个类调用顺序是:(重点，难点) :<br>		静态-&gt;普通-&gt;构造器<br>	①调用静态代码块和静态属性初始化<br>        (注意:静态代码块和静态属性初始化调用的<span class="hljs-string">&#x27;优先级一样&#x27;</span>，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)<br>        <br>	②调用普通代码块和普通属性的初始化<br>        (注意:普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)<br>    ③调用构造方法。<br>            <br><span class="hljs-number">5</span>)构造器的最前面其实隐含了<span class="hljs-built_in">super</span>()和调用普通代码块，新写一个类演示，静态相关的代码块，属性初始化，在类加载时，就执行完毕因此是优先于构造器和普通代码块执行的<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-built_in">super</span>();<br>            <span class="hljs-comment">//调用普通代码块</span><br>            xxx<br>        &#125;<br>    &#125;<br><br><span class="hljs-number">6</span>)创建一个子类时(继承关系)，他们的静态代码块，静态属性初始化，<br>	普通代码块，普通属性初始化，构造方法的调用顺序如下:<br>	①父类的静态代码块和静态属性(优先级一样，按定义顺序执行)<br>    ②子类的静态代码块和静态属性(优先级一样，按定义顺序执行)<br>	③父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)<br>	④父类的构造方法<br>	⑤子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行)<br>    ⑥子类的构造方法<span class="hljs-comment">//面试题</span><br><br><span class="hljs-number">7</span>)静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员。<br></code></pre></td></tr></table></figure>

<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>●什么是单例模式——单例(单个的实例)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供个取得其对象实例的方法<br><br><span class="hljs-attribute">2</span>.单例模式有两种方式: <span class="hljs-number">1</span>) 饿汉式<span class="hljs-number">2</span>)懒汉式<br></code></pre></td></tr></table></figure>

<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-number">1</span>)构造器私有化=》防止直接<span class="hljs-keyword">new</span><span class="hljs-type"></span><br><span class="hljs-number">2</span>)类的内部创建对象<br><span class="hljs-number">3</span>)向外暴露一个静态的公共方法。getlInstance <br><span class="hljs-number">4</span>)代码实现<br></code></pre></td></tr></table></figure>

<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 创建一个类内私有对象</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">gf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">A</span><span class="hljs-params">(String)</span>name &#123;<span class="hljs-built_in">this</span>.name = name;&#125;<br>    <span class="hljs-comment">// 一个公共方法返回 对象</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> gf;<br>	&#125;<br>&#125;<br><span class="hljs-comment">// 饿汉式可以造成创建了对象 但没有使用</span><br></code></pre></td></tr></table></figure>

<p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat;<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<span class="hljs-built_in">this</span>.name = name&#125;	<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(cat == nukk)&#123;<br>            cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cat;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 懒汉式 在第一次调用时才会创建</span><br></code></pre></td></tr></table></figure>

<p>●饿汉式VS懒汉式</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">1</span>.二者最主要的区别在于创建对象的时机不同:饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。<br><span class="hljs-number">2</span>.饿汉式不存在线程安全问题，懒汉式存在线程安全问题。(后面学习线程后，会完善一把)<br><span class="hljs-number">3</span>.饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。<br><span class="hljs-number">4</span>.在我们javaSE标准类中，java.lang.<span class="hljs-keyword">Runtime</span>就是经典的单例模式。<br></code></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final中文意思:最后的，最终的. </p>
<p>final可以修饰类、属性、方法和局部变量.</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">在某些情况下，程序员可能有以下需求，就会使用到<span class="hljs-keyword">final</span>:<br><span class="hljs-number">1</span>)当不希望类被继承时，可以用<span class="hljs-keyword">final</span>修饰<br><span class="hljs-number">2</span>)当不希望父类的某个方法被子类覆盖/重写(<span class="hljs-keyword">override</span>)时，可以用<span class="hljs-keyword">final</span>关键字修饰。<br><span class="hljs-number">3</span>)当不希望类的的某个属性的值被修改，可以用<span class="hljs-keyword">final</span>修饰. <br><span class="hljs-number">4</span>)当不希望某个局部变量被修改，可以使用fina修饰<br></code></pre></td></tr></table></figure>

<p>注意事项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) <span class="hljs-keyword">final</span>修饰的属性又叫常量，般用XX_ XX XX来命名<br><span class="hljs-number">2</span>) <span class="hljs-keyword">final</span>修饰的属性在定义时,<span class="hljs-string">&#x27;必须赋初值&#x27;</span>并且以后<span class="hljs-string">&#x27;不能再修改&#x27;</span>，赋值可以在如下位置之一:<br>	①定义时:如<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> TAX RATE=<span class="hljs-number">0.08</span>;<br>	②在构造器中<br>	③在代码块中。<br><span class="hljs-number">3</span>)如果<span class="hljs-keyword">final</span>修饰的属性是静态的，则初始化的位置只能是<br>	①定义时②在静态代码块不能在构造器中赋值。<br><span class="hljs-number">4</span>) <span class="hljs-keyword">final</span>类不能继承，但是可以实例化对象。<br><span class="hljs-number">5</span>)如果类不是<span class="hljs-keyword">final</span>类，但是含有<span class="hljs-keyword">final</span>方法， 则该方法虽然不能重写，但是可以被继承。<br><span class="hljs-number">6</span>)一般来说，如果一个类已经是<span class="hljs-keyword">final</span>类了，就没有必要再将方法修饰成<span class="hljs-keyword">final</span>方法。<br><span class="hljs-number">7</span>) <span class="hljs-keyword">final</span>不能修饰构造方法(即构造器)<br><span class="hljs-number">8</span>) <span class="hljs-keyword">final</span>和<span class="hljs-keyword">static</span>往往搭配使用，效率更高，底层编译器做了优化处理。<br><span class="hljs-number">9</span>)包装类(Integer,Double,Float, Boolean等都是<span class="hljs-keyword">final</span>),String也是<span class="hljs-keyword">final</span>类。<br></code></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>)用<span class="hljs-keyword">abstract</span>关键字来修饰一个类时,这个类就叫抽象类<br>	访问修饰符<span class="hljs-keyword">abstract</span>类名&#123;&#125;`<br><span class="hljs-number">2</span>)用<span class="hljs-keyword">abstract</span>关键字来修饰一-个方法时，这个方法就是抽象方法<br>	访问修饰符<span class="hljs-keyword">abstract</span>返回类型方法名 ( 参数列表);<span class="hljs-comment">//没有方法体</span><br><span class="hljs-number">3</span>)抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()<br><span class="hljs-number">4</span>)抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多<br></code></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>)抽象类不能被实例化<br><span class="hljs-number">2</span>)抽象类不一定要包含<span class="hljs-keyword">abstract</span>方法。 也就是说，抽象类可以没有<span class="hljs-keyword">abstract</span>方法<br><span class="hljs-number">3</span>)一旦类包含了<span class="hljs-keyword">abstract</span>方法则这个类必须声明为<span class="hljs-keyword">abstract</span> <br><span class="hljs-number">4</span>) <span class="hljs-keyword">abstract</span>只能修饰类和方法，不能修饰属性和其它的。<br><span class="hljs-number">5</span>)抽象类可以有任意成员[(抽象类本质还是类] ,比如:非抽象方法、构造器、静态属性等<br><span class="hljs-number">6</span>)抽象方法不能有主体，即不能实现如图所示<br>       <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ccc</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-number">7</span>)如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为<span class="hljs-keyword">abstract</span>类。<br>             <br><span class="hljs-number">8</span>)抽象方法不能使用<span class="hljs-keyword">private</span>、<span class="hljs-keyword">final</span> 和<span class="hljs-keyword">static</span>来修饰，因为这些关键字都是和重写相违背的。<br></code></pre></td></tr></table></figure>

<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>将相同任务抽象到 抽象类中</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是给出一些没有实现的方法,封装到一 起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>	<span class="hljs-comment">//属性</span><br>	<span class="hljs-comment">//方法</span><br>&#125;<br><br><span class="hljs-title class_"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口</span>&#123;<br>	自己属性;<br>	自己方法;<br>	必须实现接口的抽象方法<br>&#125;<br><br>注意：<br><span class="hljs-number">1.</span>在Jdk7<span class="hljs-number">.0</span>前接口里的所有方法都没有方法体。都是抽象方法<br><span class="hljs-number">2.</span> Jdk8<span class="hljs-number">.0</span>后接口类可以有静态方法， 默认方法，也就是说接口中可以有方法的具体实现<br></code></pre></td></tr></table></figure>

<p>注意事项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>)接口不能被实例化<br><span class="hljs-number">2</span>)接口中所有的方法是<span class="hljs-keyword">public</span>方法，接口中抽象方法，可以不用<span class="hljs-keyword">abstract</span> 修饰图示:(所有方法默认抽象 )<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">aaa</span><span class="hljs-params">()</span>;<br>    实际上是<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aa</span><span class="hljs-params">()</span>;<br><span class="hljs-number">3</span>) -个普通类实现接口,就必须将该接口的所有方法都实现。<br><span class="hljs-number">4</span>)抽象类实现接口，可以不用实现接口的方法。<br><span class="hljs-number">5</span>)一个类同时可以实现多个接口<br><span class="hljs-number">6</span>)接口中的属性，只能是<span class="hljs-keyword">final</span>的，而且是<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>修饰符。	<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;实际上是<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>; (必须初始化)<br><span class="hljs-number">7</span>)接口中属性的访问形式:接口名.属性名<br><span class="hljs-number">8</span>)一个接口不能继承其它的类,但是可以继承多个别的接口[举例]<br>	<span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>,C&#123;&#125;<br><span class="hljs-number">9</span>)接口的修饰符只能是<span class="hljs-keyword">public</span>和默认，这点和类的修饰符是一样的。<br></code></pre></td></tr></table></figure>

<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj">继承 <span class="hljs-keyword">extends</span><br>多态 <span class="hljs-keyword">abstract</span><br>接口 <span class="hljs-keyword">implements</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt;&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E element)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/23/oH3RIixBXNYumD1.png" alt="image-20220824155227412"></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员(思考:类的五大成员是哪些?[属性，方法，构造器，代码块，内部类] ,内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;	<span class="hljs-comment">// 外部类</span><br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">lnner</span>&#123;	<span class="hljs-comment">//内部类</span><br>		<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span>&#123;	<span class="hljs-comment">//外部其他类</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">➢定义在外部类局部位置上(比如方法内) :<br>	<span class="hljs-number">1</span>)局部内部类(有类名)<br>	<span class="hljs-number">2</span>)<span class="hljs-string">&#x27;匿名内部类&#x27;</span>(没有类名,重点!!!)<br>        <br>➢定义在外部类的成员位置上:<br>	<span class="hljs-number">1</span>)成员内部类(没用<span class="hljs-keyword">static</span>修饰)<br>	<span class="hljs-number">2</span>)静态内部类(使用<span class="hljs-keyword">static</span>修饰)<br></code></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>说明:局部内部类是定义在外部类的局部位置，比如 方法中，并且有类名。</p>
<p>注意</p>
<ol>
<li><p>可以直接访问外部类的所有成员，包含私有的</p>
</li>
<li><p><strong>不能添加访问修饰符</strong>，因为它的地位就是一个局部变量。局部变量是不能使修饰符的。但是可以使用final修饰，因为局部变量也可以使用final</p>
</li>
<li><p><strong>作用域:仅仅在定义它的方法或代码块中</strong>。</p>
</li>
<li><p>局部内部类– -访的向—-&gt;外部类的成员[访问方式:直接访问]</p>
</li>
<li><p>外部类– -访向—-&gt;局部内部类的成员<br>访问方式:创建对象，再访问(注意:必须在作用域内)<br>    <strong>外部类 只能创建 对象访问内部类</strong><br>总结：</p>
</li>
</ol>
<p>​			<strong>1.局部内部类 定义在方法中&#x2F; 代码块<br>​				2.作用域在方法&#x2F; 代码块中<br>​				3.本质仍然是一个类</strong></p>
<ol start="6">
<li><p>外部其他类–不能访问 —–&gt;局部内部类(因为局部内部类地位是一一个局部变量)</p>
</li>
<li><p>如果外部类和局部内部类的成员重名时，默认遵循’就近原则’，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问[演示]<br>  <code>System. out.println(”外部类的n2=&quot; +外部类名.this.n2);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">外部类名.<span class="hljs-built_in">this</span><br>	0uter02. <span class="hljs-built_in">this</span>本质就是外部类的对象，即哪个对象调用了m1, 0uter02. <span class="hljs-built_in">this</span>就是哪个对象<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>说明:</p>
<p>​		匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 本质是类<br><span class="hljs-number">2.</span> 内部类<br><span class="hljs-number">3.</span> 该类没有名字 (系统分配的名字（底层/ 被隐藏 ）)<br><span class="hljs-number">4.</span> 同时还是一个对象<br></code></pre></td></tr></table></figure>

<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类或接口(参数列表)&#123;<br>	类体<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="基于接口的匿名内部类"><a href="#基于接口的匿名内部类" class="headerlink" title="基于接口的匿名内部类"></a>基于接口的匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 基于接口的匿名内部类</span><br>        <span class="hljs-comment">// 1. 需求：使用IA接口,并创建对象</span><br>        <span class="hljs-comment">// 2. 传统方式 定义一个类Tiger 实现接口 并创建接口</span><br>        <span class="hljs-comment">// 3. 如果 只使用异常，后面不在使用，可以</span><br>        <span class="hljs-comment">// 		使用匿名内部类简化开发</span><br>        <span class="hljs-comment">// 4. tiger 编译类型 ? IA</span><br>        <span class="hljs-comment">// 5. tiger 运行类型 ? 就是匿名内部类</span><br>        <span class="hljs-comment">// 底层 系统会分配  类名</span><br>        <span class="hljs-comment">// 匿名内部类名字 Outer$1 —— (系统分配)</span><br>        <span class="hljs-comment">// 6. jdk底层在创建匿名内部类Outer$1,立即马上就创建类 Outer$1的实例</span><br>        <span class="hljs-comment">// 并把地址返回给 tiger</span><br>        <span class="hljs-comment">// 7. 匿名内部类使用一次， 就不能再使用了</span><br>        <span class="hljs-type">IA</span> <span class="hljs-variable">tiger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IA</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;叫&quot;</span>);<br>            &#125;<br>        &#125;;<br>        tiger.cry();<br>        <span class="hljs-comment">// 获取运行类型</span><br>        System.out.println(<span class="hljs-string">&quot;tiger 运行类型&quot;</span> + tiger.getClass());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;叫&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 基于类的匿名内部类</span><br>        <span class="hljs-comment">// 1.father 编译类型 father</span><br>        <span class="hljs-comment">// 2. father 运行类型 Other$1</span><br>        <span class="hljs-comment">// 注意(&quot;jack&quot;) 参数列表会传递 给构造器</span><br>        <span class="hljs-type">Father</span>  <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&quot;jack&quot;</span>)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了test方法&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">// 直接进行调用</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>() &#123;<br>                      <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;gggg&quot;</span>);<br>            &#125;<br>        &#125;.test();<br><br>        <span class="hljs-comment">// 基于抽象类的匿名内部类</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;吃吃吃&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">(String name)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，应同时它本身也是一个<strong>对象</strong>，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。</li>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符,因为它的地位就是一个局部变量。</li>
<li>作用域:仅仅在定义它的方法或代码块中。</li>
<li>外部其他类—不能访—-&gt;匿名内部类(因为匿名内部类地位是一个局部变量)</li>
<li>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问</li>
</ol>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当作实参直接传递，简洁高效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        f1(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IL</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;ABCD&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(IL il)</span>&#123;<br>        il.show();<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IL</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>说明:成员内部类是定义在外部类的成员位置，并且没有static修饰。</p>
<ol>
<li><p>可以直接访问外部类的所有成员，包含私有的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>&#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员。</p>
</li>
<li><p>作用域：和外部类的其他成员一样，为整个类体比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法.</p>
</li>
<li><p>成员内部类—访问—-&gt;外部类(比如:属性) [访问方式:直接访问] (说明)</p>
</li>
<li><p>外部类—–访问—– 内部类(说明)访向方式:创建对象， 再访问</p>
</li>
<li><p>外部其他类—–访问—-&gt;成员内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">两种种方式<br><span class="hljs-number">1.</span><br>	AA.<span class="hljs-type">BB</span>  <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> aa.<span class="hljs-keyword">new</span> <span class="hljs-title class_">BB</span>();<br>	<br><span class="hljs-number">2.</span> 在外部类中，编写一个方法 可以返回 BB 对象<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问</p>
</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>说明:静态内部类是定义在外部类的成员位置，并且有static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>&#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</p>
</li>
<li><p>可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员。</p>
</li>
<li><p>作用域:同其他的成员，为整个类体</p>
</li>
<li><p>静态内部类–访问—-&gt;外部类(比如:静态属性) [访问方式:直接访问所有静态成员]</p>
</li>
<li><p>外部类– 访问—–&gt;静态内部类访问方式:创建对象，再访问</p>
</li>
<li><p>外部其他类–访问—– &gt;静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>因为静态内部类，可以通过类名直接访问（前提是满足访问权限） <br>	 AA.BB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>.BB();<br><span class="hljs-number">2.</span> 在外部类中，编写一个方法 可以返回 BB 对象<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员) 去访问</p>
</li>
</ol>
<h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><p>  自定义类实现枚举</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1.</span>不需要提供setXxx方法，因为枚举对象值通常为只读<br><span class="hljs-number">2.</span>对枚举对象/属性使用<span class="hljs-keyword">final</span> + <span class="hljs-keyword">static</span>共同修饰，实现底层优化.<br><span class="hljs-number">3.</span>枚举对象名通常使用全部大写，常量的命名规范.<br><span class="hljs-number">4.</span>枚举对象根据需要，也可以有多个属性<br></code></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1</span>)构造器私有化<br><span class="hljs-number">2</span>)本类内部创建一组对象<br><span class="hljs-number">3</span>)对外暴露对象(通过为对象添加<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span>修饰符)<br><span class="hljs-number">4</span>)可以提供<span class="hljs-keyword">get</span>方法，但是不要提供<span class="hljs-keyword">set</span><br></code></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>使用 <span class="hljs-keyword">enum</span> 替代 class<br><span class="hljs-number">2.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AAAa</span> <span class="hljs-variable">aaa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AAAA</span>(<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;zzzzz&quot;</span>);<br>	用 常量命(实参列表)<br><span class="hljs-number">3.</span>如果有多个常量(对象)，使用 , 间隔即可<br><span class="hljs-number">4.</span><span class="hljs-keyword">enum</span> 实现枚举 定义常量必须写在最前面<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AAAA</span>&#123;<br>    aaa(<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;zzzzz&quot;</span>),bbb(<span class="hljs-string">&quot;bbbb&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br>    AAAA(String name, String desc) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意</p>
<ol>
<li><p>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类[如何证明]</p>
<p>可使用 javap 工具 进行反编译查看</p>
</li>
<li><p>传统的public static final Season2 SPRING &#x3D; new Season2(“春天”，”温暖”);简化成SPRING(“春天”，”温暖”)， 这里必须知道，它调用的是哪个构造器.</p>
</li>
<li><p>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</p>
</li>
<li><p>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</p>
</li>
<li><p>枚举对象必须放在枚举类的行首.</p>
</li>
</ol>
<h4 id="enum-方法"><a href="#enum-方法" class="headerlink" title="enum 方法"></a>enum 方法</h4><p>说明:使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类相关的方法。[看 下源码定义.]</p>
<ol>
<li><p>toString:Enum类已经重写过了，返回的是当前对象名子类可以重写该方法，用于返回对象的属性信息</p>
</li>
<li><p>name:返回当前对象名(常量名)，子类中不能重写</p>
</li>
<li><p>ordinal:返回当前对象的位置号，默认从0开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">aaa(<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;zzzzz&quot;</span>),bbb(<span class="hljs-string">&quot;bbbb&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br>	<span class="hljs-number">0</span>					<span class="hljs-number">1</span>					<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>values:返回当前枚举类中所有的常量 （反编译可以看到）</p>
</li>
<li><p>valueOf: 将字符串转换成枚举对象，要求字符串必须为已有的常量名， 否则报异常!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;T&gt;&gt; T <span class="hljs-title function_">valueOf</span><span class="hljs-params">(类&lt;T&gt; enumType,String name)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>compareTo:比较两个枚举常量，比较的就是位置号!</p>
</li>
</ol>
<p>注意</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-number">1</span>)使用<span class="hljs-keyword">enum</span>关键字后，就不能再继承其它类了，因为<span class="hljs-keyword">enum</span>会隐式继承<span class="hljs-keyword">Enum</span>,而Java是单继承机制。<br><span class="hljs-number">2</span>)枚举类和普通类一样，可以实现接口，如下形式。<br>	<span class="hljs-keyword">enum</span>类名<span class="hljs-keyword">implements</span>接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span><span class="hljs-comment">&#123;&#125;</span><br></code></pre></td></tr></table></figure>



<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Override注解"><a href="#Override注解" class="headerlink" title="@Override注解"></a>@Override注解</h3><p>@Override:限定某个方法，是重写父类方法，该注解只能用于方法</p>
<p>说明</p>
<ol>
<li>@Override表示指定重写父类的方法(从编译层牵验证)，如果父类没有fly方法，则会报错</li>
<li>如果不写@Override注解，而父类仍有public void fly({} ,仍然构成重写</li>
<li>@Override只能修饰方法，不能修饰其它类，包，属性等等</li>
<li>查看@Override注解源码为@ Target(ElementType.METHOD)，说明只能修饰方法</li>
<li>@Target是修饰注解的注解，称为元注解</li>
</ol>
<h3 id="Deprecated注解"><a href="#Deprecated注解" class="headerlink" title="@Deprecated注解"></a>@Deprecated注解</h3><p>@Deprecated:用于表示某个程序元素(类，方法等已过时</p>
<p>说明</p>
<ol>
<li>用于表示某个程序元素(类，方法等)已过时</li>
<li>2.可以修饰方法，类，字段，包,参数等等</li>
<li>@Target(value&#x3D; {CONSTRUCTOR, FIELD, LOCAL VARIABLE, METHOD,PACKAGE, PARAMETER, TYPE}) </li>
<li>@Deprecated的作用可以做到新旧版本的兼容和过渡</li>
</ol>
<h3 id="SuppressWarnings注解"><a href="#SuppressWarnings注解" class="headerlink" title="@SuppressWarnings注解"></a>@SuppressWarnings注解</h3><p>@SuppressWarnings:抑制编译器警告 （抑制黄色警告）</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;unchedcked&quot;</span>,<span class="hljs-string">&quot;unused&quot;</span>&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span><br></code></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法</p>
<p>错误和逻辑错误不是异常)</p>
<p>●执行过程中所发生的异常事件可分为两类</p>
<ol>
<li>Error(错误): Java虚拟机无法解决的严重问题。如: JVM系统内部错误、资源耗尽等严重情况。比如: StackOverflowError[栈溢出]和OOM(out ofmemory), Error 是严重错误，程序会崩溃。</li>
<li>Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类:运行时异常[]和编译时异常[]。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/23/EVCuGo1yLwjMf8D.png" alt="image-20220826162952567"></p>
<ol>
<li>异常分为两大类，运行时异常和编译时异常.</li>
<li>运行时异常，编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常</li>
<li>对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li>
<li>编译时异常，是编译器要求必须处置的异常。</li>
</ol>
<h3 id="常见运行时异常"><a href="#常见运行时异常" class="headerlink" title="常见运行时异常"></a>常见运行时异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) NullPointerException		<span class="hljs-comment">//空指针异常</span><br>    当应用程序试图在需要对象的地方使用<span class="hljs-literal">null</span>时，抛出该异常<br><span class="hljs-number">2</span>) ArithmeticException		<span class="hljs-comment">//数学运算异常</span><br><span class="hljs-number">3</span>) ArrayIndexOutOfBoundsException <span class="hljs-comment">//数组下标越界异常</span><br><span class="hljs-number">4</span>) ClassCastException		<span class="hljs-comment">//类型转换异常</span><br><span class="hljs-number">5</span>) NumberFormatException	<span class="hljs-comment">//数字格式不正确异常</span><br></code></pre></td></tr></table></figure>

<h3 id="常见编译异常"><a href="#常见编译异常" class="headerlink" title="常见编译异常"></a>常见编译异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> SQLException <span class="hljs-comment">//操作数据库时，查询表可能发生异常</span><br><span class="hljs-number">2.</span> IOException <span class="hljs-comment">//操作文件时，发生的异常</span><br><span class="hljs-number">3.</span> FileNotFoundException <span class="hljs-comment">//当操作一个不存在的文件时， 发生异常</span><br><span class="hljs-number">4.</span> ClassNotFoundException <span class="hljs-comment">//加载类，而该类不存在时，异常</span><br><span class="hljs-number">5.</span> EOFException <span class="hljs-comment">//操作文件，到文件末尾，发生异常</span><br><span class="hljs-number">6.</span> llegalArguementException <span class="hljs-comment">//参数异常</span><br></code></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常处理就是当异常发生时，对异常处理的方式。</p>
<p> 异常处理的方式</p>
<ol>
<li>try-catch-finally</li>
</ol>
<p>   程序员在代码中捕获发生的异常，自行处理</p>
<ol start="2">
<li><p>throws，</p>
<p>将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	代码/可能有异常<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <span class="hljs-comment">//捕获到异常</span><br>    <span class="hljs-number">1.</span>异常发生时<br>    <span class="hljs-number">2.</span>系统将异常封装成 Exception 对象e, 传递给<span class="hljs-keyword">catch</span><br>    <span class="hljs-number">3.</span>得到异常对象后，程序员自己处理<br>	<span class="hljs-number">4.</span>如果没有发生异常<span class="hljs-keyword">catch</span>代码块不执行<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 不管try 代码块是否有异常，始终执行finally</span><br>    <span class="hljs-comment">// finally return 返回最高</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">throws</span> 处理机制<br><span class="hljs-number">1.</span> <span class="hljs-keyword">try</span> - <span class="hljs-keyword">catch</span> -<span class="hljs-keyword">finally</span> 和 <span class="hljs-keyword">throws</span> erxuanyi<br><span class="hljs-number">2.</span>如果程序员，没有显示处理异常 默认为<span class="hljs-keyword">throws</span><br></code></pre></td></tr></table></figure>

<h4 id="try-catch注意"><a href="#try-catch注意" class="headerlink" title="try-catch注意"></a>try-catch注意</h4><ol>
<li>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块.</li>
<li>如果异常没有发生，则顺序执行try的代码块，不会进入到catch.</li>
<li>如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally { } </li>
<li>可以有多个catch语句，捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception在后，NullPointerException 在前)，如果发生异常，只会匹配一个catch,</li>
<li>可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉。应用场景，就是执行一-段代码， 不管是否发生异常，都必须执行某个业务逻辑</li>
</ol>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ol>
<li>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</li>
</ol>
<p><strong>使用细节</strong></p>
<ol>
<li>对于编译异常，程序中必须处理，比如try- catch或者throws</li>
<li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li>
<li><strong>子类重写父类的方法</strong>时，对抛出异常的规定:子类重写的方法，所抛出的异常类型么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</li>
<li>在throws过程中，如果有方法try-catch ,就相当于处理异常，就可以不必throws</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>●自定义异常的步骤</p>
<ol>
<li>定义类:自定义异常类名(程序员自己写)继承Exception或RuntimeException</li>
<li>如果继承Exception,属于编译异常</li>
<li>如果继承RuntimeException,属于运行异常(一般来说，继承RuntimeException)</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">一般情况都是继承<span class="hljs-built_in">RuntimeException</span>运行时异常 可以使用默认异常处理方式<br></code></pre></td></tr></table></figure>

<p><strong>throw 和 throws</strong></p>
<p><img src="https://s2.loli.net/2024/02/23/S2HVLvxiPhXom9K.png" alt="image-20220826182810982"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnExceptionDemo</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			System.out.println(<span class="hljs-string">&quot;进入方法A&quot;</span>);<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;制造异常&quot;</span>);<br>		&#125; <span class="hljs-keyword">finally</span> &#123;	<br>			System.out.println(<span class="hljs-string">&quot;用A方法的finally&quot;</span>);<br>		&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(StringD] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br></code></pre></td></tr></table></figure>

<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<h4 id="包装类-和-String-相互转换"><a href="#包装类-和-String-相互转换" class="headerlink" title="包装类 和 String 相互转换"></a>包装类 和 String 相互转换</h4><p><strong>包装类转String</strong></p>
<p>三种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();<br><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> String.valueof();<br></code></pre></td></tr></table></figure>

<p><strong>String转包装类</strong></p>
<p>两种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> Integer.parseInt(str4);	<span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">Interger</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str4);	<span class="hljs-comment">//构造器</span><br></code></pre></td></tr></table></figure>



<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">in</span>  <br></code></pre></td></tr></table></figure>



<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol>
<li><p>String对象用于保存字符串，也就是一-组字符序列</p>
</li>
<li><p>字符串常量对象是用双引号括起的字符序列。例如: “你好”、”12.97”、 </p>
</li>
<li><p>字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。</p>
</li>
<li><p>String类较常用构造器(其它看手册):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">S1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(); <br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String original);<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[] a);<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[] a,<span class="hljs-type">int</span> startIndex,<span class="hljs-type">int</span> count)<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String 实现了 serializable 说明String 可以串行化 可以在网络中传输<br>String 实现了 Comparable 说明String对象可以比较大小<br>    <br>String 是 <span class="hljs-keyword">final</span> 类 不能被继承<br>String 有属性 <span class="hljs-keyword">private</span> finaL <span class="hljs-type">char</span> value[]; 用于存放字符串内容<br>    value 是 一个 <span class="hljs-keyword">final</span> 类型，不可以被修改<br></code></pre></td></tr></table></figure>



<p><strong>创建String对象的两种方式</strong></p>
<ol>
<li><p>方式一:直接赋值<code>String S = &quot;hspedu&quot;</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">方式一:先从常量池查看是否有<span class="hljs-string">&quot;hsp&quot;</span>数据空间，如果有，直接指向;如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式二:调用构造器<code>String s = new String(&quot;hspedu&quot;)</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">方式二:先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。如果常量池没有<span class="hljs-string">&quot;hsp&quot;</span>,重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。<br>    <br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (<span class="hljs-string">&quot;hsp&quot;</span>) <br>    <span class="hljs-comment">// b指向堆中对象  b.intern() 指向常量池</span><br>    b == b.intern  <span class="hljs-comment">//false</span><br><br><span class="hljs-string">&quot;注意 ：==基本数据类型比较值，应用数据类型比较地址&quot;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">equals <span class="hljs-comment">//区分大小写，判断内容是否相等</span><br>equalslgnoreCase <span class="hljs-comment">//忽略大小写的判断内容是否相等</span><br>length <span class="hljs-comment">//获取字符的个数，字符串的长度</span><br>indexOf <span class="hljs-comment">//获取字符(字符串)在字符串中第1次出现的索引,索引从0开始，如果找不到,返回-1</span><br>lastIndexOf <span class="hljs-comment">//获取字符(字符串)  在字符串中最后1次出现的索引,索引从0开始,如找不到,返回-1</span><br>substring <span class="hljs-comment">//截取指定范围的子串 substring(0,5) 截取到5不包括5</span><br>trim <span class="hljs-comment">//去前后空格</span><br>charAt <span class="hljs-comment">//获取某索引处的字符，注意不能使用Str[index]这种方式.</span><br>toUpperCase		<span class="hljs-comment">// 转大写</span><br>toLowerCase		<span class="hljs-comment">//转小写</span><br>concat	<span class="hljs-comment">// 字符串拼接 s1.concat(&quot;a&quot;).concat(&quot;bc&quot;)</span><br>replace <span class="hljs-comment">//替换字符串中的字符</span><br>split	<span class="hljs-comment">//分割字符串，对于某些分割字符，我们需要转义比如| 1等</span><br>compareTp <span class="hljs-comment">//比较两个字符串的大小</span><br>toCharArray <span class="hljs-comment">//转换成字符数组</span><br>format <span class="hljs-comment">//格式字符串，%s字符串%C字符%d整型%.2f浮点型</span><br></code></pre></td></tr></table></figure>

<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p>
<p>很多方法与String相同，但StringBuffer是可变长度的。</p>
<p>StringBuffer是一个容器。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>StringBuffer 的直接父类是 AbstractStringBuilder<br><span class="hljs-number">2.</span> StringBuffer 实现了SeriaLizable接口,即StringBuffer是可串行化<br><span class="hljs-number">3.</span>在父类中 AbstractStringBuilder 用属性 <span class="hljs-type">char</span>[] value 用于存放字符串 <span class="hljs-comment">// 不是final</span><br><span class="hljs-number">4.</span> 该 value 数组 不是<span class="hljs-keyword">final</span> 依次字符串是存放在<span class="hljs-string">&#x27;堆&#x27;</span>中的<br><span class="hljs-number">5.</span> StringBuffer 是<span class="hljs-keyword">final</span>类不能被继承<br></code></pre></td></tr></table></figure>

<p><strong>String VS StringBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) String 保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低<span class="hljs-comment">//private final char value[];</span><br><span class="hljs-number">2</span>) StringBuffer 保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高<br>    只有内存(数组长度)不够时，才会更新地址<br><span class="hljs-comment">//char[] value;/这个放在堆.</span><br></code></pre></td></tr></table></figure>

<p><strong>StringBuffer 与 String相互转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>String转StringBuffer<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello tom&quot;</span>;<br><span class="hljs-comment">// 方式1 使用构造器</span><br><span class="hljs-comment">////注意:返回的才 是StringBuffer对象，对str 本身没有影响</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(str) ;<br><br><span class="hljs-comment">// 方式2使用append方法</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>StringBuffer = stringBuffer1.append(stp);<br><br><span class="hljs-number">2.</span>StringBuffer转String<br><span class="hljs-comment">// 方式1：使用StringBuffer提供的toString方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringBuffer3. toString();    <br><span class="hljs-comment">// 方式2：使用构造器来搞定</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(stringBuffer3);<br></code></pre></td></tr></table></figure>

<p><strong>StringBuffer 常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>)增 append<br><span class="hljs-number">2</span>)删 delete(start,end)<br><span class="hljs-number">3</span>)改 replace(start,end,string) <br>		<span class="hljs-comment">//将start---end间的内容替换成string,不含end</span><br><span class="hljs-number">4</span>)查 indexOf <span class="hljs-comment">//查找子串在字符串第1次出现的索引，如果找不到返回- 1</span><br><span class="hljs-number">5</span>)插 insert(index, string) 在index前面插入string<br><span class="hljs-number">6</span>)获取长度 length<br></code></pre></td></tr></table></figure>

<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ol>
<li>一个可变的字符序列。此类提供一个与 StringBuffer兼容的API,但不保证同步（StringBuilder，不是线程安全）。该类被设计用作StringBuffer的一一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快[后面测]</li>
<li>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。</li>
</ol>
<p><strong>String、 StringBuffer 和StringBuilder的比较</strong></p>
<ol>
<li><p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p>
</li>
<li><p>String:不可变字符序列，效率低，但是复用率高。</p>
</li>
<li><p>StringBuffer:可变字符序列、效率较高(增删)、线程安全</p>
</li>
<li><p>StringBuilder:可变字符序列、效率最高、线程不安全</p>
</li>
<li><p>String使用注意说明: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">string</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; 创建了一个字符串<br>s += <span class="hljs-string">&quot;b&quot;</span>; <br>	<span class="hljs-comment">//实际上原来的&quot; a&quot;字符串对象已经丢弃了，现在又产生了一个字符串S+ &quot;b&quot; (也就是”ab&quot;)。如果多次执行这些改 变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=&gt;结论:如果我们对String做大量修改，不要使用String</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p><code>效率: StringBuilder &gt; StringBuffer &gt; String</code></p>
<p><strong>String、StringBuffer 和StringBuilder的选择</strong></p>
<p>1.如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder<br>2.如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder<br>3.如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer<br>4.如果我们字符串很少修改，被多个对象引用，使用String, 比如配置信息等</p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 中都是静态方法：</p>
<p>常用方法:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1</span>) <span class="hljs-built_in">abs</span>绝对值<br><span class="hljs-number">2</span>) <span class="hljs-built_in">pow</span>求幂<br><span class="hljs-number">3</span>) <span class="hljs-built_in">ceil</span> 向上取整， 返回&gt;=该参数的最小整数(转成<span class="hljs-type">double</span>)<br><span class="hljs-number">4</span>) <span class="hljs-built_in">floor</span>向下取整<br><span class="hljs-number">5</span>) <span class="hljs-built_in">round</span>四舍五入<br><span class="hljs-number">6</span>) <span class="hljs-built_in">sqrt</span>求开方<br><span class="hljs-number">7</span>) <span class="hljs-built_in">random</span>求随机数<span class="hljs-comment">//思考:</span><br><span class="hljs-number">8</span>) <span class="hljs-built_in">max</span>求两个数的最大值<br><span class="hljs-number">9</span>) <span class="hljs-built_in">min</span>求两个数的最小值<br></code></pre></td></tr></table></figure>

<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Arrays里面包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) toString返回数组的字符串形式<br>	Arrays.toString(arr)<br><span class="hljs-number">2</span>) sort排序(自然排序和定制排序)	<br>	Integer arr[] = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">89</span>&#125;;<br>	sort重载，可以通过传入一个接口 Comparator 实现定制排序<br>        传入两个参数 <br>        <span class="hljs-number">1.</span> arr排序数组<br>        <span class="hljs-number">2.</span> 实现了Comparator接口的匿名内部类,要求实现compare方法<br>        Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2 - o1;<br>            &#125;<br>        &#125;);       <br><br><br><span class="hljs-number">3</span>) binarySearch通过二分搜索法进行查找，要求必须排好序<br>	<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(arr, <span class="hljs-number">3</span>);<br>		<span class="hljs-comment">// 如果不存在 return -(low + 1)  应该存在的位置+1 取反</span><br><br><span class="hljs-number">4</span>) copyOf数组元素的复制<br>    Integer[] newArr = Arrays.copyOf(arr, arr.length);<br>	<span class="hljs-number">1.</span> 从arr数组中，拷贝arr.Length个元素到newArr数组中<br>	<span class="hljs-number">2.</span> 如果拷贝的长度 &gt; arr.Length 就在新数组的后面增加nuLL<br>	<span class="hljs-number">3.</span>如果拷贝长度&lt; <span class="hljs-number">0</span>就抛出异常NegativeArT aySizeException<br><br><span class="hljs-number">5</span>) fill数组元素的填充<br>    Integer[] num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;; <br>	Arrays.fill(num, <span class="hljs-number">99</span>);	<span class="hljs-comment">//使用99替换所有元素</span><br><span class="hljs-number">6</span>) equals比较两个数组元素内容是否完全一致<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">equals</span> <span class="hljs-operator">=</span> Arrays.equals(arr, arr2);<br><span class="hljs-number">7</span>) asList将一组值，转换成list<br>    List&lt;Integer&gt; asList = Arrays.asList(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br>	System.out.println(<span class="hljs-string">&quot; asList=&quot;</span> + asList);<br></code></pre></td></tr></table></figure>



<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) exit退出当前程序<br><span class="hljs-number">2</span>) arraycopy :复制数组元素，<br>比较适合底层调用，一般使用Arrays.copyOf完成复制数组.<br>    <span class="hljs-type">int</span>[] src=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-type">int</span>[] dest =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>	System.arrayCopy(src, <span class="hljs-number">0</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        srcPos:从源数组的哪个索引位置开始拷贝<br>        dest:目标数组，即把源数组的数据拷贝到哪个数组<br>        destPos:把源数组的数据拷贝到日标数组的哪个索引<br>        length ：拷贝长度<br><span class="hljs-number">3</span>) current TimeMillens:返回当前时间距离<span class="hljs-number">1970</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>的毫秒数<br><span class="hljs-number">4</span>) gc:运行垃圾回收机制System.gc();<br></code></pre></td></tr></table></figure>

<h3 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h3><ol>
<li>BigInteger适合保存比较大的整型</li>
<li>BigDecimal适合保存精度更高的浮点型(小数)</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">不能直接 + - * / ,调用方法实现 <br><span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>加<br><span class="hljs-number">2</span>) <span class="hljs-built_in">subtract</span>减<br><span class="hljs-number">3</span>) <span class="hljs-built_in">multiply</span>乘<br><span class="hljs-number">4</span>) <span class="hljs-built_in">divide</span>除<br></code></pre></td></tr></table></figure>





<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) Date:精确到毫秒，代表特定的瞬间<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">//获取当前系统时间</span><br>    System . out. printLn(<span class="hljs-string">&quot;当前日期=”+ d1);</span><br><span class="hljs-string">    Date d2 = new Date(9234567); //通过指定亳秒数得到时间</span><br><span class="hljs-string">    System. out . printLn(&quot;</span>d2=f + d2); <span class="hljs-comment">//获取某个时间对应的亳秒数</span><br><br><span class="hljs-number">2</span>) SimpleDateFormat:格式和解析日期的类<br>   SimpleDateFormat格式化和解析日期的体类。<br>   它允许进行格式化(日期-&gt;文本)、解析(文本-&gt;日期)和规范化<br><br> <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpLeDateFormat</span> (<span class="hljs-string">&quot;yyyy年MM月dd日hh:mm:ss E&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> sdf.format(d1); <span class="hljs-comment">// format:将 日期转换成指定格式的字符串</span><br>System.out.printLn(<span class="hljs-string">&quot;当前日期=&quot;</span> + format) ; <br></code></pre></td></tr></table></figure>

<h3 id="Calender"><a href="#Calender" class="headerlink" title="Calender"></a>Calender</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="框架体系"><a href="#框架体系" class="headerlink" title="框架体系"></a>框架体系</h3><ul>
<li><p>集合主要是两组（单列集合，双列集合）</p>
</li>
<li><p>Collection 接口有两个重要的子接口 List Set , 都是单列集合</p>
</li>
<li><p>Map实现子类 是双列集合 存放 K -V</p>
<p><img src="https://s2.loli.net/2024/02/23/IBu9lYSCOevMr4L.png" alt="image-20220925102223674"></p>
<p><img src="https://s2.loli.net/2024/02/23/IjEsPgaQnYvehOy.png" alt="image-20220925102245343"></p>
</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>●Collection接口实现类的特点<br>public interface Collection<E> extends Iterable<E></p>
<ol>
<li>collection实现子类可以存放多个元素，每个元素可以是0bject</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>
<li>有些Gollection的实现类，有些是有序的(List)， 有些不是有序(Set)</li>
<li>Collection接口没有直接的实现子类，是通过它的子接口Set和List来<br> 实现的</li>
</ol>
<h4 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) add:添加单个元素<br><span class="hljs-number">2</span>) remove:删除指定元素<br><span class="hljs-number">3</span>) contains:查找元素是否存在<br><span class="hljs-number">4</span>) size:获取元素个数<br><span class="hljs-number">5</span>) isEmpty:判断是否为空<br><span class="hljs-number">6</span>) clear:清空<br><span class="hljs-number">7</span>) addAll:添加多个元素<br><span class="hljs-number">8</span>) containsAll:查找多个元素是否都存在<br><span class="hljs-number">9</span>) removeAll:删除多个元素<br></code></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Collection接口遍历元素方式1 -使用Iterator迭代器)<br> <img src="https://s2.loli.net/2024/02/23/4JAtrRF5K13YfnD.png" alt="image-20220925112953313"></p>
<ol>
<li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。</li>
<li>所有实现了Collection接口的集合类都有一 个iterator()方法， 用以返回<br> -个实现了Iterator接口的对象，即可以返回一个迭代器。</li>
<li>Iterator的结构.</li>
<li>Iterator仅用于遍历集合，Iterator本身并不存放对象。</li>
</ol>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">Iterator iterator = coll.iterator(); <span class="hljs-regexp">//</span>得到一个集合的迭代器<br>	<span class="hljs-regexp">//</span>hasNext():判断是否还有下一个元素<br><span class="hljs-keyword">while</span>(iterator.hasNext()&#123;<br>	<span class="hljs-regexp">//</span><span class="hljs-keyword">next</span>():作用<br>			<span class="hljs-number">1</span>.下移<br>			<span class="hljs-number">2</span>.将下移以后集合位置上的元素返回<br>System. out.println(iterator.<span class="hljs-keyword">next</span>());<br></code></pre></td></tr></table></figure>

<p>提示:在调用iterator.next(方法之前必须要调用iterator.hasNext()<br>●进行检测。若不调用，且下一条记录无效，直接调用it.next(会抛出<br>NoSuchElementException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先使用for增强 foreach</span><br><span class="hljs-keyword">for</span> (0bject dog : List) &#123;<br>System. out . printLn(<span class="hljs-string">&quot;dog=&quot;</span><span class="hljs-string">&quot; + dog); </span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">//使用迭代器</span><br><span class="hljs-string">System. out . printLn(&quot;</span>===使用迭代器来遍历===<span class="hljs-string">&quot;);</span><br><span class="hljs-string">Iterator iterator = List.iterator();</span><br><span class="hljs-string">while (iterator . hasNext()) &#123;</span><br><span class="hljs-string">	Object dog = iterator . next();</span><br><span class="hljs-string">	System. out . printLn(&quot;</span>dog=<span class="hljs-string">&quot; + dog);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>



<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口和常用方法</p>
<p>●List接口基本介绍<br>List接口是Collection接口的子接口</p>
<ol>
<li>List集合类中元素有序(即添加顺序和取出顺序一致)、 且可重复</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根<br>据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类有:ArrayList、LinkedList和Vector。</li>
</ol>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List集合里添加了一些根据索引来操作集合元素的方法<br><span class="hljs-number">1</span>) <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Object ele)</span>:在index位置插入ele元素<br><span class="hljs-number">2</span>) <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection eles)</span>:index位置开始将eles中的所有元素添加进来<br><span class="hljs-number">3</span>) Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>:获取指定index位置的元素<br><span class="hljs-number">4</span>) <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object obj)</span>:返回obj在集合中首次出现的位置<br><span class="hljs-number">5</span>) <span class="hljs-type">int</span> <span class="hljs-title function_">lastlndexOf</span><span class="hljs-params">(Object obj)</span>:返回obj在当前集合中未次出现的位置<br><span class="hljs-number">6</span>) Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>:移除指定index位置的元素，井返回此元素<br><span class="hljs-number">7</span>) Object <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Object ele)</span>:设置指定index位置的元素为ele，相当于是替换.<br><span class="hljs-number">8</span>) List <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> tolndex)</span>:返回从fromIndex到tolndex位置的子集合<br>	fromIndex &lt;= subList &lt; toIndex <br></code></pre></td></tr></table></figure>

<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ol>
<li><p>迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> list. iterator() ;<br>    <span class="hljs-keyword">while</span> (iterator . hasNext()) &#123; <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator .next();<br>    System. out . printLn(obj); <br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>for each</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (object o : list) &#123;<br>	System . out . printLn(<span class="hljs-string">&quot;o=&quot;</span> + o);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>普通佛如循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>	System. out . printLn(<span class="hljs-string">&quot;对象=&quot;</span> + List. get(i));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/11/02/Linux/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">CNPM Binaries Mirror (npmmirror.com)</a></p>
<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name 用户名 设置用户签名</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email 邮箱 设置用户签名</span><br>git init 			初始化本地库<br>git <span class="hljs-built_in">status</span> 			查看本地库状态<br>git add 			文件名 添加到暂存区<br>git commit -m 		<span class="hljs-string">&quot;日志信息&quot;</span> 文件名 提交到本地库<br>git reflog 			查看历史记录<br>git reset <span class="hljs-comment">--hard 	版本号 版本穿梭</span><br></code></pre></td></tr></table></figure>

<h3 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h3><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name 用户名</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email 邮箱</span><br></code></pre></td></tr></table></figure>

<p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看 到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。 </p>
<p>※注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任 何关系。</p>
<h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><h3 id="github提交流程"><a href="#github提交流程" class="headerlink" title="github提交流程"></a>github提交流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git init	//初始化<br>git add .	//所有文件添加到暂存区<br>git commit -m &quot;xxxx&quot; 提交到本地库<br><br>$ git remote add origin git@github.com:ABCD-crx/FruitDay.git<br>			//项目绑定github地址<br>			<br>git push -u origin master //推送到远程仓库<br><br>注：第一次推送可能会出现远程仓库和本地仓库不统一问题 导致推送失败<br>可将远程库拉取到本地解决该问题<br><br>git pull --rebase origin master<br>这条指令的意思是把远程库中的更新合并到本地库中，-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue——简单了解</title>
    <url>/2024/01/18/Java/vue/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="安装vue"><a href="#安装vue" class="headerlink" title="安装vue"></a>安装vue</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#安装nodejs  安装完毕后,用管理员启动<span class="hljs-built_in">cmd</span><br>#<span class="hljs-number">1</span>.检查<br>node -v<br>npm -v<br>#<span class="hljs-number">2</span>.创建两个目录：<br><span class="hljs-function">D:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_cache</span></span><br><span class="hljs-function"><span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_global</span></span><br><span class="hljs-function">#3.设置<span class="hljs-title">global</span> <span class="hljs-title">cache</span>路径</span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">config</span> <span class="hljs-title">set</span> <span class="hljs-title">prefix</span> &quot;<span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_global</span>&quot;</span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">config</span> <span class="hljs-title">set</span> <span class="hljs-title">cache</span> &quot;<span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_cache</span>&quot;</span><br><span class="hljs-function">#4.修改用户的环境变量</span><br><span class="hljs-function"><span class="hljs-title">Path</span>中-&gt;<span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_global</span></span><br><span class="hljs-function">#5.修改系统变量</span><br><span class="hljs-function">添加：<span class="hljs-title">NODE_PATH</span>  <span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_global</span>\<span class="hljs-title">node_modules</span></span><br><span class="hljs-function">添加：<span class="hljs-title">Path</span>  <span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span>\<span class="hljs-title">node_global</span></span><br><span class="hljs-function">           <span class="hljs-title">D</span>:\<span class="hljs-title">nodejs</span></span><br><span class="hljs-function">#6.测试安装</span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">install</span> <span class="hljs-title">express</span> -<span class="hljs-title">g</span></span><br><span class="hljs-function">#7.修改镜像</span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">config</span> <span class="hljs-title">get</span> <span class="hljs-title">registry</span></span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">config</span> <span class="hljs-title">set</span> <span class="hljs-title">registry</span> <span class="hljs-title">https</span>://<span class="hljs-title">registry.npm.taobao.org</span>/</span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">config</span> <span class="hljs-title">get</span> <span class="hljs-title">registry</span></span><br><span class="hljs-function"><span class="hljs-title">npm</span> <span class="hljs-title">install</span> -<span class="hljs-title">g</span> <span class="hljs-title">cnpm</span> --<span class="hljs-title">registry</span>=<span class="hljs-title">https</span>://<span class="hljs-title">registry.npm.taobao.org</span></span><br><span class="hljs-function">#8.安装<span class="hljs-title">vue</span></span><br><span class="hljs-function"><span class="hljs-title">cnpm</span> <span class="hljs-title">install</span> -<span class="hljs-title">g</span> @<span class="hljs-title">vue</span>/<span class="hljs-title">cli</span></span><br><span class="hljs-function">#9.启动</span><br><span class="hljs-function"><span class="hljs-title">vue</span> <span class="hljs-title">ui</span></span><br></code></pre></td></tr></table></figure>





<h3 id="vue文件夹组成"><a href="#vue文件夹组成" class="headerlink" title="vue文件夹组成"></a>vue文件夹组成</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">views 中写各种页面<br>router 是路由 是网址对应的路由<br>	url<br>	<br>components 中存各种组件<br><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span> 是整个的入口<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br>引入vuex（store）与 （router） 挂载到app元素下<br><br>app元素在index.<span class="hljs-property">html</span>中<br><br>vue会将所有js文件打包成一个js文件<br>在第一次打开完整向 服务器请求，发出全部页面的样式文件 前端渲染框架<br></code></pre></td></tr></table></figure>





<h3 id="vue文件组成"><a href="#vue文件组成" class="headerlink" title=".vue文件组成"></a>.vue文件组成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>	html部分<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>	js部分<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>	css部分<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure>

<p>每一个vue组件都会导出一个 对象</p>
<p>script部分</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">export default对象的属性：<br><br>    name：组件的名称<br>    <span class="hljs-built_in">components</span>：存储&lt;template&gt;中用到的所有组件<br>    <span class="hljs-built_in">props</span>：存储父组件传递给子组件的数据<br>    watch()：当某个数据发生变化时触发<br>    computed：动态计算某个数据<br>    setup(<span class="hljs-built_in">props</span>, <span class="hljs-built_in">context</span>)：初始化变量、函数<br>        ref定义变量，可以用.value属性重新赋值<br>        reactive定义对象，不可重新赋值<br>        <span class="hljs-built_in">props</span>存储父组件传递过来的数据<br>        <span class="hljs-built_in">context</span>.emit()：触发父组件绑定的函数<br></code></pre></td></tr></table></figure>

<p>template部分</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">&lt;slot&gt;&lt;/slot&gt;：存放父组件传过来的children。<br>v-<span class="hljs-keyword">on</span>:click或@click属性：绑定事件<br>v-<span class="hljs-keyword">if</span>、v-<span class="hljs-keyword">else</span>、v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>属性：判断<br>v-for属性：循环，:<span class="hljs-keyword">key</span>循环的每个元素需要有唯一的<span class="hljs-keyword">key</span><br>v-bind:或:：绑定属性<br></code></pre></td></tr></table></figure>

<p>style部分</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;style&gt;</span>标签添加scope属性后，不同组件间的css不会相互影响。<br>第三方组件<br>view-router包：实现路由功能。<br>vuex：存储全局状态，全局唯一。<br>    <span class="hljs-keyword">state</span>: 存储所有数据，可以用modules属性划分成若干模块<br>    getters：根据<span class="hljs-keyword">state</span>中的值计算新的值<br>    mutations：所有对<span class="hljs-keyword">state</span>的修改操作都需要定义在这里，不支持异步，可以通过<span class="hljs-variable">$store</span>.commit()触发<br>    actions：定义对<span class="hljs-keyword">state</span>的复杂修改操作，支持异步，可以通过<span class="hljs-variable">$store</span>.dispatch()触发。注意不能直接修改<span class="hljs-keyword">state</span>，只能通过mutations修改<span class="hljs-keyword">state</span>。<br>    modules：定义<span class="hljs-keyword">state</span>的子模块<br></code></pre></td></tr></table></figure>





<p>子页面要展示的内容都会在router-view标签内展示，</p>
<p>router-link标签是操控router-view中显示页面的路由，：to就是点击展示的意思</p>
<p><a href="https://juejin.cn/post/6906864262812024845">10分钟学会嵌套路由的使用（router-view） - 掘金 (juejin.cn)</a></p>
<h3 id="在不同组件中传递信息"><a href="#在不同组件中传递信息" class="headerlink" title="在不同组件中传递信息"></a>在不同组件中传递信息</h3><p><strong>子调用父组件信息</strong></p>
<ol>
<li>父组件：在子组件标签处绑定一个属性</li>
<li>子组件 定义 props接收属性</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 数据交互时将数据存到顶层组件 --&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    name : <span class="hljs-string">&#x27;UserProfile&#x27;</span>,<br>    <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-title class_">ContentBase</span>,<br>        <span class="hljs-title class_">UserProfileInfo</span>,<br>        <span class="hljs-title class_">UserProfilePost</span>,<br>    &#125;,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>(&#123;<br>            id : <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;crx&quot;</span>,<br>            <span class="hljs-attr">lastName</span>:<span class="hljs-string">&quot;Chen&quot;</span>,<br>            <span class="hljs-attr">followerCount</span>:<span class="hljs-number">0</span>,<br>            <span class="hljs-attr">is_followed</span>:<span class="hljs-literal">false</span>,<br>        &#125;);<br><br>        <span class="hljs-comment">// 需要使用的值都需要return出去 可在template中使用</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">user</span>:user,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">父到子 通过 <span class="hljs-built_in">props</span> 传递<br>子到父 通过 触发事件 传递<br></code></pre></td></tr></table></figure>

<h3 id="子到父"><a href="#子到父" class="headerlink" title="子到父"></a>子到父</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">user</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&#x27;&#x27;</span> + props.<span class="hljs-property">user</span>.<span class="hljs-property">firstName</span>);<br><br>    <span class="hljs-comment">// 定义一个事件处理函数在点击关注时更新状态</span><br>    <span class="hljs-comment">// 子组件向父组件传递信息 更改is_followed属性</span><br>    <span class="hljs-comment">// 需要触发父组件中 的绑定函数</span><br>    <span class="hljs-comment">//context.emit()：触发父组件绑定的函数</span><br>    <span class="hljs-comment">// context 需要从setup中传递过来</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">follow</span> = (<span class="hljs-params"></span>) =&gt;&#123;<br>        context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;follow&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">unfollow</span> = (<span class="hljs-params"></span>) =&gt;&#123;<br>        context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;unfollow&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">fullName</span>: fullName,<br>    follow,<br>    unfollow,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="computed：动态计算某个数据"><a href="#computed：动态计算某个数据" class="headerlink" title="computed：动态计算某个数据"></a>computed：动态计算某个数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;UserProfileInfo&#x27;</span>,<br>    <span class="hljs-comment">// 将需要接收的父组件数据放在 props中</span><br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">user</span>:&#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>            <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>,<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">user</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&#x27;&#x27;</span> + props.<span class="hljs-property">user</span>.<span class="hljs-property">firstName</span>);<br><br>        <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">fullName</span>: fullName<br>        &#125;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">@ 绑定函数 v-on<br>: 绑定属性 <span class="hljs-type">v</span>-bind<br></code></pre></td></tr></table></figure>





<h3 id="vue维护全局变量-可以跨父子传递变量"><a href="#vue维护全局变量-可以跨父子传递变量" class="headerlink" title="vue维护全局变量 可以跨父子传递变量"></a>vue维护全局变量 可以跨父子传递变量</h3><p>vuex 在全局维护一个树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ModulesUser</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-comment">// 存储所有数据</span><br>    <span class="hljs-attr">user</span>:&#123;<br>      <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">id</span>:<span class="hljs-string">&quot;&quot;</span>,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-comment">//不能直接获取数据 需要计算获得</span><br>    <span class="hljs-title function_">fullname</span>(<span class="hljs-params">state</span>)&#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">firstName</span> + state.<span class="hljs-property">user</span>.<span class="hljs-property">lastname</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// 对stats的所有修改操作</span><br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">//定义所有对state 的更新方式</span><br>    <span class="hljs-comment">// action 不能直接对state数据进行修改 修改操作放在mutations中</span><br>    <span class="hljs-comment">// action 存放修改的复杂操作 eg从云端获取 最后 修改stats在mutations</span><br>    <span class="hljs-title function_">updataUser</span>(<span class="hljs-params"></span>)&#123;<br>      <br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">modules</span>: &#123;<br>    <span class="hljs-comment">// 对stste进行分割</span><br>    <span class="hljs-attr">user</span>:<span class="hljs-title class_">ModulesUser</span><br>      <span class="hljs-comment">// ModulesUser 在一个新的js文件</span><br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>



<h3 id="传统登录方式验证-session-id"><a href="#传统登录方式验证-session-id" class="headerlink" title="传统登录方式验证 session_id"></a>传统登录方式验证 session_id</h3><p>session_id 存到cookie中 http js不能访问 所以跨域ajax不能访问 （跨域）</p>
<p>验证</p>
<p><img src="https://s2.loli.net/2024/02/24/HZLE347kYybwQTO.png" alt="image-20240124233033060"></p>
<p>缺点：不能跨域访问 </p>
<h3 id="JWT-json-web-token"><a href="#JWT-json-web-token" class="headerlink" title="JWT json web token"></a>JWT json web token</h3><p>jwt 不存到数据库</p>
<p>服务端 可以验证jwt是否合法</p>
<p><img src="https://s2.loli.net/2024/02/24/yGfKF17BXvumdLl.png" alt="image-20240124234153727"></p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2021/03/05/Linux/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="Linux重置密码"><a href="#Linux重置密码" class="headerlink" title="Linux重置密码"></a>Linux重置密码</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.重启虚拟机<br><span class="hljs-number">2</span>.按e 在linux16行尾 加上 rd.<span class="hljs-keyword">break</span> ,ctrl+x执行<br><span class="hljs-number">3</span>.mount -o remount,rw  /sysroot(重新挂载)（没有反馈）<br><span class="hljs-number">4</span>.chroot  /sysroot<br><span class="hljs-number">5</span>.passwd root<br><span class="hljs-number">6</span>.输入新密码（不显示）<br><span class="hljs-number">7</span>.确认密码<br><span class="hljs-number">8</span>.touch /.autorelabel<br><span class="hljs-number">9</span>.<span class="hljs-keyword">exit</span><br><span class="hljs-number">10</span>.<span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><p>命令提示符[root@localhost ~]#的含义：</p>
<p>[用户名@主机名 工作目录]，#代表root用户的提示符，$代表普通用户的提示符</p>
<p>切换用户：su - 用户名		完整切换</p>
<p>​					su  username  不完整切换</p>
<p>添加用户：useradd</p>
<p>设置密码 ：passwd  username </p>
<p>​		 注意：root可以给任何人设置密码，不需要原密码</p>
<p>​					普通用户只能给自己设置密码，不能指定‘</p>
<p>切换工作目录：cd（未指定，切换到当前登录用户家目录）</p>
<p>hostnamecat 设置主机相关信息：：hostname（重启后主机名消失 ）或者hostnamectl set-hostname 主机名 （重启后不消失）</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -l  <span class="hljs-string">/XXX</span><br><span class="hljs-keyword">ls</span>是要执行的命令 -l命令选项  <span class="hljs-string">/xxx</span> 参数<br>命令  选项  参数（选项和参数可以调换，但不是所有的都能换）<br>选项可以进行合并  -短选项 --长选项<br><br>	<span class="hljs-keyword">ls</span> -l        以长列表方式列出   ll = <span class="hljs-keyword">ls</span> -l <span class="hljs-params">--color=auto</span><br>	<span class="hljs-keyword">ls</span> -r        逆序列出<br>	<span class="hljs-keyword">ls</span> -d        查看当前目录．<br>	<span class="hljs-keyword">ls</span> -ld       长列表列出当前目录的详细信息<br>	<span class="hljs-keyword">ls</span> -lh 		 显示目录或文件大小  ll -h<br>	<span class="hljs-keyword">ls</span> -a        列出隐藏文件，包括.和<span class="hljs-string">..</span> <br>	<span class="hljs-keyword">ls</span> -A        列出隐藏文件，不包括.和<span class="hljs-string">..</span><br>	<span class="hljs-keyword">ls</span> -i		 显示文件索引节点号（inode）。<br>	一个索引节点代表一个文件，在linux中保存在磁盘分区中的文件都给它分配一个编号，称为索引节点号inode。<br><br></code></pre></td></tr></table></figure>

<h3 id="alisa"><a href="#alisa" class="headerlink" title="alisa"></a>alisa</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">alias</span> 查看或者添加命令别名，如果没有参数既是查看<br>	如果有参数，参数为命令别名=&#x27;对应的命令&#x27;<br>	<span class="hljs-keyword">alias</span>  haha=&#x27;<span class="hljs-keyword">ls</span>&#x27; 添加命令别名<br>	<span class="hljs-keyword">alias</span> 查看<br>	<span class="hljs-keyword">unalias</span> 取消当前会话内存中的命令别名<br>存在内存当中，重启后消失，重定向到<span class="hljs-string">.bashrc</span>即可永久保存<br>	<span class="hljs-keyword">echo</span> <span class="hljs-keyword">alias</span> haha=&#x27;<span class="hljs-keyword">ls</span>&#x27; &lt;&lt; <span class="hljs-string">.bashrc</span><br>      <br></code></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span> 查看或编译<span class="hljs-built_in">hash</span>表<br>	<span class="hljs-built_in">hash</span> 查看<span class="hljs-built_in">hash</span>表<br>	<span class="hljs-built_in">hash</span> -p /usr/bin/ls xixi<br>			/usr/bin/ls 是xixi命令执行的对象<br>	<span class="hljs-built_in">hash</span> -d xixi 表示删除xixi条目的<span class="hljs-built_in">hash</span>表<br>	<span class="hljs-built_in">hash</span> -t <span class="hljs-built_in">ls</span> 表示查看<span class="hljs-built_in">ls</span>条目的<span class="hljs-built_in">hash</span>表<br>	<span class="hljs-built_in">hash</span> -r  表示删除<span class="hljs-built_in">hash</span>表所有内容<br></code></pre></td></tr></table></figure>

<h3 id="linux文件类型"><a href="#linux文件类型" class="headerlink" title="linux文件类型"></a>linux文件类型</h3><p>——	ls -l   长列表 具体内容</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">drwxr-xr-<span class="hljs-keyword">x</span>. <span class="hljs-number">2</span> root root    <span class="hljs-number">6</span> Jul <span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span> Desktop<br><br>第一位：d<br>- 普通文件<br>d 目录文件 <br>l 符号链接，软连接，  快捷方式<br>s 套接字文件  Ip+port socket<br>p 管道文件    用于进程间的通信<br>b 块设备文件    随机存取数据的设备  eg.硬盘 固态 光盘<br><span class="hljs-keyword">c</span> 字符设备文件  顺序存取数据的设备 eg.键盘<br><br>rwxr-xr-<span class="hljs-keyword">x</span>.<br><br>rwx 第一组：表示该文件所有者对该文件拥有的权限<br>r-<span class="hljs-keyword">x</span> 第二组：表示该文件所属组的用户对该文件拥有的权限<br>r-<span class="hljs-keyword">x</span> 第三组：除了以上两种用户之外所有用户对该文件的权限<br>.   扩展权限：文件访问控制列表 ACL（可以针对某个文件设置该文件具体的用户权限）<br><br>r 对文件内容读取的权限<br>w 对文件内容修改的权限<br><span class="hljs-keyword">x</span> 对文件的执行权限<br><br><span class="hljs-number">2</span>  该文件的硬链接次数<br>ls -a 列出隐藏目录<br>. 当前目录 .. 当前文件的上一级文件<br>所以一个目录文件最少有两个硬链接方式<br>ls -i  显示文件索引节点号（inode）<br><br>root root <br>第一个：文件所属用户<br>第二个：文件所属组<br><br>   <span class="hljs-number">6</span> 该文件目录所占的大小<br><br>Jul <span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>时间戳<br></code></pre></td></tr></table></figure>

<h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">硬链接，只能引用同一文件系统中的文件。<br>它引用的是文件在文件系统中的物理索引（也称为inode）。当移动或者删除原始文件时，硬链接不会被破坏，因为它所引用的是文件的物理数据而不是文件在文件结构中的位置。硬链接记录的是目标的inode。<br></code></pre></td></tr></table></figure>

<h3 id="路径表现方式"><a href="#路径表现方式" class="headerlink" title="路径表现方式"></a>路径表现方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">绝对路径：以/开始的路径<br>相对路径：不是以/根开始的路径<br>回到当前目录的上一级目录： <span class="hljs-built_in">cd</span> ..<br>切换到当前用户的家目录目录：<span class="hljs-built_in">cd</span><br>切换到家目录： <span class="hljs-built_in">cd</span> ~<br>切换到上一次的目录： <span class="hljs-built_in">cd</span> -  保存在<span class="hljs-variable">$OLDPWD</span>这个变量中 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$OLDPWD</span>查看<br></code></pre></td></tr></table></figure>

<h3 id="变量继承"><a href="#变量继承" class="headerlink" title="变量继承"></a>变量继承</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">ssh 自动启用 bash<br>查看  ps -ef | grep bash<br><span class="hljs-attribute">varname</span>=zhangsan<br>echo <span class="hljs-variable">$varname</span> 查看<br>bash 在当前bash 再启用一个bash echo 查看不到<br><span class="hljs-built_in">export</span> varname 变量的继承<br>		——将变量升级为全局变量<br>此时再此bash上的所有子bash都会有此varname<br><br>所有内容都存在此会话的内存中，更改会话则无法查看<br>如果想要查看，需要写入相应变量中<br></code></pre></td></tr></table></figure>

<h3 id="Linux系统时间"><a href="#Linux系统时间" class="headerlink" title="Linux系统时间"></a>Linux系统时间</h3><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">date</span> 系统时间 软件时间<br><span class="hljs-built_in">clock</span> 产看更改硬件时间<br>hwclock 查看硬件时间 -w 系统时间给硬件时间 -s 硬件时间给系统时间<br>查看日历：cal<br>timedatex 查看系统时间<br></code></pre></td></tr></table></figure>

<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> <br>1.如果文件存在，更新文件的三个时间，<span class="hljs-built_in">stat</span>查看详细信息<br>	atime  查看文件的时间  <span class="hljs-built_in">cat</span>就会更改<br>	mtime  文件内容修改的时间<br>	ctime  文件原数据改变的时间（大小，名称，<br>2.如果文件不存在，<span class="hljs-built_in">touch</span>创建新文件<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件管理，权限管理，用户及用户组管理，存储管理</p>
<h3 id="文件层级系统"><a href="#文件层级系统" class="headerlink" title="文件层级系统"></a>文件层级系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">linux目录：<br>/		根目录<br>/bin	可执行文件<br>/sbin	可执行文件<br>/boot	开机启动文件，包括linux内核及开机菜单和开机配置文件<br>*/dev	设备文件，任何设备接口设备都是以文件形式存于这个目录<br>*/etc	配置文件<br>/home	普通用户的家目录<br>/root	root用户家目录<br>/lib	系统的函数库（32位）<br>/lib64	系统函数库（64位）<br>/media	媒体目录，也是挂载点目录<br>*/mnt	挂载点目录（光盘挂载，内容为光盘镜像，如果VM连接镜像		   会自动挂载，也可手动挂载 mount /dev/sr0 /mnt/ ）<br>/opt	可选目录，存放第三方软件包<br>/proc	该目录是一个虚拟文件系统，它放置的数据都在内存当中		（是linux内核在内存中所建立的系统内核映象），proc文件系统被用于从内存读取进程的信息。<br>/run	系统运行时所需的文件<br>/srv	service的缩写，一些网络服务启用后，这写服务所用的数据目录<br>/sys	虚拟文件系统，记录内核相关信息和/proc类似<br>/tmp	存储临时文件，让一般用户或者正在执行的程序暂时放置文件的地方<br>/usr	unix software resource放置的数据为可分享的与不可变动的，unix操作系统软件资源所放置的目录，而不是用户数据<br>/var	可变目录，用以存放经常变化的文件，如日志文件<br></code></pre></td></tr></table></figure>



<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>​		——文件管理	</p>
<p>1.创建删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span>  创建目录文件<br>-p 如果需要的话创建父目录<br>-v显示创建目录的详细过程<br>     tree xxx 查看目录的树状结构<br><span class="hljs-built_in">cp</span>  复制文件<br><span class="hljs-built_in">mv</span>  移动文件 <br><span class="hljs-built_in">rm</span>  删除文件（<span class="hljs-built_in">rm</span>是<span class="hljs-built_in">rm</span> -i的命令别名，用来提示文件是否确定）<br>		   （原<span class="hljs-built_in">rm</span>没有提示 \<span class="hljs-built_in">rm</span> 或者为 /usr/bin/rm 为原<span class="hljs-built_in">rm</span>）<br><span class="hljs-built_in">rm</span> -f 强制删除——删除普通文件<br><span class="hljs-built_in">rm</span> -r 删除目录文件<br><br>通配符 /1*  匹配到1*开头的所有任意长度文件<br><span class="hljs-built_in">rm</span> -rf /*  删根/没提示<br></code></pre></td></tr></table></figure>

<p>2.查看文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> 连接并显示文件内容到标准输出<br>	<span class="hljs-built_in">cat</span>只能看见第一页内容<br>	<span class="hljs-built_in">cat</span> -n 显示行号输出<br>more 查看所有内容（在没有翻到最后一屏时支持向前翻）<br>less （less反到最后一页也支持前翻）<br><span class="hljs-built_in">head</span>  默认查看文件前10行<br><span class="hljs-built_in">tail</span>  默认查看后10行<br><br><span class="hljs-built_in">tail</span> -f 跟踪文件内容（实时更新）ctrl+c 退出<br><br>查看第十行   <span class="hljs-built_in">head</span> -10 | <span class="hljs-built_in">tail</span> -1  xxxx<br></code></pre></td></tr></table></figure>

<p>3.文本处理</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cut</span>  文本切割<br><span class="hljs-attribute">cut</span> -d 指定分隔符 -f 指定第几列 被切割文件<br>		<span class="hljs-attribute">eg</span>. cut -d : -f <span class="hljs-number">1</span>,<span class="hljs-number">2</span>(<span class="hljs-number">1</span>和<span class="hljs-number">2</span>) <br>        				<span class="hljs-attribute">1</span>-<span class="hljs-number">2</span>(<span class="hljs-number">1</span>到<span class="hljs-number">2</span>)<br><br><span class="hljs-attribute">time</span> 命令检测命令所执行的时间<br></code></pre></td></tr></table></figure>

<p>4.文本统计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span>  显示顺序为 行-单词-字节-文件名<br><br><span class="hljs-built_in">wc</span> -l 只显示行数<br><span class="hljs-built_in">wc</span> -w 只显示单词数<br><span class="hljs-built_in">wc</span> -c 只显示字节数<br></code></pre></td></tr></table></figure>



<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vi</span> 增强版，没有<span class="hljs-keyword">vim</span>时可以使用<span class="hljs-keyword">vi</span><br><span class="hljs-keyword">vi</span>/<span class="hljs-keyword">vim</span> 不单是编译器，<br>三个模式：<br>	插入模式：可以写入内容<br>	命令模式：可以执行命令<br>	末行模式：可以执行命令<br>		:q  <span class="hljs-keyword">quit</span> 退出<span class="hljs-keyword">vim</span>编译器<br>		:<span class="hljs-keyword">w</span>  保存<br>			:<span class="hljs-keyword">w</span> filename 如果是打开并编辑文件，则是另存为<br>			:<span class="hljs-keyword">w</span> filename <br>			<br>	插入模式： iaso/IASO<br>		i 在光标前插入<br>		I在光标所在行第一个非空格符前插入<br>		<span class="hljs-keyword">a</span> 在光标后插入<br>		A 在光标所在行末尾插入<br>		s 删除光标所在位置字符并插入<br>		S 删除光标所在行并插入<br>		<span class="hljs-keyword">o</span> 在光标所在行下一行插入<br>		O 在光标所在行上一行插入<br>	<br>	命令模式：按esc可回到命令<br>		<span class="hljs-keyword">u</span> 撤销当前操作<br>		d 删除<br>			dd 删除当前行<br>			dgg 删除光标到文档首部<br>			dG 删除光标到尾部<br>			d^ 删除光标到行首，不包括光标所在位置<br>			d$ 删除光标到行尾，包括光标所在位置<br>			dw 按单词删除<br>		gg		跳转到文档尾部行首<br>		G		跳转到文档尾部<br>		ctrl+r  重做<br>		行号G    跳转到指定行<br>		<span class="hljs-keyword">x</span>		删除光标所在的位置的内容（右边)<br>		行数yy   复制光标所在行开始第几行<br>		<span class="hljs-keyword">p</span>		粘贴到光标所在行的下一行<br>		<span class="hljs-keyword">cc</span>		剪切当前行<br>		行数<span class="hljs-keyword">cc</span>   剪切当前行开始的几行<br>		H       跳转到当前屏幕输出的最上面一行<br>		L		跳转到当前屏幕输出的最下面一行<br>		M		跳转到当前屏幕输出的中间那一行<br>		<span class="hljs-keyword">w</span>		按单词进行移动光标<br>		r		替换光标所在的字符<br>		h		往左按字符移动光标<br>		<span class="hljs-keyword">j</span>		往下(后)按行移动光标<br>		<span class="hljs-keyword">k</span>		往上(前)按行移动光标<br>		<span class="hljs-keyword">l</span>		往右按字符移动光标<br>	<br>	末行模式<br>		：<span class="hljs-keyword">w</span>保存<br>		：<span class="hljs-keyword">w</span> filrname 另存为filrname<br>		：q 退出<br>		：<span class="hljs-keyword">wq</span> 保存退出<br>		：q！强制退出不保存<br>		：<span class="hljs-keyword">set</span> <span class="hljs-keyword">nu</span> 显示行号<br>		：<span class="hljs-keyword">set</span> nonu 取消显示行号<br>		：r /filename 读取指定文件内容到当前文件<br>		：行号 跳转到指定行<br>		：%s /被替换内容/替换内容(/g 表示为全局替换)<br>		：%s /删除内容//<br>		/ 查找字符串<br>		:<span class="hljs-keyword">noh</span> 取消高亮显示<br>		<br></code></pre></td></tr></table></figure>

<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">一、权限定义<br>dr-xr-x---.  文件类型+权限<br>文件：r—读 	 w—写 	x—执行<br>目录：r—列出  w—创建  x—进入<br><br><br>二、修改权限<br>	chmod  权限 对像<br>权限：	a 所有人	g所有组 o其他人 u所有者<br><br>	授权等式<br>		= 直接赋予<br>		+ 原有权限增加给定权限<br>		- 原有权限减去给定权限<br>	权限表现形式<br>		000<span class="hljs-number"> 0 </span> ---       <br>		001<span class="hljs-number"> 1 </span> --x <br>		010<span class="hljs-number"> 2 </span> -w- <br>		011<span class="hljs-number"> 3 </span> -wx     <br>		100<span class="hljs-number"> 4 </span> r--<br>		101<span class="hljs-number"> 5 </span> r-x           <br>		110<span class="hljs-number"> 6 </span> rw-            <br>		111<span class="hljs-number"> 7 </span> rwx<br>		...<br>eg. chmod a=rwx filrname 	g+x /o=- /u-w<br>	chmod u=rw-,g=r--,o=- filename<br><br>	rwxrwxrwx		777<br>	rw-rw-rw-		666<br>eg.chmod ugo=rw / chmod<span class="hljs-number"> 666 </span>filename<br></code></pre></td></tr></table></figure>

<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">三、权限掩码:控制创建文件的权限<br>	从<span class="hljs-number">777</span>权限上掩掉一部分，在新创建文件的时候<br>umask 查看权限掩码<br>umask +数字 <span class="hljs-number">0044</span> 修改权限掩码<br>		在创建目录文件时默认掩掉<span class="hljs-keyword">x</span> --<span class="hljs-keyword">x</span>--<span class="hljs-keyword">x</span>--<span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">四、修该权限所属者和所属组<br><span class="hljs-built_in">chmod</span> 修改权限<br><span class="hljs-built_in">chown</span> 修改所属主所属组<br><span class="hljs-built_in">chgrp</span> 修改所属组<br><br><span class="hljs-built_in">chown</span>  redhat:redaht haha/<br>修改文件的属主和属组：<br>	<span class="hljs-built_in">chown</span> 属主：属组 文件名    <br>	<span class="hljs-built_in">chown</span> 属主.属组 文件名<br><span class="hljs-built_in">chgrp</span> 属组 文件名<br><br></code></pre></td></tr></table></figure>

<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">五、访问控制列表ACL</span><br><span class="hljs-comment">	可以对某个文件设置该文件具体的某些用户的权限，意思就是通过ACL可以对一个文件权限做扩展，可以不同的用户对某个文件有不同的权限</span><br><span class="hljs-comment">dr</span><span class="hljs-literal">-</span><span class="hljs-comment">xr</span><span class="hljs-literal">-</span><span class="hljs-comment">x</span><span class="hljs-literal">---</span><span class="hljs-string">.</span><span class="hljs-comment">		dr</span><span class="hljs-literal">-</span><span class="hljs-comment">xr</span><span class="hljs-literal">-</span><span class="hljs-comment">x</span><span class="hljs-literal">---+</span><br><span class="hljs-comment">当最后的点变为</span><span class="hljs-literal">+</span><span class="hljs-comment">，表示有额外的访问控制列表</span><br><br><span class="hljs-comment">修改文件的acl：setfacl</span> <span class="hljs-literal">-</span><span class="hljs-comment">m  u:用户名:权限  文件名/目录名</span><br><span class="hljs-comment">			 setfacl</span> <span class="hljs-literal">-</span><span class="hljs-comment">m  g:组名:权限  文件名/目录名</span><br><span class="hljs-comment">getfacl 文件名  查看文件的访问控制列表</span><br><br></code></pre></td></tr></table></figure>

<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">SUID u+s   属主：让进程的所属者不再属于它的发起者，而是属于程序文件本身。<br>	eg.修改密码，是修改<span class="hljs-regexp">/etc/</span>shadow这个文件，权限为<span class="hljs-number">000</span><br>	所以除了root无法查看修改<br><br>SGID g+s   属组：当给一个目录定义了sgid的权限，则所有人在该目录下创建的文件都是该目录所属组，而不是创建者<br><br>sticky：o+t，当目录给定该权限后，该目录下的所有文件只能本人删除，别人不能删（只能删除自己创建的文件）<br><br>不能够删除其他用户在同目录里创建的文件，可删除自己创建的文件<br><br></code></pre></td></tr></table></figure>

<h3 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">chattr 设置文件隐藏权限权限<br>chattr +<span class="hljs-selector-tag">i</span> mima  无法删除文件（root也不能删，但是能改权限）<br>	chattr -<span class="hljs-selector-tag">i</span> mima<br>chattr +<span class="hljs-selector-tag">a</span> mima 文件内容只能被追加（无法修改删除之前内容）<br><br>lsattr 显示文件的隐藏权限<br>---<span class="hljs-attr">--a--------------</span> test/mima<br></code></pre></td></tr></table></figure>



<h2 id="用户及用户组管理"><a href="#用户及用户组管理" class="headerlink" title="用户及用户组管理"></a>用户及用户组管理</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">useradd 添加普通用户<br>添加用户并用选项指定参数：<br>		useradd -u	uid号<br>				-g	gid号/组名<br>				-G	附加组/组名<br>				-s	指定shell<br>				-d	指定家目录<br>		useradd	-c 备注 用户名 （备注为图形用户登录显示信息）<br>删除用户 userdel -r  <span class="hljs-regexp">//</span>-r删除文件的家目录<br><br>useradd -r	添加系统用户，不创建主目录和邮箱（系统用户一般不能用于登录）<br><br>创建用户未如果指明基本组，默认自动创建一个和这个账号一样的基本组<br>id	查看用户的uid，gid<br><br>passwd 	修改密码<br>userdel 	-r	删除用户的个人数据 家目录 邮箱<br>usermod 修改用户 <br>		 usermod -g 组名 用户名   ——修改基本组 <br>		 usermod -G 附加组名 用户名   ——修改附加组<br>	newgrp	附加组名 用户名 切换用户的组身份<br>	  如果一个用户不属于该附加组，切换时需要组密码（没密码也要，必须设置）<br>chsh 	修改用户shell<br><br>	一个用户属于一个基本组，可以属于多个附加组<br>组管理<br>	groupadd	添加一个组<br>		-g	GID<br>		-r	添加系统组<br>	groupdel	删除一个组<br>	groupmod	修改一个组<br>		-g	GID<br>		-n	GRPNAME	修改组名<br>	gpasswd		修改/设置组密码<br>	newgrp		登录一个新组	使用<span class="hljs-keyword">exit</span>退出<br><br></code></pre></td></tr></table></figure>

<h3 id="用户文件"><a href="#用户文件" class="headerlink" title="用户文件"></a>用户文件</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/etc/passwd<br>冒号隔开<span class="hljs-number">7</span>个字段<br><span class="hljs-symbol">setroubleshoot:</span><span class="hljs-symbol">x:</span><span class="hljs-number">992</span><span class="hljs-symbol">:</span><span class="hljs-number">985</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/var/lib/setroubleshoot</span><span class="hljs-symbol">:/sbin/nologin</span><br>用户名<span class="hljs-symbol">:</span>密码占位符<span class="hljs-symbol">:uid</span><span class="hljs-symbol">:</span>组<span class="hljs-symbol">id:</span>用户的描述<span class="hljs-symbol">:</span>用户的家目录<span class="hljs-symbol">:</span>用户的shell<br><br><br>密码文件：<br>/etc/shadow <br>冒号隔开<span class="hljs-number">9</span>个字段<br><span class="hljs-symbol">root:</span>$<span class="hljs-number">6</span><span class="hljs-variable">$gHa</span>5eaZGFeAEURTx<span class="hljs-variable">$jarp1G384p</span>/<span class="hljs-title class_">RFTz7C7tG9</span>.nQRXgRnxW2MGvKIp/xPGf11daVdOtSC6rnDojJ82u3LFVVqZXBOL3Jv7uCriJRQ/<span class="hljs-symbol">:</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">99999</span><span class="hljs-symbol">:</span><span class="hljs-number">7</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:</span>:<br><br>用户名：<br>密码（哈希过后）：<br>	密码：<span class="hljs-variable">$分</span>隔为三部分<br>		<span class="hljs-variable">$6</span>					加密算法<br>		<span class="hljs-variable">$gHa5eaZGFeAEURTx</span>	salt<br>		<span class="hljs-variable">$	</span>				加密密码<br>最近一次修改密码：从<span class="hljs-number">1970</span>年<span class="hljs-number">1</span>月<span class="hljs-number">1</span>日到最后一-次密码改变的时间所经过的天数<br>密码最短使用期限：为<span class="hljs-number">0</span>表示不限制<br>密码最长使用期限：密码使用多长时间之后必须要改密码，<span class="hljs-number">99999</span>表 示(s.<span class="hljs-number">2</span>下更<br>密码过期警告时间：密码过期前多少天进行警告，提示用户改密码，但是不锁定用户<br>账号过期精确时间：如果为<span class="hljs-number">99999</span>，意味着永不过期<br>保留字段<br><br>/etc/group<br>文件格式为：<br>	组名：组密码：<span class="hljs-variable constant_">GID</span>：以该组作为额外组的用户名，以逗号为分隔符<br>	<br>/etc/gshadow<br></code></pre></td></tr></table></figure>

<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>存储管理<br>        标准分区<br>                开机流程</p>
<p>​		LVM</p>
<h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">计算机分为：主板、硬盘、显示器、内存、总线、电源<br>	总线：地址总线、数据总线、控制总线<br>	 	 设备总线<br><br>BIOS basic input/output<span class="hljs-keyword"> system</span>  基本的输入输出系统 ——固件（软件）<br>		<span class="hljs-built_in">	check</span><br><span class="hljs-built_in"></span>			启动时，通过设备总线发送信号，确保设备正常运行<br>			表	中断	编号<br>			操作系统<br>				网络启动	有线<br>				硬盘启动<br>				光盘<br>				U盘<br>				默认启动顺序：boot<br>	BIOS开机时自启动完成 POST 自举<br><br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">磁盘启动<br>磁盘的第一个扇区：mbr扇区共512个字节<br>mbr + 分区表 + mbr结束标记（55AA）<br>mbr 446个字节	引导系统（硬盘快捷方式）<br>每一个分区 16个字节 最大4个分区<br><br></code></pre></td></tr></table></figure>

<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">init<span class="hljs-number"> 0 </span>——关机<br>	<span class="hljs-number"> 1 </span>——单用户<br>	<span class="hljs-number"> 3 </span>——命令行<br>	<span class="hljs-number"> 5 </span>——带图形界面<br>	<span class="hljs-number"> 6 </span>——重启<br></code></pre></td></tr></table></figure>

<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">linux里面硬盘根据硬盘接口的不同来命名：<br>		IDE           		  <span class="hljs-built_in">hd</span>(a-d)<br>		SATA/SCSI/USB         <span class="hljs-built_in">sd</span>(a-z) <br>		<br>一块磁盘默认可被分为四个分区，这四个分区分别为主分区或者扩展分区，在扩展分区上可创建逻辑分区。<br>	主分区：可以格式化 ，挂载，ll<br>	扩展分区：不能被格式化，可以 创建逻辑分区（突破分区表只能存在<span class="hljs-number">4</span>个分区）<br>             扩展分区有且仅有一个<br><br>磁盘不能直接使用，需要划分片区，建立文件系统<br>fdisk -l 查看分区列表<br>fdisk /dev/sda对某一块磁盘进行分区<br>进入fdisk交互界面：n   添加新分区<br>						<span class="hljs-selector-tag">p</span> primary 主分区<br>						e extended 扩展分区<br>				 <span class="hljs-selector-tag">p</span>   列出分区<br>格式化磁盘分区，创建文件系统<br>mkfs<span class="hljs-selector-class">.xfs</span> /dev/nvme0n2p1<br><br>挂载：把一个目录和文件系统产生关系的过程称为挂载<br>	临时挂载：mount 分区文件名 挂载点目录<br>			mount 查看所有挂载的信息      <br>			umount 取消挂载  +磁盘名或者目录名<br>	查看挂载磁盘信息: df <span class="hljs-built_in">-h</span>(以人类可读的方式)<br>磁盘不能直接使用，需要划分片区，建立文件系统<br><br>永久挂载：<br>手动挂载重启后消失，如果想要永久挂载需要将挂载信息写入/etc/fstab<br>vim /etc/fstab<br><span class="hljs-number">6</span>个字段用 空白符 隔开<br>挂载原设备/UUID	挂载点		文件系统	挂载选项	<span class="hljs-number">0</span>  <span class="hljs-number">0</span> <br>	通过blkid命令查看分区的uuid<br>UUID  通用唯一识别码 <br>一般不会发生变化，推荐使用此设备信息挂载<br></code></pre></td></tr></table></figure>



<h3 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h3><p>​		——逻辑卷管理</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">PV：物理卷<br>VG：卷组，建立在物理卷上<br>LV：逻辑卷，建立在卷组基础上<br><br>创建：<br><span class="hljs-number">1</span>.创建PV<br>	pvcreate <span class="hljs-regexp">/dev/</span>nvme0n2<br>	pvcrerte <span class="hljs-regexp">/dev/</span>sda<br>  查看PV<br>  	pvs ——pv简略信息<br>  	pvdisplay ——物理卷的属性<br>	pvremove：将物理卷信息删除，使其不再被视为一个物理卷<br><span class="hljs-number">2</span>.创建VG<br>	vgcreate vg名 <span class="hljs-regexp">/dev/</span>nvme0n2<br>	vgremove：删除卷组，其上的逻辑卷必须处于离线状态<br>	vgextend：动态扩展LVM卷组，它通过向卷组中添加物理卷来增加卷组的容量<br><span class="hljs-number">3</span>.创建LV<br>	lvcreate -n lv1 -L <span class="hljs-number">5</span>G vg1<br>	选项：<br>      -L：指定大小<br>      -l：指定大小（LE数）<br>      -n：指定名称<br>      -s：创建快照<br>      -p r：设置为只读（该选项一般用于创建快照中）<br><br>查看在 <span class="hljs-regexp">/dev/</span>vgname/lvname <br>	  <span class="hljs-regexp">/dev/m</span>apper<span class="hljs-regexp">/vgname-lvname 这两个是两个软连接指向/</span>dev/dm-x<br></code></pre></td></tr></table></figure>

<h3 id="LVM扩大和缩小"><a href="#LVM扩大和缩小" class="headerlink" title="LVM扩大和缩小"></a>LVM扩大和缩小</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">XFS</span> 扩大<br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># ll /dev/vg1/lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># lvextend -L 10G /dev/vg1/lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># df -h</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># blkid</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># xfs_growfs /dev/vg1/lv1   RHLE8.0仅支持 xfs_growfs /data</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># df -h</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># ll /xixi/</span><br><br>EXT4 扩大<br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># umount /xixi/</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># mkfs.ext4 /dev/mapper/vg1-lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># mount /dev/mapper/vg1-lv1 /xixi</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># df -h</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># blkid</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># vgs</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># lvs</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># lvextend -L 15G /dev/vg1/lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># lvs</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># resize2fs /dev/mapper/vg1-lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># df -h</span><br><br>EXT4 缩小<br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># umount /xixi</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># resize2fs /dev/mapper/vg1-lv1 8G</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># e2fsck -f /dev/mapper/vg1-lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># resize2fs /dev/mapper/vg1-lv1 8G</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># df -h</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># lvreduce -L 8G /dev/vg1/lv1</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># mount /dev/mapper/vg1-lv1 /xixi</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># df -h</span><br>[root<span class="hljs-variable">@rhel7</span> ~]<span class="hljs-comment"># lvs</span><br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">dd 命令<br>可以拷贝磁盘或者文件 /指定大小<br>dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/dev/nvme0n1 <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1<br>dd <span class="hljs-attribute">if</span>=/dev/nvme0n1 <span class="hljs-attribute">of</span>=/dev/nvme0n2 (拷贝-镜像)<br></code></pre></td></tr></table></figure>

<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/dev/</span>sr0 光驱 <br>软件包 <br>.rpm  redhat <span class="hljs-keyword">package</span> manager<br><br>rpm 命令可以安装rpm格式的安装包<br><br>rpm -ivh	i安装v详细信息h安装时列出标记<br>	-ql  q表示查询 l列表<br>	-qf  查询文件是由那个软件产生的<br>	查询所有安装的软件包rpm -qa | <span class="hljs-keyword">grep</span> tree<br>rpm -e tree（包名） 删除软件<br><br>Baseos 系统相关<br>AppStream 上下游提供的（第三方软件包）<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">yum  Yellow dog Updater，Modified黄狗管理器<br>软件包管理器。基于RPM包管理，一次性安装所有依赖的软件包<br>/etc/yum.repos.d/base.repo<br>yum.repos.d目录下只认识.repo结尾的配置文件<br>vim /<br>[源标识]   ——（仓库标识）<br><span class="hljs-attribute">name</span>=源名称  ——（仓库名称）<br><span class="hljs-attribute">baseurl</span>=/mnt/BaseOS/  支持http/ftp<br><span class="hljs-attribute">enable</span>=1<br><span class="hljs-attribute">gpgcheck</span>=0<br>gpgcheck的两种情况：指定是否需要查阅rpm文件内的数字签名，1为检查，0为不检查<br>如果检查还需加上<br>	<span class="hljs-attribute">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release <br><br>安装软件：yum install<br>删除软件：yum <span class="hljs-built_in">remove</span><br><br>dnf 和 yum 没有区别<br>/usr/bin/dnf 与 /usr/bin/yum 软连接都指向 -&gt; dnf-3<br></code></pre></td></tr></table></figure>

<h3 id="在线yum源仓库配置"><a href="#在线yum源仓库配置" class="headerlink" title="在线yum源仓库配置"></a>在线yum源仓库配置</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">网络yum源具有比镜像yum更新更全的软件包<br>而且安装非常简单，在有网络的环境下建议使用<br><br>以下为阿里云yum<br><span class="hljs-number">1</span>.将在线yum源配置文件下载到本地<br>	wget -O /etc/yum<span class="hljs-selector-class">.repos</span>.d/CentOS-Base<span class="hljs-selector-class">.repo</span> https:<span class="hljs-comment">//mirrors.aliyun.com/repo/Centos-7.repo</span><br><br>yum clean <span class="hljs-attribute">all</span><br>yum makecache<br></code></pre></td></tr></table></figure>



<h3 id="httpd"><a href="#httpd" class="headerlink" title="httpd"></a>httpd</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">控制服务：<br>systemctl<br>	<span class="hljs-keyword">enable</span> 开机启动这个服务<br>	<span class="hljs-keyword">disable</span> 取消开机启动<br>	<span class="hljs-keyword">is</span>-<span class="hljs-keyword">enable</span> 查看这个服务是否开机启动<br>	<span class="hljs-keyword">start</span> 启动该服务<br>	<span class="hljs-keyword">is</span>-active 查看该服务是否已经启动<br>	stop 停止该服务<br>	status 查看该服务状态<br>	mask 标记该服务（禁用该服务）<br>	unmask 取消禁用<br>	<span class="hljs-keyword">restart</span> 重启该服务<br>	reload 重新加载该服务<br><br>vim /etc/httpd/conf/httpd.conf<br>	修改<span class="hljs-number">99</span>行 ServerName <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">80</span><br>systemctl <span class="hljs-keyword">start</span> httpd	启动服务<br>systemctl status httpd	查看服务启动情况<br>netstat -lntup | grep httpd 查看服务的端口号<br>systemctl status firewalld 查看防火墙<br>firewall-cmd <span class="hljs-comment">--permanent --add-service=http</span><br>查看防火墙放行情况<br>firewall-cmd <span class="hljs-comment">--reload 重载</span><br><br>echo welcome <span class="hljs-keyword">to</span> shiyoudaxue &gt; /var/www/html/<span class="hljs-keyword">index</span>.html<br><br> /var/www/html/ 默认网站内容所在地<br> <br>systemctl stop firewalld 关闭防火墙<br>systemctl <span class="hljs-keyword">disable</span> firewalld 组织防火墙开机启动<br><br>discuz<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux总结</title>
    <url>/2021/08/04/Linux/Linux%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">1. 常用命令介绍<br>    (1) ctrl c: 取消命令，并且换行<br>    (2) ctrl u: 清空本行命令<br>    (3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项<br>    (4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br>    (5) pwd: 显示当前路径<br>    (6) cd XXX: 进入XXX目录下, cd .. 返回上层目录<br>    (7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt<br>    (8) mkdir XXX: 创建目录XXX<br>    		-p 如果需要的话创建父目录<br>			-v显示创建目录的详细过程<br>    (9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹<br>    (10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令<br>    (11) touch XXX: 创建一个文件<br>    (12) cat XXX: 展示文件XXX中的内容<br>    (13) 复制文本<br>        windows/Linux下：Ctrl + insert，Mac下：command + c<br>    (14) 粘贴文本<br>        windows/Linux下：Shift + insert，Mac下：command + v<br></code></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">权限这一块，<span class="hljs-built_in">ls</span> <span class="hljs-literal">-l</span><br>第一个符号代表文件类型，d是文件夹，l是连接文件，-是普通文件，<br>后面的是权限，<span class="hljs-built_in">r</span>是读取，w是写入，x是执行，<br><span class="hljs-number">3</span>个为<span class="hljs-number">1</span>段，第一段代表的是建立这个文件的用户权限，<br>第二段为建立这个文件的用户所属组的权限，<br>第三段为其他用户的权限，哪像为空，则没有这个权限.<br></code></pre></td></tr></table></figure>

<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>​    (1) 分屏。<br>​    (2) 允许断开Terminal连接后，继续运行进程。</p>
<p>结构</p>
<p> 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</p>
<p>实例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">tmux:<br>	session <span class="hljs-number">0</span>:<br>		<span class="hljs-built_in">window</span> <span class="hljs-number">0</span>:<br>			pane <span class="hljs-number">0</span><br>			pane <span class="hljs-number">1</span><br>			pane <span class="hljs-number">2</span><br>			...<br>		<span class="hljs-built_in">window</span> <span class="hljs-number">1</span><br>		<span class="hljs-built_in">window</span> <span class="hljs-number">2</span><br>		...<br>	session <span class="hljs-number">1</span><br>	session <span class="hljs-number">2</span><br>	...<br></code></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">(1) tmux：新建一个session，其中包含一个<span class="hljs-keyword">window</span>，<span class="hljs-keyword">window</span>中包含一个pane，pane里打开了一个<span class="hljs-keyword">shell</span>对话框。<br>	<span class="hljs-string">&quot;注默认为 ctrl + b&quot;</span><br>(2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。<br>(3) 按下Ctrl + a后手指松开，然后按&quot;：将当前pane上下平分成两个pane。<br>(4) Ctrl + <span class="hljs-keyword">d</span>：关闭当前pane；如果当前<span class="hljs-keyword">window</span>的所有pane均已关闭，则自动关闭<span class="hljs-keyword">window</span>；如果当前session的所有<span class="hljs-keyword">window</span>均已关闭，则自动关闭session。<br>(5) 鼠标点击可以选pane。<br>(6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>(7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>(8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>(9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>(10) 按下ctrl + a后手指松开，然后按<span class="hljs-keyword">d</span>：挂起当前session。<br>(11) tmux a：打开之前挂起的session。<br>(12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>        方向键 —— 上：选择上一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 下：选择下一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 右：展开当前项 session/<span class="hljs-keyword">window</span><br>        方向键 —— 左：闭合当前项 session/<span class="hljs-keyword">window</span><br>(13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的<span class="hljs-keyword">window</span>。<br>(14) 按下Ctrl + a后手指松开，然后按w：选择其他<span class="hljs-keyword">window</span>，操作方法与(12)完全相同。<br>(15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br>(16) 鼠标滚轮：翻阅当前pane内的内容。<br>(17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持<span class="hljs-keyword">Mac</span>，不过该操作并不是必须的，因此影响不大）<br>(18) tmux中复制/粘贴文本的通用方式：<br>        (1) 按下Ctrl + a后松开手指，然后按[<br>        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">tmux 创建一个tmux session进程<br>tmux attach 打开挂起的session进程<br>（ctrl + <span class="hljs-keyword">a</span>） +  d  挂起<br>ctrl d 关闭窗口 有 pane -&gt; windows -&gt; session<br>(ctrl + <span class="hljs-keyword">a</span>) + z  全屏/取消全屏pane<br><br>选中 <br>shift + 光标<br>	ctrl + ins键——复制<br>	shift + ins 粘贴<br><br>复制粘贴<br>(ctrl + <span class="hljs-keyword">a</span>) + [ 复制<br>(ctrl + <span class="hljs-keyword">a</span>) + ] 粘贴<br></code></pre></td></tr></table></figure>



<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>功能：</p>
<p>​    (1) 命令行模式下的文本编辑器。<br>​    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br>​    (3) 使用方式：vim filename<br>​        如果已有该文件，则打开它。<br>​        如果没有该文件，则打开个一个新的文件，并命名为filename</p>
<p>模式：</p>
<pre><code class="hljs">(1) 一般命令模式
    默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。
(2) 编辑模式
    在一般命令模式里按下i，会进入编辑模式。
按下ESC会退出编辑模式，返回到一般命令模式。
(3) 命令行模式
    在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。
    可以查找、替换、保存、退出、配置编辑器等。
</code></pre>
<h2 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h2><p>​	一般命令模式</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) <span class="hljs-selector-tag">i</span>：进入编辑模式<br>(<span class="hljs-number">2</span>) ESC：进入一般命令模式<br>(<span class="hljs-number">3</span>) h 或 左箭头键：光标向左移动一个字符<br>(<span class="hljs-number">4</span>) j 或 向下箭头：光标向下移动一个字符<br>(<span class="hljs-number">5</span>) k 或 向上箭头：光标向上移动一个字符<br>(<span class="hljs-number">6</span>) l 或 向右箭头：光标向右移动一个字符<br>(<span class="hljs-number">7</span>) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br>(<span class="hljs-number">8</span>) <span class="hljs-number">0</span> 或 功能键<span class="hljs-selector-attr">[Home]</span>：光标移动到本行开头<br>(<span class="hljs-number">9</span>) $ 或 功能键<span class="hljs-selector-attr">[End]</span>：光标移动到本行末尾<br>(<span class="hljs-number">10</span>) G：光标移动到最后一行<br>(<span class="hljs-number">11</span>) :n 或 nG：n为数字，光标移动到第n行<br>(<span class="hljs-number">12</span>) gg：光标移动到第一行，相当于<span class="hljs-number">1</span>G<br>(<span class="hljs-number">13</span>) n&lt;Enter&gt;：n为数字，光标向下移动n行<br>(<span class="hljs-number">14</span>) /word：向光标之下寻找第一个值为word的字符串。<br>(<span class="hljs-number">15</span>) ?word：向光标之上寻找第一个值为word的字符串。<br>(<span class="hljs-number">16</span>) n：重复前一个查找操作<br>(<span class="hljs-number">17</span>) N：反向重复前一个查找操作<br>(<span class="hljs-number">18</span>) :n1,n2s/word1/	word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>(<span class="hljs-number">19</span>) :<span class="hljs-number">1</span>,<span class="hljs-variable">$s</span>/word1/word2/g：将全文的word1替换为word2<br>(<span class="hljs-number">20</span>) :<span class="hljs-number">1</span>,<span class="hljs-variable">$s</span>/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。<br>(<span class="hljs-number">21</span>) v：选中文本<br>(<span class="hljs-number">22</span>) d：删除选中的文本<br>(<span class="hljs-number">23</span>) dd: 删除当前行<br>(<span class="hljs-number">24</span>) y：复制选中的文本<br>(<span class="hljs-number">25</span>) yy: 复制当前行<br>(<span class="hljs-number">26</span>) p: 将复制的数据在光标的下一行/下一个位置粘贴<br>(<span class="hljs-number">27</span>) u：撤销<br>(<span class="hljs-number">28</span>) Ctrl + r：取消撤销<br>(<span class="hljs-number">29</span>) 大于号 &gt;：将选中的文本整体向右缩进一次<br>(<span class="hljs-number">30</span>) 小于号 &lt;：将选中的文本整体向左缩进一次<br></code></pre></td></tr></table></figure>

<p>编辑模式</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">(<span class="hljs-number">31</span>) <span class="hljs-symbol">:w</span> 保存<br>(<span class="hljs-number">32</span>) <span class="hljs-symbol">:w!</span> 强制保存<br>(<span class="hljs-number">33</span>) <span class="hljs-symbol">:q</span> 退出<br>(<span class="hljs-number">34</span>) <span class="hljs-symbol">:q!</span> 强制退出<br>(<span class="hljs-number">35</span>) <span class="hljs-symbol">:wq</span> 保存并退出<br>(<span class="hljs-number">36</span>) <span class="hljs-symbol">:set</span> paste 设置成粘贴模式，取消代码自动缩进<br>(<span class="hljs-number">37</span>) <span class="hljs-symbol">:set</span> nopaste 取消粘贴模式，开启代码自动缩进<br>(<span class="hljs-number">38</span>) <span class="hljs-symbol">:set</span> nu 显示行号<br>(<span class="hljs-number">39</span>) <span class="hljs-symbol">:set</span> nonu 隐藏行号<br>(<span class="hljs-number">40</span>) gg=G：将全文代码格式化<br>(<span class="hljs-number">41</span>) <span class="hljs-symbol">:noh</span> 关闭查找关键词高亮<br>(<span class="hljs-number">42</span>) <span class="hljs-title class_">Ctrl</span> + q：当vim卡死时，可以取消当前正在执行的命令<br></code></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">异常处理：<br>    每次用vim编辑文件时，会自动创建一个.filename.<span class="hljs-keyword">swp的临时文件。</span><br><span class="hljs-keyword"></span>    如果打开某个文件时，该文件的<span class="hljs-keyword">swp文件已存在，则会报错。此时解决办法有两种：</span><br><span class="hljs-keyword"></span>        (<span class="hljs-number">1</span>) 找到正在打开该文件的程序，并退出<br>        (<span class="hljs-number">2</span>) 直接删掉该<span class="hljs-keyword">swp文件即可</span><br></code></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"> 定位到最后一行 G<br> 定位到第一行 gg<br> 定位到任意n行  :n 或 nG<br> <br> 查找xx  /xx  n查找下一个<br> <br> 替换字符串<br> :n1,n2s/word1/word2/g：<br> 	n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>:1,<span class="hljs-variable">$s</span>/n1/N1/g 全局替换 gc 为询问用户<br><br>qing<br></code></pre></td></tr></table></figure>



<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="ssh-1"><a href="#ssh-1" class="headerlink" title="ssh"></a>ssh</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p>远程登录服务器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">ssh user<span class="hljs-keyword">@hostname</span><br><span class="hljs-attribute">user</span>: 用户名<br><span class="hljs-attribute">hostname</span>: IP地址或域名<br></code></pre></td></tr></table></figure>

<p>第一次登录时会提示：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">&#x27;123.57.47.211 (123.57.47.211)&#x27; can&#x27;t be established.</span><br>ECDSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-built_in">is</span> SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no/[fingerprint])?<br></code></pre></td></tr></table></figure>

<p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在**~&#x2F;.ssh&#x2F;known_hosts**文件中。</p>
<p>然后输入密码即可登录到远程服务器中。</p>
<p>默认登录端口号为22。如果想登录某一特定端口：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> user<span class="hljs-variable">@hostname</span> -p <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建文件 <strong>~&#x2F;.ssh&#x2F;config。</strong></p>
<p>然后在文件中输入：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">Host myserver1<br>    HostName IP地址或域名<br>    <span class="hljs-keyword">User</span> <span class="hljs-title">用户名</span><br><span class="hljs-title"></span><br><span class="hljs-title">Host</span> myserver2<br>    HostName IP地址或域名<br>    <span class="hljs-keyword">User</span> <span class="hljs-title">用户名</span><br></code></pre></td></tr></table></figure>

<p>之后再使用服务器时，可以直接使用别名myserver1、myserver2。</p>
<h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p>创建密钥：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen</span><br></code></pre></td></tr></table></figure>

<p>然后一直回车即可。</p>
<p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p>
<ul>
<li><p>id_rsa：私钥</p>
</li>
<li><p>id_rsa.pub：公钥</p>
</li>
</ul>
<p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p>
<p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p>
<p>也可以使用如下命令一键添加公钥：</p>
<p><strong>ssh-copy-id myserver</strong></p>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>注：是使用服务器执行命令 再将标准输出返回到当前终端</p>
<p>命令格式：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> user<span class="hljs-variable">@hostname</span> command<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel">ssh user@hostname <span class="hljs-keyword">ls</span> -a<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#单引号中的$i可以求值</span><br><span class="hljs-attribute">ssh</span> myserver <span class="hljs-string">&#x27;for ((i = 0; i &lt; 10; i ++ )) do echo <span class="hljs-variable">$i</span>; done&#x27;</span><br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#双引号中的$i不可以求值</span><br><span class="hljs-attribute">ssh</span> myserver <span class="hljs-string">&quot;for ((i = 0; i &lt; 10; i ++ )) do echo <span class="hljs-variable">$i</span>; done&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scp <span class="hljs-built_in">source</span> destination<br></code></pre></td></tr></table></figure>

<p>将source路径下的文件复制到destination中</p>
<p>一次复制多个文件：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scp </span>source1 source2 destination<br></code></pre></td></tr></table></figure>

<p>复制文件夹：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">scp -r ~<span class="hljs-regexp">/tmp myserver:/</span>home<span class="hljs-regexp">/acs/</span><br></code></pre></td></tr></table></figure>

<p>将本地家目录中的tmp文件夹复制到myserver服务器中的&#x2F;home&#x2F;acs&#x2F;目录下。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">scp -r <span class="hljs-symbol">~/tmp myserver</span>:homework/<br></code></pre></td></tr></table></figure>

<p>将本地家目录中的tmp文件夹复制到myserver服务器中的~&#x2F;homework&#x2F;目录下。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">scp -r myserver:homework .<br></code></pre></td></tr></table></figure>

<p>将myserver服务器中的~&#x2F;homework&#x2F;文件夹复制到本地的当前路径下。</p>
<p>指定服务器的端口号：</p>
<p>scp -P 22 source1 source2 destination<br>注意： scp的-r -P等参数尽量加在source和destination之前。</p>
<p><strong>使用scp配置其他服务器的vim和tmux</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">scp ~/.vimrc ~/.tmux.conf myserver:<br></code></pre></td></tr></table></figure>

<p>使tmux配置文件生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tmux source ~/.tmux.conf<br></code></pre></td></tr></table></figure>



<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git init 将当前目录配置成git仓库<br> <br>git add 文件名 	将文件添加到缓存区<br>	git add .：将所有待加入暂存区的文件加入暂存区<br>	<br>git commit -m &quot;给自己看的备注信息&quot;：将暂存区的内容提交到当前分支<br><br>git status：查看仓库状态<br><br>git diff XX：查看XX文件相对于暂存区修改了哪些内容<br><br>git log：查看当前分支的所有版本<br><br>git reflog：查看HEAD指针的移动历史（包括被回滚的版本）<br><br>git reset --hard HEAD^ 或 git reset --hard HEAD~：将代码库回滚到上一个版本<br>    git reset --hard HEAD^^：往上回滚两次，以此类推<br>    git reset --hard HEAD~100：往上回滚100个版本<br>    git reset --hard 版本号：回滚到某一特定版本<br>    <br>git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销<br></code></pre></td></tr></table></figure>



<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">bu</span><br><span class="hljs-keyword"></span><br>git rebase  分支合并 把其他分支和并到主分支上<br><br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>csa</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2024/02/05/Linux/docker/</url>
    <content><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://docs.docker.com/engine/install/ubuntu/">Docker 官方文档 </a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><strong>将当前用户添加到docker用户组</strong><br>为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo usermod -aG docker $USER<br></code></pre></td></tr></table></figure>

<p>执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">newgrp docker		更新用户组<br></code></pre></td></tr></table></figure>



<h2 id="镜像-images"><a href="#镜像-images" class="headerlink" title="镜像(images)"></a>镜像(images)</h2><ol>
<li><code>docker pull ubuntu:20.04：</code>拉取一个镜像</li>
<li><code>docker images：</code>列出本地所有镜像</li>
<li><code>docker image rm ubuntu:20.04 </code>或<code> docker rmi ubuntu:20.04</code>：删除镜像ubuntu:20.04</li>
<li><code>docker [container] commit CONTAINER IMAGE_NAME:TAG：</code>创建某个container的镜像</li>
<li><code>docker save -o ubuntu_20_04.tar ubuntu:20.04：</code>将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中</li>
<li><code>docker load -i ubuntu_20_04.tar：</code>将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来</li>
</ol>
<h2 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。<br>docker ps -a：查看本地的所有容器<br>docker [container] start CONTAINER：启动容器<br>docker [container] stop CONTAINER：停止容器<br>docker [container] restart CONTAINER：重启容器<br>docker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器<br>docker [container] attach CONTAINER：进入容器<br>先按Ctrl-p，再按Ctrl-q可以挂起容器<br>docker [container] exec CONTAINER COMMAND：在容器中执行命令<br>docker [container] rm CONTAINER：删除容器<br>docker container prune：删除所有已停止的容器<br><br><br><br>docker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中<br>docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag<br>docker export/import与docker save/load的区别：<br>    export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br>    save/load会保存完整记录，体积更大<br>    <br>    <br>    <br>docker top CONTAINER：查看某个容器内的所有进程<br>docker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息<br><br>docker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx：在本地和容器间复制文件<br>docker rename CONTAINER1 CONTAINER2：重命名容器<br>docker update CONTAINER --memory 500MB：修改容器限制<br><br><br></code></pre></td></tr></table></figure>

<p>创建服务器要注意端口映射 </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">20000</span>:<span class="hljs-number">22</span> -p <span class="hljs-number">443</span>:<span class="hljs-number">443</span> -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> -p <span class="hljs-number">3000</span>:<span class="hljs-number">3000</span> -p <span class="hljs-number">3001</span>:<span class="hljs-number">3001</span> -p <span class="hljs-number">3002</span>:<span class="hljs-number">3002</span> -itd --name kob_server django_lesson:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>



<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adduser xxx</span><br><span class="hljs-attribute">usermod -aG sudo xxx</span><br></code></pre></td></tr></table></figure>

<p><strong>安装、配置mysql</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-keyword">get</span> install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">sudo service mysql <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure>

<p>设置root用户的密码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo mysql<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> caching_sha2_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;yourpasswd&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>创建对应数据库</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">create database kob<span class="hljs-comment">;</span><br>use kob<span class="hljs-comment">;</span><br>source /home/rxs/kob.sql<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>



<p><strong>安装java8</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install openjdk-8-jdk<br></code></pre></td></tr></table></figure>



<h3 id="Nignx-服务"><a href="#Nignx-服务" class="headerlink" title="Nignx 服务"></a>Nignx 服务</h3><ol>
<li><p>配置  acpp.key 文件</p>
<ol>
<li>配置 acapp.pem 文件	&#x2F;&#x2F; https认证</li>
</ol>
</li>
<li><p>配置 nginx.conf</p>
</li>
<li><pre><code class="hljs">sudo /etc/init.d/nginx start	//启动服务

错误信息 记得加上sudo 普通用户没有读取权限
    /var/log/nginx/erro.log
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br>   <br><br><br><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>df -h 	&#x2F;&#x2F;查看硬盘空间使用情况<br>free -h &#x2F;&#x2F;内存</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br><br><br>前端 整个上传不用启动<br><br></code></pre></td></tr></table></figure>
<p>scp -r dist springboot:</p>
<pre><code class="hljs">
</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>shell笔记</title>
    <url>/2021/08/21/Linux/shell/</url>
    <content><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>shell是我们通过命令行与操作系统沟通的语言。</p>
<p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。<br>AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。</p>
<p>Linux中常见的shell脚本有很多种，常见的有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">- Bourne Shell(/usr/bin/sh或/bin/sh)<br>- Bourne Again Shell(/bin/bash)<br>- C Shell(/usr/bin/csh)<br>- K Shell(/usr/bin/ksh)<br>- zsh<br>- …<br></code></pre></td></tr></table></figure>

<p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。<br>文件开头需要写#! &#x2F;bin&#x2F;bash，指明bash为脚本解释器</p>
<p><strong>脚本示例</strong></p>
<p>新建一个test.sh文件，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br>echo &quot;Hello World!&quot;<br></code></pre></td></tr></table></figure>

<p><strong>运行方式</strong></p>
<ol>
<li>用解释器执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不需要 可执行权限, 可以直接运行</span><br>bash test.sh <br></code></pre></td></tr></table></figure>

<ol start="2">
<li>作为可执行文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod +x test.sh  # 使脚本具有可执行权限<br><br>./test.sh  # 当前路径下执行<br>/home/acs/test.sh  # 绝对路径下执行<br><span class="hljs-meta prompt_">~$ </span><span class="language-bash">~/test.sh  <span class="hljs-comment"># 家目录路径下执行</span></span><br></code></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">单行注释<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是一行注释</span><br><br>echo &#x27;Hello World&#x27;  #  这也是注释<br><br>:&lt;&lt;EOF<br>第一行注释<br>第二行注释<br>第三行注释<br>EOF<br><br>其中EOF可以换成其它任意字符串。例如：<br>:&lt;&lt;abc<br>第一行注释<br>第二行注释<br>第三行注释<br>abc<br><br>:&lt;&lt;!<br>第一行注释<br>第二行注释<br>第三行注释<br>!<br></code></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量，不需要加$符号，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name1=&#x27;yxc&#x27;  # 单引号定义字符串<br>name2=&quot;yxc&quot;  # 双引号定义字符串<br>name3=yxc    # 也可以不加引号，同样表示字符串<br></code></pre></td></tr></table></figure>

<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用变量，需要加上<code>$</code>符号，或者<code>$&#123;&#125;</code>符号。花括号是可选的，主要为了帮助解释器识别变量边界。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=yxc<br>echo $name  # 输出yxc<br>echo $&#123;name&#125;  # 输出yxc<br>echo $&#123;name&#125;acwing  # 输出yxcacwing<br></code></pre></td></tr></table></figure>

<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用readonly或者declare可以将变量变为只读。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=yxc<br>readonly name<br>declare -r name  # 两种写法均可<br>name=abc  # 会报错，因为此时name只读<br></code></pre></td></tr></table></figure>


<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>unset可以删除变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=yxc<br>unset name<br>echo $name  # 输出空行<br></code></pre></td></tr></table></figure>

<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol>
<li>自定义变量（局部变量）<br>子进程不能访问的变量</li>
<li>环境变量（全局变量）<br> 子进程可以访问的变量</li>
</ol>
<p>自定义变量改成环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量<br>acs@9e0ebfcd82d7:~$ export name  # 第一种方法<br>acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法<br></code></pre></td></tr></table></figure>

<p>环境变量改为自定义变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量<br>acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量<br></code></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p>单引号与双引号的区别：</p>
<ul>
<li>单引号中的内容会原样输出，不会执行、不会取变量；</li>
<li>双引号中的内容可以执行、可以取变量；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=yxc  # 不用引号<br>echo &#x27;hello, $name \&quot;hh\&quot;&#x27;  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;<br>echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;<br></code></pre></td></tr></table></figure>

<p>获取字符串长度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=&quot;yxc&quot;<br>echo $&#123;#name&#125;  # 输出3<br></code></pre></td></tr></table></figure>

<p>提取子串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=&quot;hello, yxc&quot;<br>echo $&#123;name:0:5&#125;  # 提取从0开始的5个字符<br></code></pre></td></tr></table></figure>





<h1 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h1><h3 id="文件参数变量"><a href="#文件参数变量" class="headerlink" title="文件参数变量"></a>文件参数变量</h3><p>在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：</p>
<p>创建文件test.sh：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>echo &quot;文件名：&quot;$0<br>echo &quot;第一个参数：&quot;$1<br>echo &quot;第二个参数：&quot;$2<br>echo &quot;第三个参数：&quot;$3<br>echo &quot;第四个参数：&quot;$4<br></code></pre></td></tr></table></figure>

<p>然后执行该脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4<br>文件名：./test.sh<br>第一个参数：1<br>第二个参数：2<br>第三个参数：3<br>第四个参数：4<br></code></pre></td></tr></table></figure>

<p>其它参数相关变量</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$#</code></td>
<td>代表文件传入的参数个数，如上例中值为4</td>
</tr>
<tr>
<td>$*</td>
<td>由所有参数构成的用空格隔开的字符串，如上例中值为”$1 $2 $3 $4”</td>
</tr>
<tr>
<td>$@</td>
<td>每个参数分别用双引号括起来的字符串，如上例中值为”$1” “$2” “$3” “$4”</td>
</tr>
<tr>
<td>$$</td>
<td>脚本当前运行的进程ID</td>
</tr>
<tr>
<td>$?</td>
<td>上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误</td>
</tr>
<tr>
<td>$(command)</td>
<td>返回command这条命令的stdout（可嵌套）</td>
</tr>
<tr>
<td>`command&#96;</td>
<td>返回command这条命令的stdout（不可嵌套）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 stdout 是标准输出 (输出值的)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">		退出状态是指 命令执行完 <span class="hljs-built_in">return</span> 的值</span><br></code></pre></td></tr></table></figure>



<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。<br>数组<strong>下标从0开始</strong>。</p>
<p><strong>定义</strong><br>数组用小括号表示，元素之间用空格隔开。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br></code></pre></td></tr></table></figure>

<p>也可以直接定义数组中某个元素的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">array[0]=1<br>array[1]=abc<br>array[2]=&quot;def&quot;<br>array[3]=yxc<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">1、在读取整个数组时，未定义的部分就不会显示。<br>    比如定义了array[0]array[1]array[2]array[1000],利用`echo $&#123;array[@]&#125;`输出时，只会显示我们定义的数组那4个元素的值<br>    <br>2、对上例求长度时，结果是4，而不是1000<br></code></pre></td></tr></table></figure>

<p><strong>读取数组中某个元素的值</strong><br>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">`$&#123;array[index]&#125;`<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br>echo $&#123;array[0]&#125;<br>echo $&#123;array[1]&#125;<br>echo $&#123;array[2]&#125;<br>echo $&#123;array[3]&#125;<br></code></pre></td></tr></table></figure>

<p><strong>读取整个数组</strong><br>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[@]&#125;  <span class="hljs-comment"># 第一种写法</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[*]&#125;  <span class="hljs-comment"># 第二种写法</span></span><br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br><br>echo $&#123;array[@]&#125;  # 第一种写法<br>echo $&#123;array[*]&#125;  # 第二种写法<br></code></pre></td></tr></table></figure>

<p><strong>数组长度</strong><br>类似于字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#array[@]&#125;  # 第一种写法</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#array[*]&#125;  # 第二种写法</span></span><br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br><br>echo $&#123;#array[@]&#125;  # 第一种写法<br>echo $&#123;#array[*]&#125;  # 第二种写法<br></code></pre></td></tr></table></figure>



<h1 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h1><p>expr命令用于求表达式的值，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">expr 表达式<br></code></pre></td></tr></table></figure>

<p>表达式说明：</p>
<ul>
<li>用空格隔开每一项</li>
<li>用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）</li>
<li>对包含空格和其他特殊字符的字符串要用引号括起来</li>
<li>expr会在<code>stdout</code>中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。</li>
<li>expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。</li>
</ul>
<h3 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h3><ul>
<li><p>length STRING</p>
<p>返回STRING的长度</p>
</li>
<li><p>index STRING CHARSET</p>
<p>CHARSET中任意单个字符在STRING中最前面的字符位置，<strong>下标从1开始</strong>。如果在STRING中完全不存在CHARSET中的字符，则返回0。</p>
</li>
<li><p>substr STRING POSITION LENGTH</p>
</li>
<li><p>返回STRING字符串中从POSITION开始，长度最大为LENGTH的子串。如果POSITION或LENGTH为负数，0或非数值，则返回空字符串。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">str=&quot;Hello World!&quot;<br><br>echo `expr length &quot;$str&quot;`  	  # ``不是单引号，表示执行该命令，输出12<br>echo `expr index &quot;$str&quot; aWd`  # 输出7，下标从1开始<br>echo `expr substr &quot;$str&quot; 2 3` # 输出 ell 从2开始获取长度为3的子串<br></code></pre></td></tr></table></figure>

<h3 id="整数表达式"><a href="#整数表达式" class="headerlink" title="整数表达式"></a>整数表达式</h3><p>expr支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。</p>
<ul>
<li><code>+ -</code><br>加减运算。两端参数会转换为整数，如果转换失败则报错。</li>
</ul>
<ul>
<li><code>* / %</code><br>乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。</li>
</ul>
<ul>
<li><code>()</code> 可以改变优先级，但需要用反斜杠转义</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>echo `expr $a + $b`  	# 输出7<br>echo `expr $a - $b`  	# 输出-1<br>echo `expr $a \* $b`  	# 输出12，*需要转义<br>echo `expr $a / $b` 	# 输出0，整除<br>echo `expr $a % $b` 	# 输出3<br>echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">在`<span class="hljs-built_in">expr</span>`命令中，不能直接使用`+=`操作符来进行运算，因为它不支持自增运算符。不过，您可以使用其他方式实现相似的效果。<br><br>一种常见的方法是使用`<span class="hljs-built_in">expr</span>`命令结合算术运算符`+`来实现自增操作。例如，假设有一个变量`num`，您可以使用以下方式进行自增操作：<br><br>```bash<br>num=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$num</span> + 1)<br>```<br><br>上述命令将变量`num`的值加1，并将结果重新赋值给`num`。<br><br>如果您希望在原变量上直接进行自增操作，可以使用Shell的算术扩展 `$(( ))`。例如：<br><br>```bash<br>num=$((num + <span class="hljs-number">1</span>))<br>```<br><br>上述命令将变量`num`的值加1，并将结果直接赋值给`num`。<br><br>另外，还可以使用`<span class="hljs-built_in">let</span>`命令进行自增操作。例如：<br><br>```bash<br><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;num=num+1&quot;</span><br>```<br><br>上述命令将变量`num`的值加1，并将结果重新赋值给`num`。<br><br>这些方法都可以实现类似于`+=`的自增操作，您可以根据个人喜好和具体的使用场景选择适合的方法。<br></code></pre></td></tr></table></figure>

<h4 id="注意expr-不支持自增自减-不能使用"><a href="#注意expr-不支持自增自减-不能使用" class="headerlink" title="注意expr 不支持自增自减 不能使用 +="></a>注意expr 不支持自增自减 不能使用 <code>+=</code></h4><h4 id="推荐使用let命令进行计算"><a href="#推荐使用let命令进行计算" class="headerlink" title="推荐使用let命令进行计算"></a>推荐使用<code>let</code>命令进行计算</h4><p>更符合算数逻辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;result = 5 + 2&quot;</span>      <span class="hljs-comment"># 执行加法</span><br><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;result = result * 3&quot;</span> <span class="hljs-comment"># 执行乘法</span><br><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;result = result / 2&quot;</span> <span class="hljs-comment"># 执行除法</span><br><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;result = result - 1&quot;</span> <span class="hljs-comment"># 执行减法</span><br><br><span class="hljs-built_in">let</span>命令还支持使用变量自增和自减的操作<br><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;count++&quot;</span>  <span class="hljs-comment"># 自增变量count</span><br><span class="hljs-built_in">let</span> <span class="hljs-string">&quot;count--&quot;</span>  <span class="hljs-comment"># 自减变量count</span><br><br></code></pre></td></tr></table></figure>



<h3 id="逻辑关系表达式"><a href="#逻辑关系表达式" class="headerlink" title="逻辑关系表达式"></a>逻辑关系表达式</h3><ul>
<li><p><code>|</code></p>
<p>如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。</p>
</li>
<li><p><code>&amp;</code></p>
<p>如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</p>
</li>
<li><p><code>&lt; &lt;= = == != &gt;= &gt;</code></p>
<p>比较两端的参数，如果为true，则返回1，否则返回0。”&#x3D;&#x3D;”是”&#x3D;”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">= 和 == 没区别 一般习惯用 == 比较</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>()</code> 可以改变优先级，但需要用反斜杠转义</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>echo `expr $a \&gt; $b`  # 输出0，&gt;需要转义<br>echo `expr $a &#x27;&lt;&#x27; $b`  # 输出1，也可以将特殊字符用引号引起来<br>echo `expr $a &#x27;&gt;=&#x27; $b`  # 输出0<br>echo `expr $a \&lt;\= $b`  # 输出1<br><br>c=0<br>d=5<br><br>echo `expr $c \&amp; $d`  # 输出0<br>echo `expr $a \&amp; $b`  # 输出3<br>echo `expr $c \| $d`  # 输出5<br>echo `expr $a \| $b`  # 输出3<br></code></pre></td></tr></table></figure>

<h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><p>read命令用于从标准输入中读取单行数据。当读到文件结束符时，exit code为1，否则为0。</p>
<p>参数说明</p>
<ul>
<li>-p: 后面可以接提示信息</li>
<li>-t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令</li>
</ul>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ read name  # 读入name的值<br>acwing yxc  # 标准输入<br>acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值<br>acwing yxc  #标准输出<br>acs@9e0ebfcd82d7:~$ read -p &quot;Please input your name: &quot; -t 30 name  # 读入name的值，等待时间30秒<br>Please input your name: acwing yxc  # 标准输入<br>acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值<br>acwing yxc  # 标准输出<br></code></pre></td></tr></table></figure>



<h1 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h1><p>echo用于输出字符串。命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo STRING<br></code></pre></td></tr></table></figure>

<p><strong>显示普通字符串</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;Hello AC Terminal&quot;<br>echo Hello AC Terminal  # 引号可以省略<br></code></pre></td></tr></table></figure>

<p><strong>显示转义字符</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;\&quot;Hello AC Terminal\&quot;&quot;  # 注意只能使用双引号，如果使用单引号，则不转义<br>echo \&quot;Hello AC Terminal\&quot;  # 也可以省略双引号<br></code></pre></td></tr></table></figure>

<p><strong>显示变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=yxc<br>echo &quot;My name is $name&quot;  # 输出 My name is yxc<br></code></pre></td></tr></table></figure>

<p><strong>显示换行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">\\ \a \b \c \d \e \f \n \r \t \v <br>这些是要在有 - e 的时候才能起作用, 其他时候的转义是不用 `- e`也能转义的。 <br>help echo 里有讲<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo -e &quot;Hi\n&quot; 		 # -e 开启转义<br>echo &quot;acwing&quot;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hi</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">acwing</span><br></code></pre></td></tr></table></figure>

<p><strong>显示不换行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo -e &quot;Hi \c&quot; # -e 开启转义 \c 不换行<br>echo &quot;acwing&quot;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hi acwing</span><br></code></pre></td></tr></table></figure>

<p><strong>显示结果定向至文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;Hello World&quot; &gt; output.txt  # 将内容以覆盖的方式输出到output.txt中<br></code></pre></td></tr></table></figure>

<p><strong>原样输出字符串，不进行转义或取变量(用单引号)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=acwing<br>echo &#x27;$name\&quot;&#x27;<br></code></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$name</span>\&quot;<br></code></pre></td></tr></table></figure>

<p><strong>显示命令的执行结果</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo `date`<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Wed</span> Sep <span class="hljs-number">1</span> <span class="hljs-number">11</span>:<span class="hljs-number">45</span>:<span class="hljs-number">33</span> CST <span class="hljs-number">2021</span><br></code></pre></td></tr></table></figure>

<h1 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h1><p>printf命令用于格式化输出，类似于C&#x2F;C++中的printf函数。</p>
<p>默认<strong>不会在字符串末尾添加换行符</strong>。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">printf format-string [arguments...]<br></code></pre></td></tr></table></figure>

<p>用法示例<br>脚本内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">printf &quot;%10d.\n&quot; 123  						# 占10位，右对齐<br>printf &quot;%-10.2f.\n&quot; 123.123321  			# 占10位，保留2位小数，左对齐<br>printf &quot;My name is %s\n&quot; &quot;yxc&quot;  			# 格式化输出字符串<br>printf &quot;%d * %d = %d\n&quot;  2 3 `expr 2 \* 3` # 表达式的值作为参数<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache">       <span class="hljs-attribute">123</span>.<br><span class="hljs-attribute">123</span>.<span class="hljs-number">12</span>    .<br><span class="hljs-attribute">My</span> name is yxc<br><span class="hljs-attribute">2</span> * <span class="hljs-number">3</span> = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>



<h1 id="test命令与判断符号"><a href="#test命令与判断符号" class="headerlink" title="test命令与判断符号[]"></a>test命令与判断符号[]</h1><h3 id="逻辑运算符-和"><a href="#逻辑运算符-和" class="headerlink" title="逻辑运算符&amp;&amp;和||"></a>逻辑运算符&amp;&amp;和||</h3><ul>
<li><p>&amp;&amp; 表示与，|| 表示或</p>
</li>
<li><p>二者具有短路原则：</p>
<p><code>expr1 &amp;&amp; expr2</code>：当expr1为假时，直接忽略expr2</p>
<p><code>expr1 || expr2</code>：当expr1为真时，直接忽略expr2</p>
</li>
<li><p>表达式的<code>exit code</code>为0，表示真；为非零，表示假。（与C&#x2F;C++中的定义相反）</p>
</li>
</ul>
<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>在命令行中输入help test，可以查看test命令的用法。</p>
<p>test命令用于判断文件类型，以及对变量做比较。</p>
<p>test命令用<strong>exit code</strong>返回结果，而不是使用stdout。<strong>0表示真，非0表示假。</strong></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">test 2 -lt 3  # 为真，返回值为0<br>echo $?  # 输出上个命令的返回值，输出0<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件<br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>exist  # test.sh 文件存在<br>acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>Not exist  # testh2.sh 文件不存在<br></code></pre></td></tr></table></figure>

<h3 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">test -e filename  # 判断文件是否存在<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">测试参数</th>
<th align="left">代表意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-e</td>
<td align="left">文件是否存在</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">是否为文件</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">是否为目录</td>
</tr>
</tbody></table>
<h3 id="文件权限判断"><a href="#文件权限判断" class="headerlink" title="文件权限判断"></a>文件权限判断</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">test -r filename  # 判断文件是否可读<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>文件是否可读</td>
</tr>
<tr>
<td>-w</td>
<td>文件是否可写</td>
</tr>
<tr>
<td>-x</td>
<td>文件是否可执行</td>
</tr>
<tr>
<td>-s</td>
<td>是否为非空文件</td>
</tr>
</tbody></table>
<h3 id="整数间的比较"><a href="#整数间的比较" class="headerlink" title="整数间的比较"></a>整数间的比较</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">test $a -eq $b  # a是否等于b<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>a是否等于b</td>
</tr>
<tr>
<td>-ne</td>
<td>a是否不等于b</td>
</tr>
<tr>
<td>-gt</td>
<td>a是否大于b</td>
</tr>
<tr>
<td>-lt</td>
<td>a是否小于b</td>
</tr>
<tr>
<td>-ge</td>
<td>a是否大于等于b</td>
</tr>
<tr>
<td>-le</td>
<td>a是否小于等于b</td>
</tr>
</tbody></table>
<p>注意:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">在shell脚本中，使用-eq、-ne、-gt、-ge、-lt、-le进行整数的比较。英文意思分别为：<br><br>-eq ：equal（相等）<br><br>-ne ：not equal（不等）<br><br>-gt ：greater than（大于）<br><br>-ge ：greater than or equal（大于或等于）<br><br>-lt ：less than（小于）<br><br>-le ：less than or equal（小于或等于）<br><br>注意：在shell中这些符号只能用于整数的比较，不能用于字符串。<br></code></pre></td></tr></table></figure>



<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>test -z STRING</td>
<td>判断STRING是否为空，如果为空，则返回true</td>
</tr>
<tr>
<td>test -n STRING</td>
<td>判断STRING是否非空，如果非空，则返回true（-n可以省略）</td>
</tr>
<tr>
<td>test str1 &#x3D;&#x3D; str2</td>
<td>判断str1是否等于str2</td>
</tr>
<tr>
<td>test str1 !&#x3D; str2</td>
<td>判断str1是否不等于str2</td>
</tr>
</tbody></table>
<h3 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">test -r filename -a -x filename<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>两条件是否同时成立</td>
</tr>
<tr>
<td>-o</td>
<td>两条件是否至少一个成立</td>
</tr>
<tr>
<td>!</td>
<td>取反。如 test ! -x file，当file不可执行时，返回true</td>
</tr>
</tbody></table>
<h3 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号[]"></a>判断符号[]</h3><p><strong><code>[]</code>与test用法几乎一模一样，更常用于if语句中。另外<code>[[]]</code>是<code>[]</code>的加强版，支持的特性更多。</strong></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[ 2 -lt 3 ]  # 为真，返回值为0<br>echo $?  # 输出上个命令的返回值，输出0<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件<br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>exist  # test.sh 文件存在<br>acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>Not exist  # testh2.sh 文件不存在<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>[]内的每一项都要用空格隔开</li>
<li>中括号内的变量，最好用双引号括起来</li>
<li>中括号内的常数，最好用单或双引号括起来</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">name=&quot;acwing yxc&quot;<br>[ $name == &quot;acwing yxc&quot; ]  # 错误，等价于 [ acwing yxc == &quot;acwing yxc&quot; ]，参数太多<br>[ &quot;$name&quot; == &quot;acwing yxc&quot; ]  # 正确<br></code></pre></td></tr></table></figure>





<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><p>if…then形式<br>类似于C&#x2F;C++中的if-else语句。</p>
<h3 id="单层if"><a href="#单层if" class="headerlink" title="单层if"></a>单层if</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">注意 <span class="hljs-keyword">if</span> condition 判断的是<span class="hljs-built_in">exit</span> code 表达式的退出状态 0表示真 非0 表假</span><br></code></pre></td></tr></table></figure>

<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">if condition<br>then<br>    语句1<br>    语句2<br>    ...<br>fi<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]<br>then<br>    echo $&#123;a&#125;在范围内<br>fi<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">3在范围内<br></code></pre></td></tr></table></figure>

<h3 id="单层if-else"><a href="#单层if-else" class="headerlink" title="单层if-else"></a>单层if-else</h3><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">if condition<br>then<br>    语句1<br>    语句2<br>    ...<br>else<br>    语句1<br>    语句2<br>    ...<br>fi<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>if ! [ &quot;$a&quot; -lt &quot;$b&quot; ]<br>then<br>    echo $&#123;a&#125;不小于$&#123;b&#125;<br>else<br>    echo $&#123;a&#125;小于$&#123;b&#125;<br>fi<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>小于<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<h3 id="多层if-elif-elif-else"><a href="#多层if-elif-elif-else" class="headerlink" title="多层if-elif-elif-else"></a>多层if-elif-elif-else</h3><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">if condition<br>then<br>    语句1<br>    语句2<br>    ...<br>elif condition<br>then<br>    语句1<br>    语句2<br>    ...<br>elif condition<br>then<br>    语句1<br>    语句2<br>else<br>    语句1<br>    语句2<br>    ...<br>fi<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a=4<br><br>if [ $a -eq 1 ]<br>then<br>    echo $&#123;a&#125;等于1<br>elif [ $a -eq 2 ]<br>then<br>    echo $&#123;a&#125;等于2<br>elif [ $a -eq 3 ]<br>then<br>    echo $&#123;a&#125;等于3<br>else<br>    echo 其他<br>fi<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">其他<br></code></pre></td></tr></table></figure>

<h3 id="case…esac形式"><a href="#case…esac形式" class="headerlink" title="case…esac形式"></a>case…esac形式</h3><p>类似于C&#x2F;C++中的switch语句。</p>
<p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">case $变量名称 in<br>    值1)<br>        语句1<br>        语句2<br>        ...<br>        ;;  # 类似于C/C++中的break<br>    值2)<br>        语句1<br>        语句2<br>        ...<br>        ;;<br>    *)  # 类似于C/C++中的default<br>        语句1<br>        语句2<br>        ...<br>        ;;<br>esac<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a=4<br><br>case $a in<br>    1)<br>        echo $&#123;a&#125;等于1<br>        ;;  <br>    2)<br>        echo $&#123;a&#125;等于2<br>        ;;  <br>    3)                                                <br>        echo $&#123;a&#125;等于3<br>        ;;  <br>    *)<br>        echo 其他<br>        ;;  <br>esac<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">其他<br></code></pre></td></tr></table></figure>

<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h3 id="for…in…do…done"><a href="#for…in…do…done" class="headerlink" title="for…in…do…done"></a>for…in…do…done</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for var in val1 val2 val3<br>do<br>    语句1<br>    语句2<br>    ...<br>done<br></code></pre></td></tr></table></figure>

<p>示例1，输出a 2 cc，每个元素一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for i in a 2 cc<br>do<br>    echo $i<br>done<br></code></pre></td></tr></table></figure>

<p>示例2，输出当前路径下的所有文件名，每个文件名一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">in</span> 后面加上 `commond` 获取指令标准输出</span><br>for file in `ls`<br>do<br>    echo $file<br>done<br></code></pre></td></tr></table></figure>

<p>示例3，输出1-10</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">seq</span> x y 获取从x到y的标准输出</span><br><br>for i in $(seq 1 10)<br>do<br>    echo $i<br>done<br></code></pre></td></tr></table></figure>

<p>示例4，使用{1..10} 或者 {a..z}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for i in &#123;a..z&#125;<br>do<br>    echo $i<br>done<br></code></pre></td></tr></table></figure>

<h3 id="for-…-…-…-do…done"><a href="#for-…-…-…-do…done" class="headerlink" title="for ((…;…;…)) do…done"></a>for ((…;…;…)) do…done</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">类似于c</span><br>for ((expression; condition; expression))<br>do<br>    语句1<br>    语句2<br>done<br></code></pre></td></tr></table></figure>

<p>示例，输出1-10，每个数占一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for ((i=1; i&lt;=10; i++))<br>do<br>    echo $i<br>done<br></code></pre></td></tr></table></figure>

<h3 id="while…do…done循环"><a href="#while…do…done循环" class="headerlink" title="while…do…done循环"></a>while…do…done循环</h3><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sehll">while condition<br>do<br>    语句1<br>    语句2<br>    ...<br>done<br></code></pre></td></tr></table></figure>

<p>示例，<strong>文件结束符为Ctrl+d</strong>，输入文件结束符后read指令返回false。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">while read name<br>do<br>    echo $name<br>done<br></code></pre></td></tr></table></figure>

<h3 id="until…do…done循环"><a href="#until…do…done循环" class="headerlink" title="until…do…done循环"></a>until…do…done循环</h3><p>当条件为真时结束。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sehll">until condition<br>do<br>    语句1<br>    语句2<br>    ...<br>done<br></code></pre></td></tr></table></figure>

<p>示例，当用户输入yes或者YES时结束，否则一直等待读入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">until [ &quot;$&#123;word&#125;&quot; == &quot;yes&quot; ] || [ &quot;$&#123;word&#125;&quot; == &quot;YES&quot; ]<br>do<br>    read -p &quot;Please input yes/YES to stop this program: &quot; word<br>done<br></code></pre></td></tr></table></figure>

<h3 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h3><p>跳出当前一层循环，注意与C&#x2F;C++不同的是：break不能跳出case语句。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sehll">while read name<br>do<br>    for ((i=1;i&lt;=10;i++))<br>    do<br>        case $i in<br>            8)<br>                break<br>                ;;<br>            *)<br>                echo $i<br>                ;;<br>        esac<br>    done<br>done<br></code></pre></td></tr></table></figure>

<p>该示例每读入非EOF的字符串，会输出一遍1-7。<br>该程序可以输入<strong>Ctrl+d文件结束符来结束，也可以直接用Ctrl+c杀掉该进程</strong>。</p>
<h3 id="continue命令"><a href="#continue命令" class="headerlink" title="continue命令"></a>continue命令</h3><p>跳出当前循环。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sehll">for ((i=1;i&lt;=10;i++))<br>do<br>    if [ `expr $i % 2` -eq 0 ]<br>    then<br>        continue<br>    fi<br>    echo $i<br>done<br></code></pre></td></tr></table></figure>

<p>该程序输出1-10中的所有奇数。</p>
<p>死循环的处理方式<br>如果AC Terminal可以打开该程序，则输入Ctrl+c即可。</p>
<p>否则可以直接关闭进程：</p>
<ol>
<li><p>使用top命令找到进程的PID</p>
</li>
<li><p>输入kill -9 PID即可关掉此进程</p>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>bash中的函数类似于C&#x2F;C++中的函数，但<strong>return的返回值</strong>与C&#x2F;C++不同，<strong>返回的是exit code，取值为0-255，0表示正常结束</strong>。</p>
<p>如果想获取函数的输出结果，可以<strong>通过echo输出到stdout中</strong>，然后通过$(function_name)来获取stdout中的结果。</p>
<p>函数的return值可以通过$?来获取。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[function] func_name() &#123;  # function关键字可以省略<br>    语句1<br>    语句2<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="不获取-return值和stdout值"><a href="#不获取-return值和stdout值" class="headerlink" title="不获取 return值和stdout值"></a>不获取 return值和stdout值</h3><p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">func() &#123;<br>    name=yxc<br>    echo &quot;Hello $name&quot;<br>&#125;<br><br>func<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello yxc</span><br></code></pre></td></tr></table></figure>

<h3 id="获取-return值和stdout值"><a href="#获取-return值和stdout值" class="headerlink" title="获取 return值和stdout值"></a>获取 return值和stdout值</h3><p>不写return时，默认return 0。</p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">func() &#123;<br>    name=yxc<br>    echo &quot;Hello $name&quot;<br><br>return 123<br><br>&#125;<br><br>output=$(func)<br>ret=$?<br><br>echo &quot;output = $output&quot;<br>echo &quot;return = $ret&quot;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">output</span> <span class="hljs-operator">=</span> Hello yxc<br><span class="hljs-attribute">return</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<h3 id="函数的输入参数"><a href="#函数的输入参数" class="headerlink" title="函数的输入参数"></a>函数的输入参数</h3><p>在函数内，$1表示第一个输入参数，$2表示第二个输入参数，依此类推。</p>
<p>注意：函数内的$0仍然是文件名，而不是函数名。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">func() &#123;  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0<br>    word=&quot;&quot;<br>    while [ &quot;$&#123;word&#125;&quot; != &#x27;y&#x27; ] &amp;&amp; [ &quot;$&#123;word&#125;&quot; != &#x27;n&#x27; ]<br>    do<br>        read -p &quot;要进入func($1)函数吗？请输入y/n：&quot; word<br>    done<br><br>    if [ &quot;$word&quot; == &#x27;n&#x27; ]<br>    then<br>        echo 0<br>        return 0<br>    fi  <br><br>    if [ $1 -le 0 ] <br>    then<br>        echo 0<br>        return 0<br>    fi  <br>	<br>    sum=$(func $(expr $1 - 1))<br>    echo $(expr $sum + $1)<br><br>&#125;<br>echo $(func 10)<br>输出结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">55<br></code></pre></td></tr></table></figure>

<h3 id="函数内的局部变量"><a href="#函数内的局部变量" class="headerlink" title="函数内的局部变量"></a>函数内的局部变量</h3><p>可以在函数内定义局部变量，作用范围仅在当前函数内。</p>
<p>可以在递归函数中定义局部变量。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">local 变量名=变量值<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>func() &#123;<br>    local name=crx	#局部<br>    age=18 			#全局<br>    echo $name<br>    echo $age<br>&#125;<br>func<br><br>echo $name<br>echo $age<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">shell语法中函数的变量若无声明 就默认是全局变量</span><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">crx</span><br><span class="hljs-number">18</span><br><br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>

<p>第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。</p>
<h1 id="exit命令"><a href="#exit命令" class="headerlink" title="exit命令"></a>exit命令</h1><ul>
<li><p>exit命令用来退出当前shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。</p>
</li>
<li><p>exit命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。</p>
</li>
<li><p>exit退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。</p>
</li>
</ul>
<p>示例：</p>
<p>创建脚本test.sh，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>if [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。<br>then<br>    echo &quot;arguments not valid&quot;<br>    exit 1<br>else<br>    echo &quot;arguments valid&quot;<br>    exit 0<br>fi<br></code></pre></td></tr></table></figure>

<p>执行该脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh acwing<br>arguments valid<br>acs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为0<br>0<br>acs@9e0ebfcd82d7:~$ ./test.sh <br>arguments not valid<br>acs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为1<br>1<br></code></pre></td></tr></table></figure>



<h1 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h1><p>每个进程默认打开3个文件描述符：</p>
<ul>
<li><p>stdin标准输入，从命令行读取数据，文件描述符为0</p>
</li>
<li><p>stdout标准输出，向命令行输出数据，文件描述符为1</p>
</li>
<li><p>stderr标准错误输出，向命令行输出数据，文件描述符为2</p>
</li>
</ul>
<p>可以用文件重定向将这三个文件重定向到其他文件中。</p>
<p><strong>重定向命令列表</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &gt; file</td>
<td>将stdout重定向到file中</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将stdin重定向到file中</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将stdout以追加方式重定向到file中</td>
</tr>
<tr>
<td>command n&gt; file</td>
<td>将文件描述符n重定向到file中</td>
</tr>
<tr>
<td>command n&gt;&gt; file</td>
<td>将文件描述符n以追加方式重定向到file中</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">读入命令重定向到文件中，意思是从文件中读取输入</span><br></code></pre></td></tr></table></figure>

<p><strong>输入和输出重定向</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo -e &quot;Hello \c&quot; &gt; output.txt  # 将stdout重定向到output.txt中<br>echo &quot;World&quot; &gt;&gt; output.txt  # 将字符串追加到output.txt中<br><br>read str &lt; output.txt  # 从output.txt中读取字符串<br><br>echo $str  # 输出结果：Hello World<br></code></pre></td></tr></table></figure>

<p><strong>同时重定向stdin和stdout</strong><br>创建bash脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>read a<br>read b<br><br>echo $(expr &quot;$a&quot; + &quot;$b&quot;)<br>创建input.txt，里面的内容为：<br><br>3<br>4<br></code></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限<br>acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中<br>acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容<br>7<br></code></pre></td></tr></table></figure>



<h1 id="引入外部脚本"><a href="#引入外部脚本" class="headerlink" title="引入外部脚本"></a>引入外部脚本</h1><p>类似于C&#x2F;C++中的include操作，bash也可以引入其他文件中的代码。</p>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">. filename  # 注意点和文件名之间有一个空格<br><br>或<br><br>source filename<br></code></pre></td></tr></table></figure>

<p>示例<br>创建test1.sh，内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>name=yxc  # 定义变量name<br></code></pre></td></tr></table></figure>

<p>然后创建test2.sh，内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>source test1.sh # 或 . test1.sh<br><br>echo My name is: $name  # 可以使用test1.sh中的变量<br></code></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test2.sh <br>acs@9e0ebfcd82d7:~$ ./test2.sh <br>My name is: yxc<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>csa</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>地表最强shell-zsh</title>
    <url>/2021/11/21/Linux/%E5%9C%B0%E8%A1%A8%E6%9C%80%E5%BC%BAshell-zsh/</url>
    <content><![CDATA[<h1 id="地表最强shell-zsh"><a href="#地表最强shell-zsh" class="headerlink" title="地表最强shell-zsh"></a>地表最强shell-zsh</h1><h2 id="redhat8-更改yum源"><a href="#redhat8-更改yum源" class="headerlink" title="redhat8 更改yum源"></a>redhat8 更改yum源</h2><p>redhat安装完成后是不能直接使用yum安装的，会提示我们没有注册，所以要修改成Centos的源</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">This <span class="hljs-keyword">system</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> registered <span class="hljs-keyword">to</span> Red Hat <span class="hljs-keyword">Subscription</span> Management. You can use <span class="hljs-keyword">subscription</span>-manager <span class="hljs-keyword">to</span> register.<br></code></pre></td></tr></table></figure>

<p>这里使用阿里云Centos8 yum源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /etc/yum.repos.d/<br></code></pre></td></tr></table></figure>

<p>下载阿里云yum源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo<br></code></pre></td></tr></table></figure>

<p>将redhat源名称修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mv redhat.repo redhat.repo_bak<br></code></pre></td></tr></table></figure>

<p>这个时候我们已经可以使用阿里云yum源了，但是还是会有注册提示，可以忽略<br>我们可以通过修改以下两个文件的Enable&#x3D;0来禁用Subscription Management提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vi /etc/yum/pluginconf.d/product-id.conf<br>vi /etc/yum/pluginconf.d/subscription-manager.conf<br><br>yum clean all<br>yum makecache<br></code></pre></td></tr></table></figure>

<h2 id="安装zsh和oh-my-zsh"><a href="#安装zsh和oh-my-zsh" class="headerlink" title="安装zsh和oh-my-zsh"></a>安装zsh和oh-my-zsh</h2><h3 id="查看当前shell"><a href="#查看当前shell" class="headerlink" title="查看当前shell"></a>查看当前shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br></code></pre></td></tr></table></figure>

<h3 id="安装shell"><a href="#安装shell" class="headerlink" title="安装shell"></a>安装shell</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum install -y zsh<br></code></pre></td></tr></table></figure>

<h3 id="查看系统已经安装的shell"><a href="#查看系统已经安装的shell" class="headerlink" title="查看系统已经安装的shell"></a>查看系统已经安装的shell</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /etc/shells<br></code></pre></td></tr></table></figure>

<h3 id="切换shell-安装git"><a href="#切换shell-安装git" class="headerlink" title="切换shell,安装git"></a>切换shell,安装git</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">chsh -s /bin/zsh<br>yum install -y git<br></code></pre></td></tr></table></figure>

<h3 id="下载执行oh-my-zsh"><a href="#下载执行oh-my-zsh" class="headerlink" title="下载执行oh-my-zsh"></a>下载执行oh-my-zsh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">国外源</span><br>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">国内源</span><br>sh -c &quot;$(curl -fsSL https://gitee.com/powersee/ohmyzsh/raw/master/tools/install.sh)&quot;<br></code></pre></td></tr></table></figure>

<h2 id="配置和优化"><a href="#配置和优化" class="headerlink" title="配置和优化"></a>配置和优化</h2><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>查看有哪些主题:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls ~/.oh-my-zsh/themes/<br></code></pre></td></tr></table></figure>

<p>修改主题:</p>
<blockquote>
<p>ZSH_THEME 字段就是主题,根据上面查看到的主题中选一个自己喜欢的替换即可，默认主题是<code>robbyrussell</code><br>如果想每次进入shell的时候随机使用一款主题，那么可以设置 ZSH_THEME&#x3D;”random”<br>个人比较喜欢 xiong-chiamiov 这款主题<br>修改完之后通过 source ~&#x2F;.zshrc 即可让设置的主题生效，当然退出当前terminal重新登录也可以生效。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vim ~/.zshrc<br></code></pre></td></tr></table></figure>

<p>使主题生效：### zsh-syntax-highlighting</p>
<p>代码语法高亮显示插件，毫无疑问，非常好用，但是需要自己安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.进入oh-my-zsh自定义插件目录</span><br>cd ~/.oh-my-zsh/custom/plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.拉取zsh-syntax-highlighting代码</span><br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.在配置文件~/.zshrc中添加插件（注意：自定义安装的插件最好放在所有插件的最下方）</span><br>plugins=(<br>    git<br>    zsh-syntax-highlighting<br>)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.使插件生效（在配置文件最后加上下面这一行代码）</span><br>source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.保存退出之后，<span class="hljs-built_in">source</span> ~/.zshrc即可生效</span><br>source ~/.zshrc<br></code></pre></td></tr></table></figure>

<h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><p>zsh的自动补全插件，可以根据你之前的使用习惯自动给你补全的建议，强烈建议安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.进入oh-my-zsh自定义插件目录</span><br>cd ~/.oh-my-zsh/custom/plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.拉取zsh-autosuggestions代码</span><br>git clone https://github.com/zsh-users/zsh-autosuggestions<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.在配置文件~/.zshrc中添加插件（注意：自定义安装的插件最好放在所有插件的最下方）</span><br>plugins=(<br>    git<br>    zsh-syntax-highlighting<br>    zsh-autosuggestions<br>)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.保存退出之后，<span class="hljs-built_in">source</span> ~/.zshrc即可生效</span><br>source ~/.zshrc<br></code></pre></td></tr></table></figure>

<p>其他插件：<a href="https://www.cnblogs.com/jie-fang/p/13437335.html">CentOS7安装zsh和oh-my-zsh - StaryJie - 博客园 (cnblogs.com)</a></p>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p><code>~/.zshrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">plugins=(<br>	sudo<br>    git<br>    zsh-syntax-highlighting<br>    zsh-autosuggestions<br>)<br></code></pre></td></tr></table></figure>

<h2 id="安装htop"><a href="#安装htop" class="headerlink" title="安装htop"></a>安装htop</h2><p>htop是一款功能强大的互动的进程查看器。</p>
<p>但是htop不是基础命令，有的系统优化去掉了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum install -y epel-release<br>yum install -y htop<br></code></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>csa</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2020/09/11/Python/Python/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><p>answer  &#x3D;  99	—&gt;	标识符（变量）    赋值符	值 </p>
<p>python 变量</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">1</span>.不用事先声明变量，赋值过程中就包含了变量的声明和定义<br><span class="hljs-number">2</span>.用<span class="hljs-string">&quot; = &quot;</span>赋值，左边是变量名，右边是变量值<br><span class="hljs-number">3</span>.使用前必须先被初始化（先被赋值）<br><span class="hljs-number">4</span>.可以通过<span class="hljs-built_in">del</span>语句删除不再使用的变量<br>	python中有垃圾回收装置，所以也可以不用操作<br></code></pre></td></tr></table></figure>

<p>变量：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">变量在程序中就是用一个变量名表示<br>变量名必须是大小写英文，数字和_组成<br>不能用数字开头<br>不能和内置关键字冲突<br><span class="hljs-strong">***</span>变量不需要声明，每个变量在使用前必须被赋值（不需要类型定义）<br></code></pre></td></tr></table></figure>

<p>在python中，” &#x3D; “是赋值语句，可以把任何数据类型赋值给变量</p>
<p>​	如果” &#x3D; “右边为表达式，则先计算表示达式的值，得到结果，再经行赋值操作</p>
<p>注：同一个变量可以反复赋值，而且可以赋值不同类型的变量（动态语言）</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">查看python关键字<br>&gt;&gt;&gt;<span class="hljs-keyword">import</span> <span class="hljs-built_in">keyword</span><br>&gt;&gt;&gt;<span class="hljs-built_in">keyword</span> kwlist<br></code></pre></td></tr></table></figure>

<p>python 用缩进规定 作用域范围，</p>
<p>值的范围：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">整数：<br>python 可以处理任何大小的整数（包括负整数），整数没有大小限制<br><br>浮点数：<br>浮点数可以用数学写法，但对于较大或者较小的浮点数，必须用科学计数法表示<br><span class="hljs-number">10</span>用e代替，eg. <span class="hljs-number">1.23</span>x10^<span class="hljs-number">9</span> ——&gt; <span class="hljs-number">1.23e9</span>，或者 <span class="hljs-number">12.38e8</span> / <span class="hljs-number">1.2e-5</span><br>注：浮点数也没有大小限制，但是超出一定范围就直接表示为 inf （无限大）<br><br>字符串：<br>字符串是以 <span class="hljs-string">&#x27;单引号&#x27;</span> 或者 <span class="hljs-string">&quot;双引号&quot;</span> 括起来的任意文本<br>	字符串内部既包含<span class="hljs-string">&#x27; 和 &quot; 可以用转义字符\来标识</span><br><span class="hljs-string">    eg. &#x27;</span>I\<span class="hljs-string">&#x27;m \&quot;OK\&quot;!&#x27;</span> ——&gt; I<span class="hljs-string">&#x27;m &quot;OK&quot;!</span><br><span class="hljs-string">注：python 用 &quot; r &quot; 表示内部字符串默认不转义</span><br><span class="hljs-string">print(r&quot;\\n\n\n\&quot;)</span><br><span class="hljs-string">      </span><br><span class="hljs-string">布尔值bool：</span><br><span class="hljs-string"> 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值</span><br><span class="hljs-string"></span><br><span class="hljs-string">空值：</span><br><span class="hljs-string">	空值是Python里一个特殊的值，用None表示。None不能理解为0，</span><br><span class="hljs-string">	因为0是有意义的，而None是一个特殊的空值</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">算术运算： + - * ** / // %  <br>关系运算： == != &gt; &lt; &lt;= &gt;=  <br>位运算：   &amp; | ^ ~ &gt;&gt; &lt;&lt;  <br>逻辑运算： <span class="hljs-keyword">and</span> <span class="hljs-keyword">or</span><span class="hljs-built_in"> not</span> <br>成员运算： <span class="hljs-keyword">in</span><span class="hljs-built_in"> not</span> <span class="hljs-keyword">in</span> <br>身份运算： <span class="hljs-literal">is</span> <span class="hljs-literal">is</span> no<br></code></pre></td></tr></table></figure>

<p>python中有两种除法：</p>
<ol>
<li><p>&#x2F;		&#x2F;除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数</p>
</li>
<li><p>&#x2F;&#x2F;       整除</p>
<p>​		 &#x2F;&#x2F;地板除，整数的地板除永远是整数，即使除不尽。10 &#x2F;&#x2F; 3 &gt;&gt;&gt; 3</p>
</li>
</ol>
<p>** 操作来进行幂运算：</p>
<p>​		eg. &gt;&gt;&gt; 5 ** 2  # 5的平方</p>
<p>​			  25</p>
<p>位运算：</p>
<p>&amp; ：与	与操作（2进制，对应位都为1，才为1）</p>
<p>| ：或	按位做加法（2进制，有一位为1，则为1 ） </p>
<p>^	异或		对应位，不一样为真，一样为假</p>
<p>~		取反</p>
<p>&gt;&gt; 右移  &lt;&lt; 左移</p>
<p>逻辑运算：</p>
<p>类似于集合的   并集and	合集or	非集not</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">20</span><br><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br><span class="hljs-keyword">if</span> a <span class="hljs-keyword">and</span> b :<br>	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - 变量 a 和 b 都为 true&quot;</span>) <br><span class="hljs-keyword">else</span>: <br>	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - 变量 a 和 b 有一个不为 true&quot;</span>)<br></code></pre></td></tr></table></figure>



<p>成员运算</p>
<p>in	在里面为真，不在里面为假</p>
<p>not in	在里面为假，不在里面为真</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span> ):<br> 	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;变量 a 在给定的列表中 list 中&quot;</span>)<br><span class="hljs-keyword">else</span>:<br> 	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;变量 a 不在给定的列表中 list 中)</span><br></code></pre></td></tr></table></figure>



<p>身份运算</p>
<p>is   is not （判断内存地址）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">2</span><br>b=<span class="hljs-number">2</span>		<span class="hljs-comment">#python 常量只保存一次，a、b指向的id内存地址相同</span><br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">is</span> b ):<br> 	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - a 和 b 有相同的标识&quot;</span>)<br><span class="hljs-keyword">else</span>:<br> 	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - a 和 b 没有相同的标识&quot;</span>,<span class="hljs-built_in">id</span>(a),<span class="hljs-built_in">id</span>(b))<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b ):<br> <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;4 - a 和 b 没有相同的标识&quot;</span>)<br><span class="hljs-keyword">else</span>:<br> <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;4 - a 和 b 有相同的标识&quot;</span>)<br></code></pre></td></tr></table></figure>



<h2 id="基本IO"><a href="#基本IO" class="headerlink" title="基本IO"></a>基本IO</h2><p>input:			默认输入为字符串</p>
<p>output：</p>
<p>%格式化输出</p>
<p>​		%运算符就是用来格式化字符串的。在字符串内部，%s表示 用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应 好。如果只有一个%?，括号可以省略。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a = %d b = %s&quot;</span>% (a,b))<br></code></pre></td></tr></table></figure>

<p>​	注：python允许字符串拼接（不常用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">name=<span class="hljs-string">&#x27;Michael&#x27;</span><br>value=<span class="hljs-number">1000000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hi,&#x27;</span>,name,<span class="hljs-string">&#x27;you have $&#x27;</span>,value)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hi,&#x27;</span>+name+<span class="hljs-string">&#x27;you have $&#x27;</span>+<span class="hljs-built_in">str</span>(value))<br>	<span class="hljs-comment">#所有类型转化为str字符串，才能用+拼接起来</span><br></code></pre></td></tr></table></figure>

<p>format格式化输出</p>
<ol>
<li><p>顺序填坑	可以有元素多，不能有元素少</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a,b))<br></code></pre></td></tr></table></figure>
</li>
<li><p>下标填坑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a = &#123;1&#125;, b = &#123;0&#125;.format(a,b)&quot;</span>)<br>	&gt;&gt;&gt; a = b, b = a (<span class="hljs-built_in">format</span> 顺序为 <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2.</span>.)<br></code></pre></td></tr></table></figure>
</li>
<li><p>变量填坑      format变量必须当时赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;名字是&#123;name&#125;,年龄是&#123;age&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name = <span class="hljs-string">&#x27;tom&#x27;</span>,age = <span class="hljs-number">23</span>)) <br></code></pre></td></tr></table></figure></li>
</ol>
<p>sep是多个输出之间的分隔符，默认是一个空格。</p>
<p>end是 输出的结尾，默认是换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是一段输出&#x27;</span>, <span class="hljs-string">&#x27;下一段输出&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><br>&gt;&gt;&gt;这是一段输出,下一段输出 <br>&gt;&gt;&gt;进程已结束，退出代码为 <span class="hljs-number">0</span><br>	<span class="hljs-comment">#没有sep 和 end 为</span><br>&gt;&gt;&gt;这是一段输出 下一段输出<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;进程已结束，退出代码为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>条件判断：只有if else 判断，没有switch case判断 if语句的完整形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">简写版：<br><span class="hljs-keyword">if</span> 判断 :<br>	执行<span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>    执行<span class="hljs-number">2</span><br> <br><span class="hljs-keyword">if</span> &lt;条件判断<span class="hljs-number">1</span>&gt;:<br>    &lt;执行<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">2</span>&gt;:<br>    &lt;执行<span class="hljs-number">2</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">3</span>&gt;:<br>    &lt;执行<span class="hljs-number">3</span>&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;执行<span class="hljs-number">4</span>&gt;<br></code></pre></td></tr></table></figure>

<p>for..in语法规则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 循环范围 ：<br>	循环执行语句<br><br><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 循环范围 ：<br>	循环执行语句<br><span class="hljs-keyword">else</span>：<br>	执行一次<br><br><span class="hljs-string">&quot;&quot;&quot;注意：</span><br><span class="hljs-string">for 循环使用 else 语句</span><br><span class="hljs-string">在 python 中，for … else 表示这样的意思，</span><br><span class="hljs-string">for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完</span><br><span class="hljs-string">（即 for 不是通过 break 跳出而中断的)的情况下执行，</span><br><span class="hljs-string">while … else 也是一样。&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>:	<span class="hljs-comment">#遍历list</span><br>	<span class="hljs-built_in">print</span>(x)	<br>依次把<span class="hljs-built_in">list</span>中的每个元素迭代出来，<br>所以<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ...循环<br>就是把每个元素代入变量x，然后执行缩进块的语句<br></code></pre></td></tr></table></figure>

<p>循环范围：可以是列表，也可以是range函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>): <span class="hljs-comment">#遍历 0 - 100 的所有整数</span><br> <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + x<br> <span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure>

<p>​		其中range是python提供的内置函数，表示边界范围</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">range(<span class="hljs-literal">start</span>,<span class="hljs-literal">stop</span>,step)<br><span class="hljs-literal">start</span>:计数从<span class="hljs-literal">start</span>开始，默认为<span class="hljs-number">0</span><br><span class="hljs-literal">stop</span>:计数到<span class="hljs-literal">stop</span>结束，但不包括<span class="hljs-literal">stop</span><br>step：步长，默认为<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>while 语法规则： </p>
<p>​	while 逻辑表达式 ：</p>
<p>​			循环执行语句</p>
<p>死循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> Ture:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>),<br></code></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>创建字符串很简单，只要为变量分配一个值即可，使用引号 (‘或”)来创建字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">var1 = <span class="hljs-string">&#x27;Hello World!&#x27;</span> <span class="hljs-comment">#单字符在 Python 中也是作为一个字符</span><br>串使用。<br>str1 = <span class="hljs-string">&quot;hello python&quot;</span><br></code></pre></td></tr></table></figure>

<ol>
<li><p>字符串求长度：len(str1);</p>
</li>
<li><p>字符串拼接： +       （”字符串”  *  3）重复三次</p>
</li>
<li><p>字符串遍历： for a in str1</p>
</li>
<li><p>字符串包含判断：if (‘a’ in sample_str7) &#x3D;&#x3D;&gt;true &#x2F;false（in操作符）</p>
</li>
<li><p>字符串索引： 正向索引： str1[0] str1[1] str[2] </p>
<p>​						反向索引： str1[-1] str1[-2] str1[-3] （-1为倒数第一个）</p>
</li>
<li><p>字符串切片：str1[start: end:step] &#x3D;&#x3D;》str1[0:4] （可以指定步长）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello would&quot;</span><br><span class="hljs-built_in">print</span>(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="常见字符串内置函数："><a href="#常见字符串内置函数：" class="headerlink" title="常见字符串内置函数："></a>常见字符串内置函数：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.strip([chars]) ==》<br>	<span class="hljs-built_in">print</span>(sample_fun1.strip()) <span class="hljs-comment">#默认去掉首尾空格</span><br>	<span class="hljs-built_in">print</span>(sample_fun1.strip(<span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">#指定首尾需要删除的字符</span><br><br><span class="hljs-built_in">str</span>.count(<span class="hljs-string">&#x27;chars&#x27;</span>,start,end)<br>	<span class="hljs-comment">#统计chars字符串或者字符在str中出现的次数，</span><br>	从start顺序开始查找一直到end顺序范围结束，默认是从顺序<span class="hljs-number">0</span>开始<br><br><span class="hljs-built_in">str</span>.capitalize() 将字符串的首字母大写<br><br><span class="hljs-built_in">str</span>.upper() 将字符串中的字母全部转换成大写字母<br><span class="hljs-built_in">str</span>.isupper() 判断字符串是否全是大写<br><br><span class="hljs-built_in">str</span>.lower() 将字符串中的字母全部转换成小写字母<br><span class="hljs-built_in">str</span>.islower() 判断字符串是否全是小写<br><br><span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;str&#x27;</span>,start,end)	<span class="hljs-comment">#返回值为第一个&#x27;str&#x27;首字母下标位置</span><br> 	查找并返回子字符<span class="hljs-string">&#x27;str&#x27;</span>在start到end范围内首次出现的下标位置，<br> 	默认范围是从字符串的头开始到尾结束<br><span class="hljs-built_in">str</span>.index(<span class="hljs-string">&#x27;str&#x27;</span>,start,end) 同上，单没有字符会报错<br><br><span class="hljs-built_in">str</span>.replace(oldstr, newstr,count) <br>	<span class="hljs-comment">#用旧的子字符串替换新的子字符串，若不指定count默认全部替换</span><br>    <br><span class="hljs-built_in">str</span>.split(sep,maxsplit) <span class="hljs-comment">#将字符串拆成列表</span><br>	将字符串<span class="hljs-built_in">str</span>按照指定的sep字符进行分割，形成列表返回<br>	maxsplit是指定需要分割的次数，<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.split()) 若不指定<span class="hljs-comment">#sep默认是分割空格，全部分割</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment">#分割一次，也就是生成一个两元素列表</span><br>    <br><span class="hljs-built_in">str</span>.join(<span class="hljs-built_in">list</span>)	<span class="hljs-comment">#将列表元素返回成字符串</span><br>	<span class="hljs-built_in">list</span> = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>]<br>    <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">list</span>)<br><br><span class="hljs-built_in">str</span>.isalnum() 字符串是由字母或数字组成<span class="hljs-string">&#x27;则返回true否则返回false</span><br><span class="hljs-string"></span><br><span class="hljs-string">str.isalpha() 字符串是否全是由字母组成的</span><br><span class="hljs-string">str.isdigit() 字符串是否全是由数字组成，是则返回true，否则</span><br><span class="hljs-string">返回false</span><br></code></pre></td></tr></table></figure>

<h4 id="字符串遍历"><a href="#字符串遍历" class="headerlink" title="字符串遍历"></a>字符串遍历</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>下标法	<span class="hljs-built_in">str</span>[ ]<br><span class="hljs-number">2.</span><span class="hljs-keyword">for</span> .. <span class="hljs-keyword">in</span><br><span class="hljs-number">3.</span><span class="hljs-built_in">iter</span>内置函数	迭代器<br><span class="hljs-number">4.</span><span class="hljs-built_in">enumerate</span>()——枚举 (输出索引和数据)<br>详见列表遍历<br></code></pre></td></tr></table></figure>



<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>list使用： 原因： 1. 大量数据需要处理 &#x3D;&#x3D;》大容量存储 </p>
<p>​							  2. 不同类型数据需要处理 &#x3D;&#x3D;》兼容存储</p>
<p>创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>使用[ ]直接创建列表		<span class="hljs-comment">#大小，类型都没有要求</span><br>	变量名 = [列表元素，列表元素]<br><span class="hljs-number">2.</span>使用 <span class="hljs-built_in">list</span>() 函数创建列表<br>	python提供了一个内置的函数 <span class="hljs-built_in">list</span>()，可以将其它数据类型转换为列表类型<br>	<span class="hljs-comment">#将字符串转换成列表</span><br>	list1 = <span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>	<span class="hljs-built_in">print</span>(list1)<br>    &gt;&gt;&gt;[<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]<br>    <br>    <span class="hljs-comment">#将元组转换成列表</span><br> 	tuple1 = (<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>)<br> 	list2 = <span class="hljs-built_in">list</span>(tuple1)<br>	<span class="hljs-built_in">print</span>(list2)<br>    &gt;&gt;&gt;[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>]<br>    <br>    <span class="hljs-comment">#将字典转换成列表，最终列表中只有键没有值</span><br>	dict1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">9</span>&#125;<br>	list3 = <span class="hljs-built_in">list</span>(dict1)<br>	<span class="hljs-built_in">print</span>(list3)<br>    &gt;&gt;&gt;[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]______???<br>    <br>    <span class="hljs-comment">#将区间转换成列表</span><br>	range1 = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br>	list4 = <span class="hljs-built_in">list</span>(range1)<br>	<span class="hljs-built_in">print</span>(list4)<br>    &gt;&gt;&gt;[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>]<br>       <br></code></pre></td></tr></table></figure>



<p>使用部分：增-&gt;删-&gt;改-&gt;查</p>
<ol>
<li><p>增加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">append() 			<span class="hljs-comment">#可以添加字典</span><br>内置的append() <span class="hljs-comment">#添加到尾部</span><br>	lst.append(<span class="hljs-string">&quot;hello&quot;</span>)<br>insert()<br>通过 <span class="hljs-built_in">list</span>.insert(index,obj) <span class="hljs-comment">#指定位置插入</span><br>	lst.isert(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;world&quot;</span>) <span class="hljs-comment">#第一个添加</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pop()<br>通过pop()删除最后尾部元素，也可以指定一参数删除指定位置<br>	lst.pop() <span class="hljs-comment">#默认删除最后一个元素</span><br>	lst.pop(<span class="hljs-number">0</span>) <span class="hljs-comment">#指定位置删除（下标）</span><br>remove()<br><span class="hljs-built_in">list</span>.remove(obj)按值删除第一个匹配项<br>	lst.remove(<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">通过下标赋值替换 <br>lst[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-comment">#不能通过值修改，只能通过下标修改，所以必须知道位置</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">if x in L</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">xxx</span><br><span class="hljs-attribute"> else</span><span class="hljs-punctuation">:</span><br> yyy<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="列表遍历"><a href="#列表遍历" class="headerlink" title="列表遍历"></a>列表遍历</h4><ol>
<li><p>for… in 遍历</p>
<p>for  xxx  in  list：</p>
</li>
<li><p>range（）函数遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1234</span>,<span class="hljs-number">5678</span>,<span class="hljs-number">8912</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>)):<br>	<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>[i])		<span class="hljs-comment">#取长度，拿下标遍历</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>enumerate（）函数遍历——枚举</p>
<p>用于将一个可遍历的数据对象（如列表，元组，字符串）组合为一个索引序列，同时列出数据和数据下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1234</span>,<span class="hljs-number">5678</span>,<span class="hljs-number">8912</span>]<br><span class="hljs-keyword">for</span>	index,<span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">list</span>):<br>	<span class="hljs-built_in">print</span> (index,<span class="hljs-built_in">id</span>)<br>&gt;&gt;&gt;<span class="hljs-number">0</span> <span class="hljs-number">1234</span><br>&gt;&gt;&gt;<span class="hljs-number">1</span> <span class="hljs-number">5678</span><br>&gt;&gt;&gt;<span class="hljs-number">2</span> <span class="hljs-number">8912</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>iter()函数用来生产迭代器遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1234</span>,<span class="hljs-number">5678</span>,<span class="hljs-number">8912</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>):<br>	<span class="hljs-built_in">print</span>(x)<br>&gt;&gt;&gt;<span class="hljs-number">1234</span><br>&gt;&gt;&gt;<span class="hljs-number">5678</span><br>&gt;&gt;&gt;<span class="hljs-number">8912</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="列表内置函数"><a href="#列表内置函数" class="headerlink" title="列表内置函数"></a>列表内置函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>	<span class="hljs-built_in">list</span>.append(obj)<br>	在列表末尾添加新的对象<br><span class="hljs-number">2</span>	<span class="hljs-built_in">list</span>.count(obj)<br>	统计某个元素在列表中出现的次数<br><span class="hljs-number">3</span>	<span class="hljs-built_in">list</span>.extend(seq)<br>	在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）<br><span class="hljs-number">4</span>	<span class="hljs-built_in">list</span>.index(obj)<br>	<span class="hljs-comment">#从列表中找出某个值第一个匹配项的索引位置(查下标位置)</span><br><span class="hljs-number">5</span>	<span class="hljs-built_in">list</span>.insert(index, obj)<br>	将对象插入列表<br><span class="hljs-number">6</span>	<span class="hljs-built_in">list</span>.pop([index=-<span class="hljs-number">1</span>])<br>	移除列表中的一个元素（默认最后一个元素），并且返回该元素的值<br><span class="hljs-number">7</span>	<span class="hljs-built_in">list</span>.remove(obj)<br>	移除列表中某个值的第一个匹配项<br><span class="hljs-number">8</span>	<span class="hljs-built_in">list</span>.reverse()<br>	反向列表中元素<br><span class="hljs-number">9</span>	<span class="hljs-built_in">list</span>.sort( key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<span class="hljs-comment">#reverse 降序排序</span><br>    对原列表进行排序<br>    		lst = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>]<br>        	lst.sort()<br>            <span class="hljs-built_in">print</span>(lst)<br><span class="hljs-number">10</span>	<span class="hljs-built_in">list</span>.clear()<br>	<span class="hljs-comment">#清空列表</span><br><span class="hljs-number">11</span>	<span class="hljs-built_in">list</span>.copy()<br>	复制列表<br><span class="hljs-number">12</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) <br>	查看列表元素的个数<br></code></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>Tuple：是和列表类似的存储空间，只是内容不允许修改（类c枚举）</p>
<p>创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span> = (element1, element2, ..., elemetn)<br><span class="hljs-comment">#当创建的元组中只有一个元素时，该元素后面必须要加一个逗号,否则 Python 解释器会将它视为字符串。</span><br></code></pre></td></tr></table></figure>

<p>使用tuple( )函数创建元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">tp1 = <span class="hljs-built_in">tuple</span>(data)	<br><span class="hljs-comment">#data表示可转化为元组的数据，包括字符串，元组，range对象</span><br>	tp1 = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure>

<p>Tuple可以看做是一种“不变”的List，访问也是通过下标，用小括号[]表示： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;China&#x27;</span>, <span class="hljs-string">&#x27;Jason&#x27;</span>)<br><span class="hljs-built_in">print</span>(t)<br>但是不能重新赋值替换：<br>t[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;America&#x27;</span> <span class="hljs-comment"># 修改会失败，元组元素不允许修改</span><br>也没有pop和insert、append方法 （删除插入追加）<br></code></pre></td></tr></table></figure>

<p>增加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">可以创建空元素的<span class="hljs-built_in">tuple</span>: t = ()<br><span class="hljs-comment">#元组元素的增加靠拼接实现</span><br>t = t + t2<br></code></pre></td></tr></table></figure>

<p>没有直接元素删除，可以输出对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">t = (<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br><span class="hljs-keyword">del</span> t<br><span class="hljs-built_in">print</span>(t)	<span class="hljs-comment">#打印会失败，对象被删除（不建议使用）</span><br></code></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#不能直接修改，只能间接修改</span><br>t = (<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,[<span class="hljs-string">&#x27;12&#x27;</span>,<span class="hljs-string">&#x27;13&#x27;</span>,<span class="hljs-string">&#x27;14&#x27;</span>])<br>L = t[<span class="hljs-number">3</span>]<br>L[<span class="hljs-number">0</span>] = <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure>

<p>查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、索引查找，通过使用“方括号包围的索引值及元组名”来访问元组中的元素<br>	<span class="hljs-built_in">print</span>(t[<span class="hljs-number">0</span>])		<span class="hljs-comment">#数组下标</span><br><span class="hljs-number">2</span>、切片查找，打印连续的值<br>	<span class="hljs-built_in">print</span>(t[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])	<span class="hljs-comment">#左闭右开</span><br><span class="hljs-number">3</span>、遍历<br>	<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> t1<br><span class="hljs-number">4</span>、判断元素是否在元组中<br>	<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> t)	--&gt;ture/false<br>    <br><span class="hljs-built_in">print</span>(t.count(<span class="hljs-number">2</span>)) 		<span class="hljs-comment">#查找指定元素的数量</span><br><span class="hljs-built_in">print</span>(t.index(<span class="hljs-string">&quot;c&quot;</span>))		<span class="hljs-comment">#查找第一个符合条件的索引值</span><br></code></pre></td></tr></table></figure>

<p>Python 自带垃圾回收功能，会自动销毁不用的元组， 所以一般不需要通过 del 来手动删除。</p>
<p>特性： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python中往往会将有逗号连接的量视为元组，即使其外面没有圆括号 <br>&gt;&gt;&gt;t = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(t)<br>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-comment">#可以快速交换数据</span><br>	x,y = y,x<br>    x,y,z = z,y,x<br></code></pre></td></tr></table></figure>

<p>应用场景</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">在开发中，更多的应用场景是：<br>函数的 参数 和 返回值，<br>一个函数可以接受 任意多个参数，或者 一次返回多个数据<br>格式字符串，格式化字符串后面的 () 本质上就是一个元组<br><span class="hljs-comment">#格式化字符串后面 &#x27;()&#x27; 的本质上就是元组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 年龄是 %d 身高是 %.2f&quot;</span> % (<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1.75</span>))<br><span class="hljs-comment">#定义一个元组，验证一下</span><br>info_tuple_02 = (<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1.75</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 年龄是 %d 身高是 %.2f&quot;</span> % info_tuple_02)<br><span class="hljs-comment">#此时输出的内容，与 上面的代码 输出的内容一致；</span><br><br><span class="hljs-comment">#使用格式字符串，拼接生成一个新的字符串</span><br>info_str = <span class="hljs-string">&quot;%s 年龄是 %d 身高是 %.2f&quot;</span> % info_tuple_02<br><span class="hljs-built_in">print</span>(info_str)<br></code></pre></td></tr></table></figure>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>key-Value键值对</p>
<p>字典是python中唯一的映射类型，元素之间的对应关系，即可以通过一个元素可以唯一找到另一个元素</p>
<p>创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>使用&#123;&#125;创建字典<br>	<span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>, ...&#125;<br>     <span class="hljs-built_in">dict</span>表示字典变量名，keyn : valuen 表示各个元素的键值对。<br>		<span class="hljs-comment">#同一字典中的各个键key必须唯一，不能重复 value值可以相同</span><br>    <span class="hljs-comment">#使用字符串作为key</span><br>	scores = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>,<span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">92</span>,<span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">84</span>&#125;<br>	<span class="hljs-built_in">print</span>(scores)<br>	<span class="hljs-comment">#创建空字典</span><br>	dict2 = &#123;&#125;<br>	<span class="hljs-built_in">print</span>(dict2)<br>	<span class="hljs-comment">#使用元组和数字作为key</span><br>	dict1 = &#123;(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>): <span class="hljs-string">&#x27;great&#x27;</span>, <span class="hljs-number">30</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br>	<span class="hljs-built_in">print</span>(dict1)<br><span class="hljs-number">2.</span>通过fromkrys()创建字典<br>	dictname = <span class="hljs-built_in">dict</span>.fromkeys(<span class="hljs-built_in">list</span>, value)<br>    	<span class="hljs-built_in">list</span> 参数表示字典中所有键的列表（<span class="hljs-built_in">list</span>）；<br>		value 参数表示默认值，如果不写，则为空值 <span class="hljs-literal">None</span><br>        eg. knowledge = [<span class="hljs-string">&#x27;语文&#x27;</span>,<span class="hljs-string">&#x27;数学&#x27;</span>,<span class="hljs-string">&#x27;英语&#x27;</span>]<br>            scores = <span class="hljs-built_in">dict</span>.fromkeys(knowledge, <span class="hljs-number">60</span>)<br>            <span class="hljs-built_in">print</span>(scores）<br><span class="hljs-number">3.</span>通过<span class="hljs-built_in">dict</span>()映射函数创建字典<br>    <span class="hljs-comment"># 创建空的字典</span><br>	d = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-built_in">print</span>(d)<br>          <br>    demo=[(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>)] <span class="hljs-comment">#元组放到列表中</span><br>    dt2 = <span class="hljs-built_in">dict</span>(demo)	<span class="hljs-comment">#通过dict()转化</span><br>    <span class="hljs-built_in">print</span>(dt2)<br>	                  <br>    <span class="hljs-built_in">zip</span> 函数 <span class="hljs-comment">#关联键值对</span><br>	keys=[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br>    vals =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    dt3 = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(keys,vals))<br>    <span class="hljs-built_in">print</span>(dt3)<br></code></pre></td></tr></table></figure>

<p>增加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#增加：直接通过键值对方式添加dict中的元素。</span><br>	dname[<span class="hljs-string">&quot;key&quot;</span>] = value<br></code></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#能删单一的元素也能清空字典</span><br><span class="hljs-keyword">del</span> <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;key&#x27;</span>] <span class="hljs-comment">#删除键</span><br><span class="hljs-built_in">dict</span>.clear() 	<span class="hljs-comment">#清空字典</span><br><span class="hljs-keyword">del</span> <span class="hljs-built_in">dict</span>		<span class="hljs-comment">#删除字典</span><br></code></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dname[<span class="hljs-string">&quot;Adam&quot;</span>] = <span class="hljs-number">100</span> <span class="hljs-comment">#有key覆盖原始值，没有就添加</span><br></code></pre></td></tr></table></figure>

<p>查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span><span class="hljs-built_in">dict</span>用key来访问<br>	<span class="hljs-built_in">print</span> d[<span class="hljs-string">&#x27;Adam&#x27;</span>]<br>	如果key不存在会保错<br>    所以访问之前最好先查询下key是否存在：<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Adam&#x27;</span> <span class="hljs-keyword">in</span> d : <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;exist key&#x27;</span><br>	或者用get()直接判断<br>    	<span class="hljs-keyword">if</span> d.get(<span class="hljs-string">&#x27;Adam&#x27;</span>)<br>    	&gt;&gt;&gt; <span class="hljs-built_in">print</span> d.get(<span class="hljs-string">&#x27;Jason&#x27;</span>)<br>		<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<h4 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>遍历key值<br>	<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d：<br>    	<span class="hljs-built_in">print</span>(key)<br><span class="hljs-number">2.</span>遍历value<br>	<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> d:			<br>		<span class="hljs-built_in">print</span>(d[x])<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a.values():<br>        <span class="hljs-built_in">print</span>(x)<br><span class="hljs-number">3.</span>遍历输出字典项<br>	<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> d:<br>        <span class="hljs-built_in">print</span>(x,d[x])<br>    <br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> d.items(): <span class="hljs-comment">#items()函数获取一整个键值对</span><br>        <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-number">4.</span>遍历字典健值<br>	<span class="hljs-keyword">for</span> k，v <span class="hljs-keyword">in</span> d.items():<br>        <span class="hljs-built_in">print</span>(k+<span class="hljs-string">&#x27;:&#x27;</span>+v)<br></code></pre></td></tr></table></figure>

<h4 id="字典合并"><a href="#字典合并" class="headerlink" title="字典合并"></a>字典合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">d1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>&#125;<br>d2 = &#123;<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>d1.update(d2) <span class="hljs-comment"># d1+d2</span><br>d2.update(d1) <span class="hljs-comment"># d2+d1</span><br><br><span class="hljs-comment">#手工将d1和d2数据放入d3</span><br>d3=&#123;&#125;<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> d1.items():<br> 	d3[k] =v<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> d2.items():<br> 	d3[k] =v<br><span class="hljs-built_in">print</span>(d3<br></code></pre></td></tr></table></figure>

<p>字典特性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。<br><span class="hljs-number">2</span>）键key必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。<br><br>字典的内置方法：<br><span class="hljs-built_in">len</span>(<span class="hljs-built_in">dict</span>) 计算字典元素个数，即键的总数。<br><span class="hljs-built_in">str</span>(<span class="hljs-built_in">dict</span>) 输出字典，以可打印的字符串表示。<span class="hljs-comment">#将字典转化为字符串</span><br><span class="hljs-built_in">type</span>(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>set 无序的不重复元素序列</p>
<p>set就像是把Dict中的key抽出来了一样，类似于一个List，但是内容又不能重复</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">从<span class="hljs-string">&#x27;形式&#x27;</span>上看，和字典类似，Python 集合会将所有元素放在一对大括号 &#123;&#125; 中，相邻元素之间用“,”分隔。<br> 	&#123;element1,element2,...,elementn&#125;<br>	其中，elementn 表示集合中的元素，个数没有限制。<br>从<span class="hljs-string">&#x27;内容&#x27;</span>上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，<br>	否则 Python 解释器会抛出 TypeError 错误<br></code></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>使用&#123;&#125;创建<br>	a = &#123;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-number">2.</span>使用<span class="hljs-built_in">set</span>函数创建<br>	<span class="hljs-built_in">set</span>() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、<span class="hljs-built_in">range</span> 对象等 可迭代对象转换成集合。该函数的语法格式如下：<br>	setname = <span class="hljs-built_in">set</span>(iteration)<br>    	<span class="hljs-comment">#字符串转集合</span><br>		set1 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;baidu.com&quot;</span>)<br>        set1: &#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;<br>		<span class="hljs-comment">#列表转集合</span><br>		set2 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>        set2: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>        <span class="hljs-comment">#元组转集合</span><br>		set3 = <span class="hljs-built_in">set</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br>        set3: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-string">&#x27;&#x27;&#x27;注意：创建一个空集合必须用 set() 而不是 &#123; &#125;，</span><br><span class="hljs-string">	    因为 &#123; &#125; 是用来创建一个空字典&#x27;&#x27;&#x27;</span>          <br></code></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]) <span class="hljs-comment">#set也是无序的，也不能包含重复的元素</span><br>访问一个<span class="hljs-built_in">set</span>的意义就仅仅在于查看某个元素是否在这个集合里面：<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">in</span> s<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-keyword">in</span> s<br><span class="hljs-literal">False</span><br>也通过<span class="hljs-keyword">for</span>来遍历：<br>s = <span class="hljs-built_in">set</span>([(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">95</span>), (<span class="hljs-string">&#x27;Lisa&#x27;</span>, <span class="hljs-number">85</span>), (<span class="hljs-string">&#x27;Bart&#x27;</span>, <span class="hljs-number">59</span>)])<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>	<span class="hljs-built_in">print</span> (x[<span class="hljs-number">0</span>],<span class="hljs-string">&#x27;:&#x27;</span>,x[<span class="hljs-number">1</span>])<br>&gt;&gt;&gt;	Lisa : <span class="hljs-number">85</span><br>	Adam : <span class="hljs-number">95</span><br>	Bart : <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure>

<p>增加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">通过add和remove来添加、删除元素（保持不重复），<br>添加元素时，用<span class="hljs-built_in">set</span>的add()方法：<br>	s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>	s.add(<span class="hljs-number">4</span>)    <span class="hljs-comment">#增加    </span><br>    s.remove(<span class="hljs-number">4</span>)	<span class="hljs-comment">#删除</span><br>不能直接修改    <br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>)<br>b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;cdef&#x27;</span>)<br>x = a &amp; b  <span class="hljs-comment">#交集</span><br>y = a | b  <span class="hljs-comment">#合集</span><br>z = a - b  <span class="hljs-comment">#相对补集，差集</span><br></code></pre></td></tr></table></figure>

<p>总结</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、<span class="hljs-built_in">list</span>、<span class="hljs-built_in">tuple</span>是有序列表；<span class="hljs-built_in">dict</span>、<span class="hljs-built_in">set</span>是无序列表<br><span class="hljs-number">2</span>、<span class="hljs-built_in">list</span>元素可变、<span class="hljs-built_in">tuple</span>元素不可变<br><span class="hljs-number">3</span>、<span class="hljs-built_in">dict</span>和<span class="hljs-built_in">set</span>的key值不可变，唯一性<br><span class="hljs-number">4</span>、<span class="hljs-built_in">set</span>只有key没有value<br><span class="hljs-number">5</span>、<span class="hljs-built_in">set</span>的用途：去重、并集、交集等<br><span class="hljs-number">6</span>、<span class="hljs-built_in">list</span>、<span class="hljs-built_in">tuple</span>：+、*、索引、切片、检查成员等<br><span class="hljs-number">7</span>、<span class="hljs-built_in">dict</span>查询效率高，但是消耗内存多；<span class="hljs-built_in">list</span>、<span class="hljs-built_in">tuple</span>查询效率低、但是消耗内存<br></code></pre></td></tr></table></figure>

<h2 id="基础杂项"><a href="#基础杂项" class="headerlink" title="基础杂项"></a>基础杂项</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>当全局变量和局部变量命名冲突时，局部变量优先</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">函数中直接修改是修改<span class="hljs-string">&#x27;局部变量&#x27;</span><br>	想要修改全局需要加上 <span class="hljs-keyword">global</span>声明<br>a = <span class="hljs-number">100</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>()<br>    <span class="hljs-keyword">global</span> a	<span class="hljs-comment">#声明以下代码中的a都使用全局变量</span><br>    a = <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure>

<h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;1010&quot;</span>,<span class="hljs-number">2</span>))	<span class="hljs-comment">#2转10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;140&quot;</span>,<span class="hljs-number">8</span>))		<span class="hljs-comment">#8转10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;60&quot;</span>,<span class="hljs-number">16</span>))		<span class="hljs-comment">#16转10</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">8</span>))			<span class="hljs-comment">#10转8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">17</span>))			<span class="hljs-comment">#19转16</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">10</span>))			<span class="hljs-comment">#10转2</span><br>&gt;&gt;&gt;<span class="hljs-number">0o10</span><br>&gt;&gt;&gt;<span class="hljs-number">0x11</span><br>&gt;&gt;&gt;<span class="hljs-number">0b1010</span>	<span class="hljs-comment">#前两位告诉属于什么数据类型</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(str1))	<span class="hljs-comment">#将一个字母转化为ASCII码表对应数字值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(c))		<span class="hljs-comment">#将数字转化为ASCII码表对应字母值</span><br></code></pre></td></tr></table></figure>

<h3 id="可变类型和不可变类型"><a href="#可变类型和不可变类型" class="headerlink" title="可变类型和不可变类型"></a>可变类型和不可变类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">不可变：Number 数字， String 字符串 ，<span class="hljs-type">Tuple</span> 元组 <span class="hljs-comment">#内容不可变</span><br><br>可变：<span class="hljs-type">Set</span> 集合 ，<span class="hljs-type">List</span> 列表 ，<span class="hljs-type">Dict</span> 字典<br><span class="hljs-string">&#x27;集合可变是指，可以进行集合运算（交，并，差）</span><br><span class="hljs-string">&#x27;</span>字典一半可变，只value值可变<br></code></pre></td></tr></table></figure>

<h3 id="python同时输入两个数"><a href="#python同时输入两个数" class="headerlink" title="python同时输入两个数"></a>python同时输入两个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">if</span> a &gt; b :<br>        <span class="hljs-built_in">max</span> = a<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">max</span> = b<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">max</span>)<br><br>a,b = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入两个数字&quot;</span>).split()   ; <span class="hljs-string">&#x27;&#x27;&#x27;同时输入两个数 split拆分字符串&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))     <span class="hljs-comment">#此时接收的数为str类型</span><br><span class="hljs-string">&#x27;&#x27;&#x27;想要输入数仍为int  map函数&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># a,b = map(int, input(&quot;俩数&quot;).split())</span><br>c = <span class="hljs-built_in">max</span>(a,b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两者中较大的是%d &quot;</span>% c)<br></code></pre></td></tr></table></figure>

<p>用map( ) ， split( )以及input( ) 可以实现用input( )同时输入多个数。</p>
<p>1.map( )<br>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p>
<p>2.split( )<br>拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）</p>
<p>3.map(function,input(“以空格分开”).split())<br>由于input( )输出的是用空格分开的字符串，split( )会分割开各个值并放到列表中，此时在列表中的值是字符串，如果要用于运算必须在map( )中利用int( )或者float( )等处理，再赋值。如果需要赋值的值都是字符串的话就没必要用map函数了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a,b =<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;输入a,b空格隔开:&#x27;</span>).split()<br><span class="hljs-comment">#此时a,b为str型</span><br>a,b =<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;输入a,b空格隔开:&#x27;</span>).split())<br><span class="hljs-comment">#此时a,b为int型</span><br></code></pre></td></tr></table></figure>







<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>python 函数 </p>
<p>1、概念：</p>
<p>​	 在数学领域，函数是一种关系，这种关系使一个集合里的 每一个元素对应 到另一个集合里的唯一元素。 y&#x3D; f(x) </p>
<p>计算机的函数，是一个固定的一个程序段，或称其为一个子程序</p>
<p>2、作用：函数是组织好的，可重复使用的，用来实现单一或相关联功能的代码段</p>
<p>3、分类： 内置函数，标准库函数，用户自定义函数</p>
<h2 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h2><p>官方手册地址： <a href="https://docs.python.org/zh-cn/3/">https://docs.python.org/zh-cn/3/</a></p>
<p>所有的库函数都可以先 import 库名 </p>
<p>然后通过 dir(库名) 查看该模块下的所有内置方法</p>
<ol>
<li><p>os	操作系统</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span>	os<br>os.getcwd()			<span class="hljs-comment">#返回当前的工作目录</span><br>	<span class="hljs-built_in">print</span>(os.getcwd)	<span class="hljs-comment">#查看程序所在的绝对路径目录</span><br><br>os.system(<span class="hljs-string">&quot;mkdir today&quot;</span>)	<span class="hljs-comment">#执行系统命令</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>sys  解释器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys			<span class="hljs-comment">#解释器powershell</span><br><span class="hljs-built_in">print</span>(sys.argv)	<span class="hljs-comment">#在解释器中执行命令，argv获取后面传递的参数</span><br>				<span class="hljs-string">&#x27;在程序中获取命令行所传递的参数&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>math  数学运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>math.fabs(-<span class="hljs-number">0.03</span>) <span class="hljs-comment">#返回x的绝对值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>re  正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re <span class="hljs-comment">#正则表达式的库 * 任意长度字符 ？ 一个字符长度</span><br>re.findall(<span class="hljs-string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="hljs-string">&#x27;which foot or hand fellfastest&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h2><p>三要素：定义，调用，返回值</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>语法：<br>def 函数名（形参数列表）:<br>&lt;缩进&gt;函数体</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>()：					<span class="hljs-comment">#函数定义</span><br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello show1!!&quot;</span>)<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello show2!!&quot;</span>)<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello show3!!&quot;</span>)<br>    <br>show() 						<span class="hljs-comment">#函数调用</span><br></code></pre></td></tr></table></figure>

<p>注意：函数名称必须符合命名规范，<br>     1、不要和关键字冲突<br>     2、不能用数字开头<br>     3、只能是数字，字母，下划线组成</p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>调用函数之前，必须先定义函数<br><span class="hljs-number">2.</span>内置函数对象会自动创建。例如：<span class="hljs-built_in">str</span>,python启动后都创建好了<br><span class="hljs-number">3.</span>标准库和第三方库函数，通过<span class="hljs-keyword">import</span>导入模块时，会执行模块中的<span class="hljs-keyword">def</span>语句<br><span class="hljs-number">4.</span>自定义函数可以在<span class="hljs-string">&#x27;定义位置以下&#x27;</span>任意位置调用，单独调用要顶格书写<br></code></pre></td></tr></table></figure>

<p>特殊情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(): <span class="hljs-comment">#这是定义函数test1()</span><br>	test()  <span class="hljs-comment">#函数test1()中调用了test()，此时函数test()还没有定义，</span><br>			<span class="hljs-comment">#不过没关系，因为这里只是定义函数test1()，</span><br> 			<span class="hljs-comment">#只要在调用test1()的地方之前定义了test()函数就可以！！！</span><br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(): <span class="hljs-comment">#这是定义函数test()</span><br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br><br>test1() <span class="hljs-comment">#这里是调用函数test1()的语句，只要在这句之前定义了test()，</span><br> 		<span class="hljs-comment">#程序就不会报错！！</span><br></code></pre></td></tr></table></figure>

<h3 id="函数参数与返回值"><a href="#函数参数与返回值" class="headerlink" title="函数参数与返回值"></a>函数参数与返回值</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ol>
<li><p>传不可变对象实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ChangeInt</span>(<span class="hljs-params"> a </span>):<br>	a = <span class="hljs-number">10</span>  <span class="hljs-comment">#修改仅限于函数内部</span><br><br>b = <span class="hljs-number">2</span><br>ChangeInt(b)<br><span class="hljs-built_in">print</span>(b) 		<span class="hljs-comment"># 结果仍是2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>传可变对象实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">changeme</span>(<span class="hljs-params"> mylist </span>): <span class="hljs-comment">#修改传入的列表</span><br>	mylist.append([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])	<span class="hljs-comment">#追加</span><br>	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;函数内取值: &quot;</span>, mylist)<br>	<span class="hljs-keyword">return</span><br><br><span class="hljs-comment"># 调用changeme函数</span><br>mylist = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br>changeme( mylist )<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;函数外取值: &quot;</span>, mylist)	<span class="hljs-comment">#函数内修改函数外也能访问</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>默认参数</p>
<p>调用函数时，如果没有传递参数，则会使用默认参数。 以下实例中如果没有传入 age 参数，则使用默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> name, age = <span class="hljs-number">30</span> </span>):<br>	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;名字: &quot;</span>, name)<br>	<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;年龄: &quot;</span>, age)<br>	<span class="hljs-keyword">return</span><br><span class="hljs-string">&#x27;&#x27;&#x27;注意：默认值只能从函数的参数 右边向左边 依次给默认值</span><br><span class="hljs-string">		不能从左向右，或者跳参数赋值。&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaochen&quot;</span>)<br><span class="hljs-built_in">print</span>(age = <span class="hljs-number">19</span>,name = <span class="hljs-string">&#x27;xiaochen&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;调用时传递参数，按形参顺序给值，乱序需要指明具体形参&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>不定长参数</p>
<p>函数需要处理比当初声明时更多的参数，这些参数叫做不定长参数</p>
<p>加单星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> arg1, *vartuple </span>): 	<span class="hljs-comment">#单* 元组</span><br>	<span class="hljs-built_in">print</span> (arg1)			<br>	<span class="hljs-built_in">print</span> (vartuple)<br> <br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>)<br>&gt;&gt;&gt;<span class="hljs-number">70</span><br>&gt;&gt;&gt;(<span class="hljs-number">60</span>,<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure>

<p>加了两个星号 ** 的参数会以字典的形式导入 注意事项：双星号的位置参数必须保证是字典形式，否则解释错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> arg1, **vardict </span>):	<span class="hljs-comment">#双** 传字典</span><br>	<span class="hljs-built_in">print</span> (arg1)<br>	<span class="hljs-built_in">print</span> (vardict)<br><br>printinfo(<span class="hljs-number">1</span>, a=<span class="hljs-number">2</span>,b=<span class="hljs-number">3</span>) 		<span class="hljs-comment">#注意参数形式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>函数返回值</p>
<p>return [表达式] 语句用于退出函数</p>
<p>如果函数体中包含return语句，则结束函数执行并返回值</p>
<p>如果函数体中不包含return语句，则返回None值</p>
<p>要返回多个返回值，使用列表、元组、字典、集合将多个值“存起来”即可</p>
<p>注：函数一次返回多个结果时，是以元组的形式返回的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>()<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;aaa&quot;</span>)<br>	<span class="hljs-keyword">return</span>			<span class="hljs-comment">#不写return 或者光写return 都是返回None</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test03</span>():<br>    msg=<span class="hljs-string">&#x27;我要返回多个值&#x27;</span><br>    <span class="hljs-built_in">print</span>(msg)<br>    <span class="hljs-keyword">return</span> msg,<span class="hljs-string">&quot;hello xiaozhu&quot;</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br>t3=test03()<br><span class="hljs-built_in">print</span>(t3)<br><br>&gt;&gt;&gt;(<span class="hljs-string">&#x27;我要返回多个值&#x27;</span>, <span class="hljs-string">&#x27;hello xiaozhu&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment">#注：函数一次返回多个结果时，是以元组的形式返回的(不确定具体类型)</span><br></code></pre></td></tr></table></figure>

<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>函数调用函数自己本身，递归操作</p>
</li>
<li><p>求一个数n的阶乘</p>
<p>f(n) &#x3D; n * (n - 1) * (n - 2)…. *2 * 1</p>
<p>或</p>
<p>f( n ) &#x3D; n * f (n -1)</p>
</li>
<li><p>斐波那契数列</p>
<p>前两项之和等于第三项，从第三列开始</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Fibonacci</span>(<span class="hljs-params">n</span>):<br><span class="hljs-keyword">if</span>	n == <span class="hljs-number">1</span>:		<span class="hljs-comment">#边界条件 必须有这种结束位置</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> n == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">elif</span> n &gt;= <span class="hljs-number">2</span>:<br>	<span class="hljs-keyword">return</span> FiBonacci(n- <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">list</span> =[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> i ==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> i ==<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">list</span>.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">list</span>.append(<span class="hljs-built_in">list</span>[i-<span class="hljs-number">2</span>]+<span class="hljs-built_in">list</span>[i-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>python 模块概念<br>1、Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python函数语句。<br>2、模块能定义函数，类和变量，模块里也能包含可执行的代码。<br>3、每个模块都是一个独立的名称空间</p>
<p>模块分三种</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>、内置模块(又称标准库)<br>	执行help(&#x27;modules&#x27;)查看所有Python自带模块列表<br><span class="hljs-number">2</span>、第三方开源模块，可通过 pip install 模块名（互联网安装）<br><span class="hljs-number">3</span>、自定义模块<br></code></pre></td></tr></table></figure>

<h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#第一种导入</span><br><span class="hljs-keyword">import</span> module[,module1,module2 ...] <span class="hljs-comment"># 引入模块如果有多个用&quot;,&quot;隔开</span><br><span class="hljs-string">&#x27;&#x27;&#x27;路径为工程绝对路径，module需要加上文件名&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>Python查找模块顺序：</p>
<ol>
<li>在当前目录，即当前执行的程序文件所在目录下查找；</li>
<li>到 PYTHONPATH（环境变量）下的每个目录中查 找； </li>
<li>到 Python 默认的安装目录下查找</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#第二种导入：</span><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 函数名		<span class="hljs-comment">#导入模块的一部分</span><br><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> name1[, name2[, ... nameN]]<br></code></pre></td></tr></table></figure>

<p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中 </p>
<p>​	这个声明不会把整个模块导入到当前的命名空间中， </p>
<p>​	它只会将 fib 里的 name1 单个引入到执行这个声明的模块的全局符号表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#第三种导入：</span><br><span class="hljs-keyword">import</span> 模块名 <span class="hljs-keyword">as</span> 新名字<br>相当于给导入的模块名称重新起一个别名，便于记忆，方便地在程序中调用<br></code></pre></td></tr></table></figure>

<p>使用模块</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">模块名.函数名()		<span class="hljs-meta">#在当前代码中调用模块函数</span><br></code></pre></td></tr></table></figure>

<h2 id="内置模块使用"><a href="#内置模块使用" class="headerlink" title="内置模块使用"></a>内置模块使用</h2><ol>
<li><p>datetime是Python中处理日期和时间的标准模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime <br><br>now = datetime.now()	<span class="hljs-comment">#获取当前实时datetime，可以测试性能</span><br>dt = datetime(<span class="hljs-number">2021</span>,<span class="hljs-number">10</span>,<span class="hljs-number">31</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>) <span class="hljs-comment">#用指定日期时间创建datetime</span><br><span class="hljs-string">&#x27;&#x27;&#x27;数字转换为datetime类型&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment">#str转换为datetime</span><br>datee_test = datetime.strptime(<span class="hljs-string">&#x27;2018-06-19 13:15:00&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br><br><span class="hljs-comment">#datetime转换为str</span><br>now = datetime.now()<br><span class="hljs-built_in">print</span>(now.strftime(<span class="hljs-string">&#x27;%a, %b %d %H:%M&#x27;</span>))<br>• %a 本地简化星期名称<br>• %b 本地简化的月份名称<br>• %H <span class="hljs-number">24</span>小时制小时数（<span class="hljs-number">0</span>-<span class="hljs-number">23</span>）<br>• %M 分钟数（<span class="hljs-number">00</span>-<span class="hljs-number">59</span>）<br></code></pre></td></tr></table></figure>
</li>
<li><p>sys 解释器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sys.argv)):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;argv&#123;0&#125;: type is &#123;1&#125;, value is&#123;2&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i, <span class="hljs-built_in">type</span>(sys.argv[i]), sys.argv[i])<br>      <span class="hljs-comment">#sys获取命令行参数</span><br>在命令行下运行该脚本，并提供几个参数<br>python argv_test.py <span class="hljs-number">1</span> a <span class="hljs-number">2</span> b <span class="hljs-number">3</span> c`<br></code></pre></td></tr></table></figure>
</li>
<li><p>python的休眠函数sleep</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Start : %s&quot;</span> % time.ctime())  <span class="hljs-comment">#获取当前时间</span><br>time.sleep( <span class="hljs-number">5</span> ) <span class="hljs-comment">#休眠5秒钟，单位秒</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;End : %s&quot;</span> % time.ctime())<br><span class="hljs-comment">#保证循环时不空转</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>python 的暂停动作,程序在该位置会处于睡眠状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-comment">#当再次按下 enter键的时候程序恢复运行</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><p>1、在同一文件夹下模块函数调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A.py文件：<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x + y = %d&quot;</span>% (x+y))<br>B.py文件：<br><span class="hljs-keyword">import</span> A<br>A.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>或<br><span class="hljs-keyword">from</span> A <span class="hljs-keyword">import</span> add<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<p>2、在同一文件夹下模块类调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A.py文件:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,xx,yy</span>):<br>        self.x=xx<br>        self.y=yy<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x和y的和为：%d&quot;</span>%(self.x+self.y))<br><br>B.py文件调用：<br><span class="hljs-keyword">from</span> A <span class="hljs-keyword">import</span> A<br>a=A(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)	<span class="hljs-comment">#构造</span><br>a.add()		<span class="hljs-comment">#调用成员函数</span><br>或<br><span class="hljs-keyword">import</span> A<br>a=A.A(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>a.add()<br><br></code></pre></td></tr></table></figure>

<p>3、在不同文件夹下模块调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;不在同一目录下，无法直接导入&#x27;&#x27;&#x27;</span><br>mod_add.py文件的文件路径：E:\<br><br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">r&quot;E:\\&quot;</span>)  <span class="hljs-comment">#将其路径添加到环境变量里，r使转义字符无效</span><br><br><span class="hljs-keyword">import</span> mod_add		<span class="hljs-comment">#间接导入</span><br>n = mod_add.add(<span class="hljs-number">14</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(n)<br>mod_add.show()<br><br>拷贝文件到系统安装路径下，不需要导入，直接使用<br><span class="hljs-string">&#x27;&#x27;&#x27;将要导入的模块，复制到Python中lib文件里,D:\Python\Lib&#x27;&#x27;&#x27;</span><br><br>python <span class="hljs-keyword">import</span>模块时， 是在sys.path里按顺序查找的。<br>sys.path是一个列表，里面以字符串的形式存储了许多路径。<br>使用A.py文件中的函数需要先将他的文件路径放到sys.path中<br><br></code></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>模块的升级版：包</p>
<p>包的概念：把许多个模块按照功能放到不同的目录中来组织模块</p>
<p>​		这些组织存放模块文件的目录，我们称之为包。</p>
<p>​		包只是模块的一种形式而已，包的本质也是一种模块。</p>
<pre><code class="hljs">     一个包含\__init__.py文件的目录，
</code></pre>
<p>​		创建包的目的不是为了运行，而是被导入使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">__init__.py 文件的作用<br>在每一个包目录下，都应该有一个 __init__.py 文件，<br><span class="hljs-string">&#x27;若这个文件不存在，那么这个目录只是一个目录而不是一个包&#x27;</span><br>__init__.py 文件可以是空文件，也可以有 Python 代码，原则是尽量保持__init__.py 文件的精简~<br></code></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">导入包的语句如下：<br><span class="hljs-keyword">import</span> package <br>引入包下的某一个模块<br><span class="hljs-keyword">from</span> package <span class="hljs-keyword">import</span> module<br></code></pre></td></tr></table></figure>

<p>1、新建一个包文件<br>2、在该包文件下新建多个模块文件 test1.py test2.py<br>3、在包下的模块文件中分别编写函数或者类<br>4、在包同一级别的位置新建一个测试模块 test.py<br>5、在测试模块中引入包 	from 包 import 模块   或者 from 包.模块 import 函数<br>6、在测试模块中使用包中函数和变量</p>
<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><h3 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h3><ol>
<li><p>命令提示符安装：</p>
<p>cmd中，pip	–version 查看是否有pip工具，没有则需要安装</p>
<p><a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a> 获取python get-pip.py,</p>
<p>切到D盘，通过python	get-pip.py 命令直接安装</p>
</li>
<li><p>pip命令使用（在cmd中执行，没有进入python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&gt; pip install &lt;包名&gt; 		<span class="hljs-comment"># 安装最新版</span><br>&gt; pip uninstall &lt;包名&gt; 	<span class="hljs-comment">#卸载Python包</span><br><br>&gt; pip install -v &lt;包名&gt;==&lt;verison&gt; 	<span class="hljs-comment"># 安装指定版本</span><br>&gt; python -m pip install &lt;包名&gt; 		<span class="hljs-comment"># 安装最新版</span><br>&gt; pip search &lt;包名&gt;					<span class="hljs-comment">#搜索包</span><br>&gt; pip install --upgrade &lt;包名&gt; 		<span class="hljs-comment">#升级包到最新版本</span><br><br>&gt; pip <span class="hljs-built_in">list</span> 				 <span class="hljs-comment">#列出已经安装的Python包</span><br>&gt; pip show &lt;包名&gt; 		<span class="hljs-comment">#查看某个包的信息</span><br>&gt; pip show --files &lt;包名&gt; <span class="hljs-comment">#查看某个包下的文件</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>需要安装的库</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">lxml <span class="hljs-keyword">BeautifulSoup4 </span>urllib3 requests <span class="hljs-keyword">jieba </span>pyqt5 <span class="hljs-keyword">scapy</span><br></code></pre></td></tr></table></figure>

<p>pip 缓存位置：C: \Users\Administrator\AppData\Local\pip\cache</p>
<p>pip 安装位置：D:\Python\Lib\site-packages</p>
</li>
</ol>
<h3 id="pycharm-安装模块"><a href="#pycharm-安装模块" class="headerlink" title="pycharm 安装模块"></a>pycharm 安装模块</h3><p>file–》setting –》project untitled –&gt;project InterPreter<br>有一个加号 单击进入 在最上面的搜索栏输入要安装的包名<br>左下角 install Package 安装<br>如果安装过程失败或者速度很慢，可以考虑修改数据来源地址<br>左下角 Manage Repositories（管理仓库）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">清华：https:<span class="hljs-regexp">//</span>pypi.tuna.tsinghua.edu.cn/simple<br>阿里：http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/pypi/</span>simple/<br>豆瓣：http:<span class="hljs-regexp">//</span>pypi.douban.com<span class="hljs-regexp">/simple/</span><br>华中理工大学：http:<span class="hljs-regexp">//</span>pypi.hustunique.com/<br>山东理工大学：http:<span class="hljs-regexp">//</span>pypi.sdutlinux.org/<br>中国科学技术大学：http:<span class="hljs-regexp">//</span>pypi.mirrors.ustc.edu.cn/<br><br>官方： https:<span class="hljs-regexp">//</span>pypi.python.org/simple<br></code></pre></td></tr></table></figure>







<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>python 文件操作： 原因：数据持久化存储</p>
<p>不论那种语言，对于文件的操作都有如下基本流程：<br>打开文件 &#x3D;&#x3D;》读写(定位)文件 &#x3D;&#x3D;》关闭文件<br>open() 												close()</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>打开文件时，需要指定文件路径和以何等方式打开文件，<br>打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。<br>Python使用内置的open()函数打开一个文件，并且返回一个文件对象，也叫句柄(handle)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>) 	<span class="hljs-comment"># 在本文件夹下面的一个文件</span><br>没有文件：<br>异常： No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;test.txt“</span><br><span class="hljs-string">有文件：</span><br><span class="hljs-string">正常： &lt;_io.TextIOWrapper name=&#x27;</span>test.txt<span class="hljs-string">&#x27; mode=&#x27;</span><span class="hljs-string">r&#x27;encoding=&#x27;</span>cp936<span class="hljs-string">&#x27;&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;C:/Pf = open(&quot;</span>C:/Python33/README.txt<span class="hljs-string">&quot;) # 全路径</span><br><span class="hljs-string">f = open(r&quot;</span>C:\Python\Lib\ctypes\test\test_anon.py<span class="hljs-string">&quot;)&quot;</span>)<br>         r 转义字符无效，<span class="hljs-string">&#x27;/&#x27;</span>和<span class="hljs-string">&#x27;r+\&#x27; 相同</span><br></code></pre></td></tr></table></figure>



<p>注意有时候，打开文件时，我们需要指定文件打开的模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment">#默认 只读 必须存在</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-comment">#只写 创建 清空功能 慎重使用</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">#追加 创建</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">所有的模式如下：常用模式<br>| r | 文本模式，读取 默认模式 ，r 这种应该在后面注明编码格式<br>			如encode=‘UTF-<span class="hljs-number">8</span>’|<br>| rb | 二进制模式，读取，不能指定编码格式 |<br>| w | 文本模式，写入 |<br>| wb | 二进制模式，写入 |<br>| a | 文本模式，追加 |<br>| ab | 二进制模式，追加 |<br>| + | 可读可写 |<br>r+ rb+ w+ wb+ a+ ab+   <span class="hljs-comment">#&quot;+&quot;增加写入功能</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Xle3Ywp7bcifhDo.png" alt="image-20211031170407552"></p>
<p>打开文件的类型主要有两种:</p>
<ol>
<li>ASCII文件（文本文件），用文本编辑器可以直接打开阅读</li>
<li>二进制文件（图片，视频，音频），不能用文本编辑器打开读写</li>
</ol>
<p>注意事项</p>
<p>1.编码问题 		(指定编码是其在liunx也可查看)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">windows 向 liunx 转换 <br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,mode=<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>) 对<br>	<span class="hljs-comment">#文本文件才有可能需要编码</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;text.bin&quot;</span>,mode=<span class="hljs-string">&quot;rb&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>) 错<br>	<span class="hljs-comment">#二进制文件不需要指定编码</span><br>否则会报出异常：binary mode doesn<span class="hljs-string">&#x27;t take an encoding</span><br><span class="hljs-string">argument</span><br></code></pre></td></tr></table></figure>

<p>2.读取非UTF-8编码的文本文件，需要给open()函数传入 encoding参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">liunx 向 windows转化<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/gbk.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>f.read()<br></code></pre></td></tr></table></figure>

<p>3.遇到有些编码不规范的文件，你可能会遇到 UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。<br>遇到这种情况，open() 函数还接收一个errors参数， 表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/gbk.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>,errors=<span class="hljs-string">&#x27;ignore&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h2><p>文件关闭： f.close()    —-打开文件后要记得关闭</p>
<p>官方建议： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>		do_something()<br>使用这种用法，我们不必调用close()方法，在<span class="hljs-keyword">with</span>语句程序内部就会执行，无论内部是否出现异常<br><span class="hljs-comment">#超出作用域范围就会自动关闭,减少内存浪费</span><br></code></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>以文本方式写入的文件，建议指定编码</p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>write()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f.write(<span class="hljs-string">&quot;hello world&quot;</span>)		<span class="hljs-string">&#x27;&#x27;&#x27;写入一行数据&#x27;&#x27;&#x27;</span><br>		<span class="hljs-comment">#向目标文本文件写入一行字符串</span><br>		<span class="hljs-comment">#写入的内容是从文件开头位置开始,在一次操作中数据依次有效</span><br>		<span class="hljs-comment">#原来的文件内容保留，开头位置会被覆盖。</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;123&quot;</span>)<br>    f.wirte(<span class="hljs-string">&quot;456&quot;</span>)	<span class="hljs-comment">#在本次操作中数据依次有效</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">seq = [<span class="hljs-string">&quot;hello world 1\n&quot;</span>, <span class="hljs-string">&quot;nihao wohao 2&quot;</span>] <br>f.writelines( seq ) 	<span class="hljs-string">&#x27;&#x27;&#x27;写入多行数据&#x27;&#x27;&#x27;</span><br>		<span class="hljs-comment">#writelines()方法写入文件的字符串序列</span><br></code></pre></td></tr></table></figure>

<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>文件读操作：read()方法从文件读取指定的字节数，如果未给定或为负则读取所有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">ret = f.read() 	<span class="hljs-comment">#默认全部读出</span><br>ret = f.read(<span class="hljs-number">5</span>) <span class="hljs-comment">#从文件开头读出指定长度字符</span><br></code></pre></td></tr></table></figure>

<p>readline()	读取一行数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">ret = f.readline()	<span class="hljs-comment">#读取一行</span><br></code></pre></td></tr></table></figure>

<p>readlines() 读取多行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">ret = f.readlines() <span class="hljs-comment">#将文件所有行构成列表</span><br><span class="hljs-string">&#x27;&#x27;&#x27;返回的是一个列表，但是当数据较大时，这样的用法会很占用内存&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="文件遍历操作"><a href="#文件遍历操作" class="headerlink" title="文件遍历操作"></a>文件遍历操作</h3><p>1、逐行读取一个文本文件，并且在每一行的最后加上一个逗号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> Ture:<br>	ret = f.readline() <span class="hljs-comment">#读一行</span><br>	<span class="hljs-keyword">if</span> ret == <span class="hljs-string">&quot;&quot;</span>: 		<span class="hljs-comment">#判断结尾</span><br>		<span class="hljs-keyword">break</span><br>	<span class="hljs-built_in">print</span>(ret.strip(<span class="hljs-string">&quot; &quot;</span>) + <span class="hljs-string">&quot;,&quot;</span>)  <span class="hljs-comment">#strip将结尾换行符换为&quot; &quot; </span><br></code></pre></td></tr></table></figure>

<p>2、遍历输出指定目录下的所有目录和普通文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(<span class="hljs-string">&quot;../&quot;</span>):<br>	<span class="hljs-built_in">print</span>(root) <span class="hljs-comment">#当前目录路径</span><br>	<span class="hljs-built_in">print</span>(dirs)	<span class="hljs-comment">#当前路径下所以子目录</span><br>	<span class="hljs-built_in">print</span>(files) <span class="hljs-comment">#当前路径下所以非子目录文件</span><br></code></pre></td></tr></table></figure>



<h3 id="文件定位操作"><a href="#文件定位操作" class="headerlink" title="文件定位操作"></a>文件定位操作</h3><p>解决问题：一个文件写完后不能直接读？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>,<span class="hljs-string">&#x27;r+&#x27;</span>) <span class="hljs-keyword">as</span> f:       <br>    f.write(<span class="hljs-string">&quot;caopb 123456\n&quot;</span>)<br>    f.writelines(seq)<br>    ret = f.read()<br>    <span class="hljs-built_in">print</span>(ret)		<span class="hljs-comment">#读不到内容，文件指针位于写操作内容之后</span><br>    <br>    <span class="hljs-built_in">print</span>(f.tell()) <span class="hljs-comment">#会将文件指针距离文件开头的字节数打印出来</span><br>    f.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)	<span class="hljs-comment">#从文件开头偏移0字节 == 将指针定位到文件开头位置</span><br></code></pre></td></tr></table></figure>

<p>tell() 方法用于获取文件当前指针距离文件开头位置<br>seek() 方法用于移动文件读取指针到指定位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f.seek(offset[, whence])<br>其中：<br>	offset -- 开始的偏移量，也就是代表需要移动偏移的字节数<br>	offset &gt;<span class="hljs-number">0</span> 向文件末尾偏移<br>	offset &lt;<span class="hljs-number">0</span> 向文件开头偏移<br><br>	whence：可选，默认值为 <span class="hljs-number">0</span>。<br>	给offset参数一个定义，表示要从哪个位置开始偏移；<br>	<span class="hljs-number">0</span>代表从文件开头开始算起，<br>	<span class="hljs-number">1</span>代表从当前位置开始算起，<span class="hljs-comment">#b模式打开</span><br>	<span class="hljs-number">2</span>代表从文件末尾算起	<span class="hljs-comment">#要用b模式打开</span><br><br>seek()函数报错：can<span class="hljs-string">&#x27;t do nonzero end-relativeseeks</span><br><span class="hljs-string">	在文本文件中，没有使用b模式选项打开的文件，只允许从文件头开始计算相对位置，从文件尾计算时就会引发异常。</span><br></code></pre></td></tr></table></figure>

<h3 id="文件重命名，删除，创建"><a href="#文件重命名，删除，创建" class="headerlink" title="文件重命名，删除，创建"></a>文件重命名，删除，创建</h3><p>引入标准库函数os</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os 	导入os函数<br><span class="hljs-comment">#os 模块中的 rename()可以完成对文件的重命名操作</span><br>os.rename(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test2.txt&quot;</span>) <br><span class="hljs-comment">#os 模块中的 remove()可以完成对文件的删除操作		</span><br>os.remove(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br>os.mkdir(<span class="hljs-string">&quot;张三&quot;</span>) 	<span class="hljs-comment">#创建文件夹(目录)</span><br>os.rmdir(<span class="hljs-string">&quot;李四&quot;</span>)	<span class="hljs-comment">#删除空文件夹</span><br><br>os.listdir(<span class="hljs-string">&#x27;./&#x27;</span>)	<span class="hljs-comment">#获取目录列表</span><br>	<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(os.listdir()) 将当前目录储存为列表形式输出<br>    <span class="hljs-number">2.</span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> os.listdir()<br>    	<span class="hljs-built_in">print</span>(x)<br><br>os.chdir(<span class="hljs-string">&quot;../&quot;</span>) <span class="hljs-comment">#改变默认工作目录</span><br><br>path = os.path.splitext(path)	分割路径中的文件名与拓展名<br><span class="hljs-comment">#将文件名和后缀以元组形式储存   path[0]文件名，path[1 ]后缀名</span><br></code></pre></td></tr></table></figure>

<h2 id="XLS-读写"><a href="#XLS-读写" class="headerlink" title="XLS 读写"></a>XLS 读写</h2><p>excel文件的操作：</p>
<p>Python中xlrd和xlwt模块使用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">xlrd模块实现对excel文件内容读取，<br>xlwt模块实现对excel文件内容写入<br><br><span class="hljs-comment">#需要安装这两个第三方模块</span><br>pip install xlrd<br>pip install xlwt<br></code></pre></td></tr></table></figure>

<h3 id="写操作-1"><a href="#写操作-1" class="headerlink" title="写操作"></a>写操作</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、导入模块<br>　 　<span class="hljs-keyword">import</span> xlwt<br><span class="hljs-number">2</span>、创建workbook（其实就是excel，后来保存一下就行）<br>　 　 workbook = xlwt.Workbook(encoding = <span class="hljs-string">&#x27;ascii&#x27;</span>)<br><span class="hljs-number">3</span>、创建表的sheet<br>　 　 worksheet = workbook.add_sheet(<span class="hljs-string">&#x27;My Worksheet&#x27;</span>)<br><span class="hljs-number">4</span>、往单元格内写入内容<br>		 ***.write(行,列,labal = 内容)<br>　 　 worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, label = <span class="hljs-string">&#x27;Row 0, Column 0 Value&#x27;</span>)<br><span class="hljs-number">5</span>、保存<br>　 　 workbook.save(<span class="hljs-string">&#x27;Excel_Workbook.xls&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="优化操作"><a href="#优化操作" class="headerlink" title="优化操作"></a>优化操作</h4><p>1.带样式写入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt<br><br>workbook = xlwt.Workbook(encoding = <span class="hljs-string">&#x27;ascii&#x27;</span>)<br>worksheet = workbook.add_sheet(<span class="hljs-string">&#x27;My Worksheet&#x27;</span>)<br><br>style = xlwt.XFStyle() 	<span class="hljs-comment"># 初始化样式</span><br>font = xlwt.Font() 		<span class="hljs-comment"># 为样式创建字体</span><br>font.name = <span class="hljs-string">&#x27;Times New Roman&#x27;</span><br>font.bold = <span class="hljs-literal">True</span> 		<span class="hljs-comment"># 黑体</span><br>font.underline = <span class="hljs-literal">True</span> 	<span class="hljs-comment"># 下划线</span><br>font.italic = <span class="hljs-literal">True</span> 		<span class="hljs-comment"># 斜体字</span><br>style.font = font 		<span class="hljs-comment"># 设定样式</span><br><span class="hljs-comment"># 样式创建完成储存在style中，具体写入时调用</span><br><br>worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;没样式&#x27;</span>) <span class="hljs-comment"># 不带样式的写入</span><br>worksheet.write(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;有样式&#x27;</span>, style) <span class="hljs-comment"># 带样式的写入</span><br><br>workbook.save(<span class="hljs-string">&#x27;Excel_test.xls&#x27;</span>) <span class="hljs-comment"># 保存文件</span><br></code></pre></td></tr></table></figure>

<p>2、设置单元格宽度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">worksheet.col(<span class="hljs-number">0</span>).width = <span class="hljs-number">3333</span><br><span class="hljs-comment"># col(0) 0列的宽度 </span><br></code></pre></td></tr></table></figure>

<p>3、输入一个日期到单元格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime <span class="hljs-comment"># 引入datetime模块</span><br><br>style = xlwt.XFStyle()<br>style.num_format_str = <span class="hljs-string">&#x27;M/D/YY&#x27;</span><br><span class="hljs-comment"># Other options: D-MMM-YY, D-MMM, MMM-YY, h:mm, h:mm:ss, h:mm, h:mm:ss, M/D/YY h:mm, mm:ss, [h]:mm:ss, mm:ss.0</span><br>worksheet.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,datetime.adtetime.now(),style)<br></code></pre></td></tr></table></figure>

<p>4、向单元格添加一个公式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># 输入 5</span><br>worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 输入 2</span><br>worksheet.write(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, xlwt.Formula(<span class="hljs-string">&#x27;A1*B1&#x27;</span>)) <br>	<span class="hljs-comment"># 输出 &quot;10&quot; (A1[5] * A2[2])</span><br>worksheet.write(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, xlwt.Formula(<span class="hljs-string">&#x27;SUM(A1,B1)&#x27;</span>)) <br>	<span class="hljs-comment">#输出 &quot;7&quot; (A1[5] + A2[2])</span><br></code></pre></td></tr></table></figure>

<p>5、向单元格添加一个超链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, xlwt.Formula(<span class="hljs-string">&#x27;HYPERLINK(&quot;http://www.bilibil.com&quot;;&quot;bilibili&quot;)&#x27;</span>)) <br><span class="hljs-comment">#内容显示为bilibili，其中链接了一个网址</span><br><span class="hljs-comment">#如果没有分号后面内容，则直接显示一个可连接的网址</span><br></code></pre></td></tr></table></figure>

<p>6、合并行和列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 合并从0行到0行，从0列到1列</span><br>worksheet.write_merge(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;合并单元格&#x27;</span>,style)<br><span class="hljs-comment"># 合并从2行到4行，从0列到3列</span><br>worksheet.write_merge(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;合并单元格&#x27;</span>)<br><span class="hljs-string">&#x27;合并中不能有内容，是将小格子变大格子，并填充内容&#x27;</span><br></code></pre></td></tr></table></figure>

<p>7、设置单元格内容的对其方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">alignment = xlwt.Alignment() <span class="hljs-comment">#初始化Alignment</span><br>horz代表 水平 对齐方式，vert代表 垂直 对齐方式<br>alignment.horz = xlwt.Alignment.HORZ_CENTER  <span class="hljs-comment">#居中对齐(垂直方向上)</span><br> <span class="hljs-string">&#x27;&#x27;&#x27;May be:</span><br><span class="hljs-string">	HORZ_GENERAL, HORZ_LEFT, HORZ_CENTER, HORZ_RIGHT,</span><br><span class="hljs-string">	HORZ_FILLED, HORZ_JUSTIFIED,</span><br><span class="hljs-string">	HORZ_CENTER_ACROSS_SEL, HORZ_DISTRIBUTED&#x27;&#x27;&#x27;</span><br>alignment.vert = xlwt.Alignment.VERT_CENTER  <span class="hljs-comment">#居中对齐(水平方向上)</span><br> <span class="hljs-string">&#x27;&#x27;&#x27;May be:</span><br><span class="hljs-string">	VERT_TOP, VERT_CENTER, VERT_BOTTOM,</span><br><span class="hljs-string">	VERT_JUSTIFIED, VERT_DISTRIBUTED&#x27;&#x27;&#x27;</span><br>style = xlwt.XFStyle() <span class="hljs-comment">#初始化样式</span><br>style.alignment = alignment<br><br>worksheet.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;文本居中&#x27;</span>，style)<br><br>VERT_TOP			上端对齐<br>VERT_CENTER			居中对齐（垂直方向上）<br>VERT_BOTTOM			低端对齐<br>HORZ_LEFT			左端对齐<br>HORZ_CENTER			居中对齐（水平方向上）<br>HORZ_RIGHT			右端对齐<br></code></pre></td></tr></table></figure>

<p>8、为单元格添加边框</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt<br>workbook = xlwt.Workbook()<br>worksheet = workbook.add_sheet(<span class="hljs-string">&#x27;My Sheet&#x27;</span>)<br>borders = xlwt.Borders() <span class="hljs-comment"># Create Borders</span><br>borders.left = xlwt.Borders.THIN<br><span class="hljs-comment"># DASHED虚线</span><br><span class="hljs-comment"># NO_LINE没有</span><br><span class="hljs-comment"># THIN实线</span><br> <span class="hljs-string">&#x27;&#x27;&#x27;May be: </span><br><span class="hljs-string">	NO_LINE, THIN, MEDIUM, DASHED, DOTTED,THICK, </span><br><span class="hljs-string">	DOUBLE, HAIR, MEDIUM_DASHED,THIN_DASH_DOTTED,</span><br><span class="hljs-string">    MEDIUM_DASH_DOTTED,THIN_DASH_DOT_DOTTED, </span><br><span class="hljs-string">    MEDIUM_DASH_DOT_DOTTED,SLANTED_MEDIUM_DASH_DOTTED, </span><br><span class="hljs-string">    or 0x00 through 0x0D.&#x27;&#x27;&#x27;</span><br>borders.right = xlwt.Borders.THIN<br>borders.top = xlwt.Borders.THIN<br>borders.bottom = xlwt.Borders.THIN<br>borders.left_colour = <span class="hljs-number">0x40</span><br>borders.right_colour = <span class="hljs-number">0x40</span><br>borders.top_colour = <span class="hljs-number">0x40</span><br>borders.bottom_colour = <span class="hljs-number">0x40</span><br>style = xlwt.XFStyle() <span class="hljs-comment"># Create Style</span><br>style.borders = borders <span class="hljs-comment"># Add Borders to Style</span><br>worksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Cell Contents&#x27;</span>, style)<br>workbook.save(<span class="hljs-string">&#x27;Excel_Workbook.xls&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>9、为单元格设置背景色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt<br>workbook = xlwt.Workbook()<br>worksheet = workbook.add_sheet(<span class="hljs-string">&#x27;MY Sheet&#x27;</span>)<br>pattern = xlwt.Pattern()<br>pattern.pattern = xlwt.Pattern.SOLID_PATTERN<br>   <span class="hljs-comment"># May be:NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12</span><br>pattern.pattern_fore_colour = <span class="hljs-number">5</span><br><span class="hljs-string">&#x27;&#x27;&#x27; May be: 8 through 63. </span><br><span class="hljs-string">	0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, </span><br><span class="hljs-string">	5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, </span><br><span class="hljs-string">	17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow ,</span><br><span class="hljs-string"> 	almost brown), 20 = Dark Magenta, 21 = Teal, </span><br><span class="hljs-string">	22 = Light Gray, 23 = Dark Gray, the list goes on...&#x27;&#x27;&#x27;</span><br>style = xlwt.XFStyle()<br>style.pattern = pattern<br>worksheet.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;颜色&#x27;</span>，style)<br>workbooksave(<span class="hljs-string">&#x27;Excel_Workbook.xls&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="读操作-1"><a href="#读操作-1" class="headerlink" title="读操作"></a>读操作</h3><h4 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、导入模块<br>	<span class="hljs-keyword">import</span> xlrd<br><span class="hljs-number">2</span>、打开Excel文件读取数据<br>	data = xlrd.open_workbook(<span class="hljs-string">&#x27;Excel_test.xls&#x27;</span>) <br><span class="hljs-number">3</span>、 获取一个工作表<br>	table_sheet = data.sheets()[<span class="hljs-number">0</span>] <span class="hljs-comment">#通过索引顺序获取</span><br><span class="hljs-number">4</span>、获取单元格内容，三种方式都是同一个单元格。<br>	<span class="hljs-built_in">print</span>(table_sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).value)<br>	<span class="hljs-built_in">print</span>(table_sheet.cell_value(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) )<br>	<span class="hljs-built_in">print</span>(table_sheet.row(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].value )<br><span class="hljs-number">5</span>、 获取行数和列数<br>	nrows = table_sheet.nrows<br>	ncols = table_sheet.ncols<br><span class="hljs-comment"># 循环行列表数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nrows ):		<span class="hljs-comment">#获取所有数据</span><br>	<span class="hljs-built_in">print</span>(table_sheet.row_values(i))<br></code></pre></td></tr></table></figure>

<h4 id="优化操作-1"><a href="#优化操作-1" class="headerlink" title="优化操作"></a>优化操作</h4><p>1、打开excel文件获取所有sheet</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>





<h2 id="CSV读写"><a href="#CSV读写" class="headerlink" title="CSV读写"></a>CSV读写</h2><p>CSV文件： 逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），<br>其文件以纯文本形式存储表格数据（数字和文本）</p>
<h3 id="写CSV文件"><a href="#写CSV文件" class="headerlink" title="写CSV文件"></a>写CSV文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、首先导入CSV模块<br>	<span class="hljs-keyword">import</span> csv<br><span class="hljs-number">2</span>、创建一个CSV文件对象<br>	f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;222.csv&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-number">3</span>、进行写入CSV文件<br>	writer = csv.writer(f) <span class="hljs-comment"># 转化为写的对象</span><br></code></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> codecs<br>data = [<br> (<span class="hljs-string">&quot;测试1&quot;</span>,<span class="hljs-string">&#x27;软件工程师1&#x27;</span>),<br> (<span class="hljs-string">&quot;测试2&quot;</span>,<span class="hljs-string">&#x27;软件工程师2&#x27;</span>),<br> (<span class="hljs-string">&quot;测试3&quot;</span>,<span class="hljs-string">&#x27;软件工程师3&#x27;</span>),<br> (<span class="hljs-string">&quot;测试4&quot;</span>,<span class="hljs-string">&#x27;软件工程师4&#x27;</span>),<br> (<span class="hljs-string">&quot;测试5&quot;</span>,<span class="hljs-string">&#x27;软件工程师5&#x27;</span>),<br>]<br>f = codecs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;111.csv&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&quot;gbk&quot;</span>) <span class="hljs-comment">#gbk 指定编码解决汉字乱码问题</span><br>writer = csv.writer(f)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br> 	writer.writerow(i)<br>f.close()<br><br></code></pre></td></tr></table></figure>

<h3 id="读CSV文件"><a href="#读CSV文件" class="headerlink" title="读CSV文件"></a>读CSV文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、首先导入CSV模块 <br>	<span class="hljs-keyword">import</span> csv<br><span class="hljs-number">2</span>、创建一个CSV文件对象 <br>	f =csv.reader(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;1111.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>))<br><span class="hljs-number">3</span>、打开文件进行读取<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> f: <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br>rd = csv.reader(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;111.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> rd:<br>	<span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure>

<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p>字典形式储存</p>
<p>写操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> codecs<br>data = &#123;<span class="hljs-string">&#x27;id&#x27;</span>:<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-string">&#x27;26&#x27;</span>&#125;<br><span class="hljs-comment"># with open(&#x27;222.csv&#x27;,&#x27;w&#x27;)as f:</span><br><span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;222.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&quot;gbk&quot;</span>)<span class="hljs-keyword">as</span> f:<br> fieldnames = &#123;<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>&#125; <span class="hljs-comment"># 表头</span><br> writer = csv.DictWriter(f,fieldnames=fieldnames)<br> writer.writeheader()	<span class="hljs-comment">#先写key</span><br> writer.writerow(data)  <span class="hljs-comment">#再写value</span><br></code></pre></td></tr></table></figure>

<p>读操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br>f1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;222.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>reader = csv.DictReader(f1)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reader:<br> 	<span class="hljs-built_in">print</span>(i)<br>f1.close()<br></code></pre></td></tr></table></figure>

<p>官方手册：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/csv.html">https://docs.python.org/zh-cn/3/library/csv.html</a></p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>代码有异常发生，程序会在该位置终止，无法判断异常后面的代码是否正确</p>
<p>异常处理框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>：<br>	正常代码块<br><span class="hljs-keyword">except</span>：错误号：<br>	异常处理代码 <span class="hljs-comment">#（遇到对应错误号异常执行这里的代码）</span><br><span class="hljs-keyword">finally</span>：<br>	无论如何都会被执行的代码<br></code></pre></td></tr></table></figure>

<p>错误号：<br>1、将没加异常时候的错误号记录下来，再添加异常处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">先编写上面有异常的代码，执行一次发生异常得到异常号。<br>FileNotFoundError<br>按照异常添加框架修改如下:<br><span class="hljs-keyword">try</span>:<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao......1&quot;</span>)<br>	f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao .....2&quot;</span>)<br><span class="hljs-keyword">except</span> FileNotFoundError: <span class="hljs-comment">#就是异常号判断位置</span><br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file open error&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>2、将多个不同的异常都用()包括然后之间用逗号“ ， ”隔开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao......1&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao .....2&quot;</span>)<br><span class="hljs-keyword">except</span> (FileNotFoundError,NameError): <span class="hljs-comment">#多个不同异常的捕获</span><br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x or file error&quot;</span><br></code></pre></td></tr></table></figure>

<p>3、将未知的所有异常信息都统一用 Exception来捕获</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">10</span><br>    b = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入数字&quot;</span>))<br>    <span class="hljs-built_in">print</span>(a//b)<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao......1&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao .....2&quot;</span>)<br><span class="hljs-keyword">except</span> Exception: <span class="hljs-comment">#所有异常都统一捕获</span><br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;all error&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>4、使用异常as 操作可以将实际错误信息都打印出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">10</span><br>    b = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入数字&quot;</span>))<br>    <span class="hljs-built_in">print</span>(a/b)<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao......1&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao .....2&quot;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> error: <span class="hljs-comment">#各种情况都可能发生</span><br>	<span class="hljs-built_in">print</span>(error) <span class="hljs-comment">#将真实的错误信息直接输出</span><br></code></pre></td></tr></table></figure>

<p>5、finally的作用与使用，如果存在finally子句，则该finally子句 将作为try语句完成之前的最后一项任务执行。</p>
<p>finally无论该try语句是否产生 异常该子句都会运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m in while loop&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>   		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m in try&quot;</span>)<br>   		<span class="hljs-keyword">raise</span> EOFError <span class="hljs-comment">#自己触发异常并抛出</span><br>	<span class="hljs-keyword">except</span> IOError:<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IOEoor&quot;</span>)<br>	<span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m in finally&quot;</span>)<br>        <span class="hljs-keyword">break</span> <span class="hljs-comment">#屏蔽掉会显示try中异常，否则不显示</span><br>test1()<br><br><span class="hljs-string">&#x27;&#x27;&#x27;注意：</span><br><span class="hljs-string">如果异常处理中存在finally，finally总会被执行。</span><br><span class="hljs-string">那么在执行finally之前，try中的产生的异常将会被临时保存起来，当finally的代码执行完成后,再抛出异常。</span><br><span class="hljs-string">但当finally中存在raise或return或break时，try中的异常将会被抛弃</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m in try&quot;</span>)<br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> IndexError<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> index<br>    <span class="hljs-keyword">except</span> IndexError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m in except&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;except&quot;</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m in finally&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;finally&quot;</span><span class="hljs-comment">#屏蔽掉是返回try中return 否则返回这里return</span><br>    		<br> <br><span class="hljs-built_in">print</span>(test2(<span class="hljs-number">12</span>))<br></code></pre></td></tr></table></figure>

<p>注意：如果异常处理中存在finally， finally总会被执行。 </p>
<p>1、如果在try块语句中存在return的同时又存在finally块语句，<br>      那么将会在执行try块语句中return语句之前去执行finally语句块，<br>      然后再回来执行try块语句中return语句。</p>
<p> 2、 但是例子中在finally块语句中存在return语句，执行到这个return整个函数 已结束， 所以try块语句中return语句将永远得不到执行</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">异常：要加在基本IO操作上，人工输入（乱输），文件操作（文件权限不够）<br></code></pre></td></tr></table></figure>

<p>解决的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">打开一个文件，不知道是否存在，加上<span class="hljs-keyword">finally</span>始终可以保证内容泄漏问题<br>但这种方法被<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> 所取代了<br><br><span class="hljs-keyword">try</span>:<br>	f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;一个不存在的文件.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>	<span class="hljs-built_in">print</span>(f.read())<br><span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> reason:<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;出错啦！&#x27;</span>+ <span class="hljs-built_in">str</span>(reason))<br><span class="hljs-keyword">finally</span>:<br>	<span class="hljs-keyword">if</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">locals</span>(): <span class="hljs-comment">#始终执行文件关闭操作，防止内存泄露</span><br> 	f.close()<br>或<br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bilibili.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br> lines = f.readlines()<br> <span class="hljs-built_in">print</span>(lines)<br><br></code></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>1、print</p>
<p>用 print 最大的坏处是将来还得删掉它,运行结果也会包含很多垃圾信息</p>
<p>2、pycharm的单步跟踪</p>
<ol>
<li><p>设置断点</p>
</li>
<li><p>Debug’xxx’调试代码</p>
</li>
<li><p>断点所在代码行变蓝，意味着Pycharm程序进程已经到达 断点处，但尚未执行断点所标记的代码</p>
</li>
<li><p>debug窗口几个图标分别代表的意思</p>
<img src="https://s2.loli.net/2024/02/24/jJGBa4hMrIyiTeb.png" alt="image-20211107133436175" style="zoom: 67%;" />

<p>1.show execution point (F10) 显示当前所有断点<br>2.step over(F8) 单步调试。跳过函数 （一般跳过系统函数）<br>3.step into(F7) 单步调试。 进入函数 	（进入自己写的函数）<br>4.step into my code(Alt + Shift +F7) 执行下一行，但忽略libraries（导入库的语句）<br>5.force step into(Alt + Shift +F7) 执行下一行忽略lib和构造对象等<br>6.step out（Shift+F8）直接跳出子函数a，而不用继续执行子函数a中的剩余代码。<br>7.run to cursor(Alt +F9) 直接跳到下一个断点</p>
</li>
</ol>
<p>3、断言</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">- 凡是用 <span class="hljs-built_in">print</span> 来辅助查看的地方,都可以用断言(<span class="hljs-keyword">assert</span>)来替代;<br>- 如果断言失败, <span class="hljs-keyword">assert</span> 语句本身就会抛出 AssertionError(断言错误)<br>- 用于判断一个表达式，在表达式条件为 <span class="hljs-keyword">false</span> 的时候触发异常。<br>- Python 解释器执行时可以用 -O 参数来关闭 <span class="hljs-keyword">assert</span>,把所有的<span class="hljs-keyword">assert</span> 语句当成 pass<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">断言,<span class="hljs-keyword">assert</span> (你的预期),“如果没有达到预期 显示的内容”<br>eg:<br><span class="hljs-keyword">assert</span> a&gt;b, <span class="hljs-string">&#x27;error: b is bigger&#x27;</span><br></code></pre></td></tr></table></figure>



<p>4、 logging日志</p>
<p>需要导入logging模块</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">-<span class="hljs-built_in"> logging </span>不会抛出错误,而且可以输出到文件;<br>- logging.<span class="hljs-built_in">info</span>() 就可以输出一段文本到日志文件中。<br>- logging.basicConfig(<span class="hljs-attribute">level</span>=logging.INFO)指定记录信息的级别,<br>- 有<span class="hljs-built_in">debug</span> , <span class="hljs-built_in">info</span> , <span class="hljs-built_in">warning</span> , error等几个级别，<br>- 他们级别依次增大<span class="hljs-built_in">debug</span> &lt; <span class="hljs-built_in">info</span> &lt; warn &lt; <span class="hljs-built_in">error</span> &lt;critical<br></code></pre></td></tr></table></figure>

<p>默认情况下不显示info级别的错误日志，只显示warn及warn以上的错误日志</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>基础</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、面向du面向对象是种编程方式， 此编程方式的实现是基于对 类和对象的使用<br><span class="hljs-number">2</span>、类是一个模板，模板中包装了多个“函数”供使用<span class="hljs-comment">(可以将多函数中公用的变量封装到对象中)</span><br><span class="hljs-number">3</span>、对象，根据模板创建的实例<span class="hljs-comment">(即:对象)</span>，实例用于调用被包装在类中的函数<br><span class="hljs-number">4</span>、面向对象三大特性:封装、继承和多态==》重载	<br>	重置是实现多态性的手段，不是面向对象的特性<br></code></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>类的定义 &#x3D; 类的封装</p>
<p>语法格式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">ClassName:</span><br><span class="hljs-symbol">	</span>属性名 = 属性值<br>	<span class="hljs-symbol">def</span> 方法名(<span class="hljs-symbol">self</span>):<br>		方法体<br></code></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>	i = <span class="hljs-number">1234</span> 	<span class="hljs-comment">#类变量，属于属性,可以直接用类调用，或用实例对象调用</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_init_</span>(<span class="hljs-params">self,x,y</span>): 	<span class="hljs-comment">#构造函数</span><br>        self.x = x	<br>        self.y = y	<span class="hljs-comment">#实例变量，属于属性,需要它是在类的构造函数内以						 self.开头来定义的</span><br>	<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment">#自定函数，属于方法,默认传递self参数</span><br>        a = <span class="hljs-number">100</span>   <span class="hljs-comment">#实例变量</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world %d&quot;</span>% a)<br>	        <br></code></pre></td></tr></table></figure>

<p>实例化类  —》对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x = MyClass() <span class="hljs-comment">#调用构造函数</span><br></code></pre></td></tr></table></figure>

<p>访问类的属性和方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">通过实例来访问：<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())<br><br>通过类来访问：<br><span class="hljs-built_in">print</span>(MyClass.i)	<br></code></pre></td></tr></table></figure>

<p>类变量可以通过 “类名.变量名” 和 “实例名.变量名” 的方式访问。<br>实例变量只能通过“ 实例名.变量名”的方式来访问</p>
<h3 id="类的构造与初始化"><a href="#类的构造与初始化" class="headerlink" title="类的构造与初始化"></a>类的构造与初始化</h3><p>构造函数 _<em>init__() &#x3D;&#x3D;》对象创建时候自动调用  &#x3D;&#x3D;》 建议使用<br>析构函数 <em>_del</em></em>() &#x3D;&#x3D;》对象消亡的时候自动调用 &#x3D;&#x3D;》不建议使用</p>
<p><em>_init</em>_()要点如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.名称固定，必须为<span class="hljs-built_in">__init__</span>(self)<br><span class="hljs-number">2</span>.第一个参数固定，必须为self。self指的就是刚刚创建好的实例对象。<br><span class="hljs-number">3</span>.构造函数通常用来初始化实例属性。<br><span class="hljs-number">4</span>.通过类名(参数列表)，来调用构造函数,调用后,将创建好的对象返回给相应的变量<br><span class="hljs-number">5</span><span class="hljs-selector-class">.__init__</span>()方法：初始化创建好的对象，初始化指的是：&quot;给实例属性赋值&quot;<br><span class="hljs-number">6</span><span class="hljs-selector-class">.__new__</span>()方法：用于创建对象，但我们一般无需定义该方法。<br><span class="hljs-number">7</span><span class="hljs-selector-class">.__init__</span>() 方法可以有参数，参数通过 <span class="hljs-built_in">__init__</span>() 传递到类的实例属性上<br></code></pre></td></tr></table></figure>



<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>在类的内部，使用 def 关键字来定义一个(函数)方法，与一般函数定义不同，<br>类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>：<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a</span>):<br>		self.name = n<br>		self.age = a<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):	<span class="hljs-comment">#实例方法：不能通过类来访问</span><br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说：我 %d岁&quot;</span>% self.name,self.age)<br>p = people(<span class="hljs-string">&#x27;xiaoming&#x27;</span>,<span class="hljs-number">18</span>)<br>p.speak()<br></code></pre></td></tr></table></figure>



<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">静态方法名</span>():	<br>	<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">静态方法需要使用修饰器 @<span class="hljs-built_in">staticmethod</span> 来标识，告诉解释器这是一个静态方法。<br>静态方法不需要使用self 或 cls 可以通过<span class="hljs-string">&#x27;类名.静态方法名&#x27;</span> 的方式调用静态方法<br>无需将类实例化，直接通过“类名.方法名（）”方式调用方法<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>():		<span class="hljs-comment">#可以通过 类名 或者实例对象来调用</span><br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;喜欢吃&quot;</span>)<br>Person.eat()<br></code></pre></td></tr></table></figure>



<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">类方法名</span>(<span class="hljs-params">cls</span>):		<span class="hljs-comment">#可以通过 类名 或者实例对象来访问</span><br>	<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<p>类方法和实例方法：</p>
<ol>
<li><p>相同点：<br>类方法至少也要包含一个参数，通常命名为cls</p>
<p>在调用类方法时，无需显示为 cls参数 传参，但传递的不是实例对象，而是类对象本身（类名）？？？</p>
</li>
<li><p>不同点 </p>
<p>最大的不同在于需要使用 @classmethod 装饰器才能称为类方法</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">类属性<br>	声明在类内部，方法外部，可以通过类或者对象进行访问，但只能通过类进行修改<br>类方法<br>	定义在类内部，用@<span class="hljs-built_in">classmethod</span>修饰的方法。默认第一个参数cls代表类本身。<br>	类方法可以通过<span class="hljs-string">&#x27;类和对象&#x27;</span>调用<br><br>实例属性<br>	在方法内部声明的属性，可以访问，修改，动态添加。<br>	实例属性<span class="hljs-string">&#x27;只能通过对象&#x27;</span>调用。<br>实例方法<br>定义在类内部，用self作为第一个形参，就是普通意义上的内部函数。<br>	实例方法<span class="hljs-string">&#x27;只能通过对象&#x27;</span>调用。<br><br>静态方法 <br>	定义在类的内部，用@<span class="hljs-built_in">staticmethod</span>修饰的方法，没有默认参数，<br>	适用于与类无关的操作，后者无需使用类成员的操作，常见与工具类中。<br>	静态方法内部不能直接访问属性和方法，但可以使用类名间接访问。<br><br><span class="hljs-comment">#1.默认情况下，在类中定义的函数就是绑定方法</span><br><span class="hljs-comment">#2.当用对象本身来调用类中的方法时，默认会把对象本身作为参数传入方法中。</span><br><span class="hljs-string">&#x27;而用类名调用时则需要传入参数（对象）&#x27;</span><br></code></pre></td></tr></table></figure>



<h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><p>在Python中</p>
<p>默认上对象的属性和方法都是公开的，可以通过点操作符( . )来进行访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,score</span>):<br> 		self.name = name<br> 		self.score = score<br>        self.__sex = <span class="hljs-string">&#x27;男&#x27;</span>	<span class="hljs-comment">#私有变量</span><br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_information</span>(<span class="hljs-params">self</span>):<br> 		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;学生：%s,分数为：%s&quot;</span> %(self.name ,self.score)) <br> 		<span class="hljs-comment">#类中访问实例变量通过 self.属性名</span><br><br>person = Student(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-string">&quot;95&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;修改前的属性名：&quot;</span>,person.score) <br>	<span class="hljs-comment">#类外访问实例变量通过 实例名.属性名</span><br>person.get_information()<br><br>person.score = <span class="hljs-number">0</span> <span class="hljs-comment">#通过实例名.属性名修改实例变量的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;修改后的属性名：&quot;</span>,person.score)<br>person.get_information()<br></code></pre></td></tr></table></figure>

<h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><p>私有变量，只由内部可以访问，类的外部不能访问 </p>
<p>要让内部属性不被外部访问可以在属性名称前加两个下划线 ( __ )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,score</span>):<br>        self.__name = name<br>        self.__score = score<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_information</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;学生：%s,分数为：%s&quot;</span> %(self.__name ,self.__score))<br><br>person = Student(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-string">&quot;95&quot;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;修改前的属性名：&quot;</span>,person.__score) <span class="hljs-comment">#在类的外部访问私有属性</span><br>	访问会失败<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">“单下划线” 开始的成员变量叫做<span class="hljs-string">&#x27;保护变量&#x27;</span>，意思是只有类对象和子类对象自己能访问到这些变量；<br>“双下划线” 开始的是<span class="hljs-string">&#x27;私有成员&#x27;</span>，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。<br></code></pre></td></tr></table></figure>



<p>1、将变量定义为私有变量，可以确保外部代码不能随意修改对象内部的状态，通过访问限制的保护，代码更加安全.<br>2、若在类外部直接修改私有变量的值，是不会影响到最终实例(私有)变量的值<br>3、访问私有属性和方法的方式（通过_类名__私有（属性或方法））</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">person._Student__scor <span class="hljs-comment"># 间接访问  (可以强制修改)</span><br><span class="hljs-comment"># 这种方式会破坏类的封装性</span><br></code></pre></td></tr></table></figure>



<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>派生&#x2F;继承&#x2F;继承结构<br>    1、派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。</p>
<p>​	2、继承描述了子类属性从祖先类继承这样一种方式</p>
<p>​	3、继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系</p>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>父类也叫基类，子类也叫派生类，一个父类多个子类</p>
<p>继承类书写格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>	子类方法<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;吃&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drink</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;喝&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):		<span class="hljs-comment">#默认会继承父类所有属性和方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drak</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;叫&quot;</span>)<br>a = Animal()<br>a.eat() 	<span class="hljs-comment">#父类调用自己的方法</span><br><br>b = Dog()<br>b.eat() 	<span class="hljs-comment">#通过子类调用父类方法</span><br>b.drak() 	<span class="hljs-comment">#子类调用子类方法</span><br></code></pre></td></tr></table></figure>

<p>孙类是可以继承爷爷类的，线性，无限制</p>
<p>2.重写</p>
<p>子类和父类中拥有方法名相同的方法，说明子类重写了父类的方法 </p>
<p>重写的作用： 父类中已经有了这个方法，但子类想修改里面的内容，<br>                        直接修改父类是不好的，就需要用到重写</p>
<p>#与上级任意环节重名都会重写方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---吃-----&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drink</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----喝-----&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----睡觉-----&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---汪汪叫----&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Xiaotq</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----飞-----&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----狂叫-----&quot;</span>)<br><br>chen = Xiaotq()<br>chen.fly()<br>chen.bark()<br>chen.eat()<br><br><br></code></pre></td></tr></table></figure>

<h4 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">子类调用父类被重写之前的方法:<br><span class="hljs-number">1.</span>普通方法（明确指定）<span class="hljs-comment">#可移植性差</span><br>Dog.bark(self = chen) <span class="hljs-comment">#调用父类被重写的方法</span><br><span class="hljs-number">2.</span><span class="hljs-string">&#x27;通过super关键字也可以间接调用&#x27;</span><br><span class="hljs-built_in">super</span>(Xiaotq,chen).bark()<br>		<span class="hljs-comment"># super() 函数是用于调用父类(超类)的一个方法</span><br><br>对于<span class="hljs-string">&quot;super(子类名，子类对象).父类被重写方法  可以理解为：</span><br><span class="hljs-string">先找到子类的&#x27;父类&#x27;,然后调用父类的方法，同时将子类的实例传递给父类方法</span><br></code></pre></td></tr></table></figure>



<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>一个子类多个父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(父类<span class="hljs-number">1</span>,父类<span class="hljs-number">2</span>):<br>	子类方法<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(A,B): 	<span class="hljs-comment">#多继承的时候，每个基类用 , 号隔开。</span><br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_c</span>(<span class="hljs-params">self</span>):<br> 		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是C类&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>多重继承中，同名方法按照继承次序有效  	C(B,A)先继承A</p>
<p>特例菱形继承：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>(<span class="hljs-title class_ inherited__">object</span>): 	<span class="hljs-comment">#object是python默认最大的类</span><br> 	<span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br> 	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----Base&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):<br> 	<span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br> 	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----A&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br> 	 <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----B&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(A, B): <span class="hljs-comment"># 父类重写的方法按照继承顺序依次重写，默认是第一个匹配</span><br> 	<span class="hljs-comment"># def test(self):</span><br> 		<span class="hljs-comment"># print(&quot;-----C&quot;)</span><br>        <br>c = C()<br><span class="hljs-built_in">print</span>(子类类名.__mro__)<span class="hljs-comment">#查看子类的继承顺序</span><br></code></pre></td></tr></table></figure>

<h4 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a>钻石继承</h4><p>尽可能能的避免多重继承</p>
<p>从技术上来说，在python3的所有多重继承都是钻石继承(菱形继承），因为所有的类都从object继承</p>
<p>一个例子，我们有一个基类，该基类有一个call_me方法，<br>有两个子类重写了这个方法，<br>然后第3个类通过多重继承扩展了两个方法。这称为钻石继承(菱形继承)。</p>
<p>钻石继承场景，</p>
<p>使用普通继承，明确指定父类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span>:<br>	num_base_calls = <span class="hljs-number">0</span><br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Base Class&quot;</span>)<br>		self.num_base_calls += <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LeftSubclass</span>(<span class="hljs-title class_ inherited__">BaseClass</span>):<br>    num_left_calls = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>        BaseClass.call_me(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Lef Subclass&quot;</span>)<br>        self.num_left_calls += <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RightSubclass</span>(<span class="hljs-title class_ inherited__">BaseClass</span>):<br>    num_right_calls = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>        BaseClass.call_me(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Right Subclass&quot;</span>)<br>        self.num_right_calls += <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subclass</span>(LeftSubclass, RightSubclass):<br>    num_sub_calls = <span class="hljs-number">0</span><br><span class="hljs-comment">#如果不重写call_me方法,则孙类会直接继承LeftSubclass中call_me方法 </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):	<br>        LeftSubclass.call_me(self)	<br>        RightSubclass.call_me(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Subcalss&quot;</span>)<br>        self.num_sub_calls += <span class="hljs-number">1</span><br> <br>s = Subclass()<br>s.call_me()<br><span class="hljs-built_in">print</span>(s.num_sub_calls, s.num_left_calls, s.num_right_calls,s.num_base_calls)<br><br>&gt;&gt;&gt;输出：<br>Calling method on Base Class<br>Calling method on Lef Subclass<br>Calling method on Base Class<br>Calling method on Right Subclass<br>Calling method on Subcalss<br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p> 可以看到Baseclass被调用了两次，这是一个非常严重的bug</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>C++中面对钻石问题，引入了虚基类，</p>
<p>LeftSubclass和RightSubclass虚拟继承BaseClass。当生成Subclass对象时，LeftSubclass和RightSubclass并不会自动调用虚拟基类BaseClass的构造函数，而需要由Subclass的构造函数显式调用BaseClass的构造函数。</p>
<p>Python则采用super()函数解决钻石继承：<br>将上述代码重写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span>:<br>    num_base_calls = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Base Class&quot;</span>)<br>        self.num_base_calls += <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LeftSubclass</span>(<span class="hljs-title class_ inherited__">BaseClass</span>):<br>    num_left_calls = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().call_me()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Lef Subclass&quot;</span>)<br>        self.num_left_calls += <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RightSubclass</span>(<span class="hljs-title class_ inherited__">BaseClass</span>):<br>    num_right_calls = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().call_me()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Right Subclass&quot;</span>)<br>        self.num_right_calls += <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subclass</span>(LeftSubclass, RightSubclass):<br>     num_sub_calls = <span class="hljs-number">0</span><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_me</span>(<span class="hljs-params">self</span>):<br>     <span class="hljs-built_in">super</span>().call_me()<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling method on Subcalss&quot;</span>)<br>     self.num_sub_calls += <span class="hljs-number">1</span><br> <br>s = Subclass()<br>s.call_me()<br><span class="hljs-built_in">print</span>(s.num_sub_calls, s.num_left_calls, s.num_right_calls,s.num_base_calls)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>输出<br>Calling method on Base Class<br>Calling method on Right Subclass<br>Calling method on Lef Subclass<br>Calling method on Subcalss<br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>解决了钻石继承</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">首先，Subclass的call_me方法调用了<span class="hljs-built_in">super</span>().call_me()，其实就是引用了 LeftSubclass.call_me()方法。<br>然后LeftSubclass.call_me()调用了 <span class="hljs-built_in">super</span>().call_me()，但是这时<span class="hljs-built_in">super</span>()引用了<span class="hljs-string">&#x27;RightSubclass.call_me()&#x27;</span>。 <br>需要特别注意：<span class="hljs-built_in">super</span>调用并不是调用LeftSubclass的超类（就是 BaseClass）的方法。 <br>它是调用RightSubclass，虽然它不是LeftSubclass的父类！<br>这就是<span class="hljs-string">&#x27;下一个方法&#x27;</span>，而不是父类方法。RightSubclass然后调用BaseClass，并且通过 <span class="hljs-built_in">super</span>调用保证在类的 层次结构中每一个方法都被执行一次<br></code></pre></td></tr></table></figure>

<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>super采用了调用”下一个的方法”，要理解super的原理，就要先了解mro</p>
<p>super的内核：mro   </p>
<p>在python中，每个类都有一个mro的类方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">mro继承的顺序<br><span class="hljs-built_in">print</span>(子类类名.__mro__)<span class="hljs-comment">#查看子类的继承顺序</span><br><br><span class="hljs-built_in">print</span>(Subclass.__mro__)<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Subclass&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.LeftSubclass&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.RightSubclass&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.BaseClass&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br><br>mro() 和 __mro__ 有什么区别 ???<br></code></pre></td></tr></table></figure>

<p>通过mro可以查看到子类的继承顺序，而super的下一个方法就是按照mro表，当前类的下一个继承类，所查找的</p>
<p>super的强悍之处：<br>1、在类的继承层次结构中，只想调用”下一个方法”，而不是父类的方法</p>
<p>2、super的目标就是解决复杂的多重继承问题（基类被调用两次的问题）</p>
<p>3、super是绝对的保证，在类的继承层次结构中每一个方法只被执行一次</p>
<p>参考连接：<a href="http://www.cnblogs.com/testview/p/4651198.html?utm_source=tuicool&utm_medium=referral">http://www.cnblogs.com/testview/p/4651198.html?utm_source=tuicool&amp;utm_medium=referral</a></p>
<h4 id="经典类和新式类"><a href="#经典类和新式类" class="headerlink" title="经典类和新式类"></a>经典类和新式类</h4><p>所有 直接继承 或者 间接继承 object的类，都是新式类，<br>object称之为根类，意思时所有类都是源自object类</p>
<p>• 为什么这么设计？ </p>
<p>创建对象时，需要申请内存空间，创建新的名称空间，<br>将对象的属性放入名称空间， 这一复杂的基础操作都是由object完成的。<br>简单来说就是object 提供了一些常用的基础操作</p>
<p>注意： </p>
<p>1.在python3中，所有类都是object的子类，所有类都是新式类<br>2.在python2中，默认的是经典类，不会继承object</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">区别<br><span class="hljs-comment">#python2中定义类 经典类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cls</span>():<br> 	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;python2中定义类&#x27;</span>)<br> <br><span class="hljs-comment">#python3中 新式类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cls</span>(<span class="hljs-title class_ inherited__">Object</span>):<br> 	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;python3中定义类&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>定义时的类型和运行时的类型不一样，也就是定义时并不确定要调用的是哪个方法， 只有运行的时候才能确定调用的是哪个</p>
<p>多态特性 </p>
<p>多态性是指在不考虑实例类型的情况下使用实例，<br>多态性分为静态多态性和动态多态性</p>
<h3 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h3><p>1.基类中进行区分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H2O</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,temp</span>):<br>        self.name = name<br>        self.temp = temp<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">turn_ice</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-keyword">if</span> self.temp&lt;<span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[%s]水结成冰咯&quot;</span>%self.name)<br>            <span class="hljs-keyword">elif</span> self.temp&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> self.temp&lt;<span class="hljs-number">100</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[%s]冰融化成水咯&quot;</span>%self.name)<br>            <span class="hljs-keyword">elif</span> self.temp&gt;=<span class="hljs-number">100</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[%s]水蒸发成气体咯&quot;</span>%self.name)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ice</span>(<span class="hljs-title class_ inherited__">H2O</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Water</span>(<span class="hljs-title class_ inherited__">H2O</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Steam</span>(<span class="hljs-title class_ inherited__">H2O</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">turn</span>(<span class="hljs-params">obj</span>):		<span class="hljs-comment">#类外函数</span><br>	obj.turn_ice() 	<span class="hljs-comment">#多态体现</span><br><br>ice = Ice(<span class="hljs-string">&quot;冰&quot;</span>,-<span class="hljs-number">40</span>)<br>water = Water(<span class="hljs-string">&quot;水&quot;</span>,<span class="hljs-number">40</span>)<br>steam = Steam(<span class="hljs-string">&quot;水蒸气&quot;</span>,<span class="hljs-number">1000</span>)<br><span class="hljs-comment">#多态的实现</span><br>turn(ice)<br>turn(water)<br>turn(steam)<br></code></pre></td></tr></table></figure>

<p>2.基于基类和子类进行区分（重写）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animals</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Animals run...&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span>(<span class="hljs-title class_ inherited__">Animals</span>): <span class="hljs-comment"># 属于动物的另外一种形态：猪</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Pig is huohuo&#x27;</span>)       <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span>(<span class="hljs-title class_ inherited__">Animals</span>):<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;dog is wangwang&quot;</span>)<br>        <br>p = Pig()<br>d = dog()<br><br><span class="hljs-comment"># 统一接口，对于使用者来说，自己的代码根本无需改动</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">obj</span>):<br>	obj.talk()<br> <br>func(p) <span class="hljs-comment"># 甚至连调用方式都无需改变，就能调用出pig的talk功能</span><br>func(d)<br></code></pre></td></tr></table></figure>



<h3 id="静态多态性"><a href="#静态多态性" class="headerlink" title="静态多态性"></a>静态多态性</h3><p>如任何类型都可以用运算符+进行运算<br>编译(解释)之初就根据数据类型做自动匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">运算符重载是指赋予内置运算符新的功能,使内置运算符能适应更多的数据类型。<br>当定义一个类的时候，<br>如果这个类中重写了<span class="hljs-string">&#x27;python基类object内置的有关运算符的特殊方法&#x27;</span>，<br>那么该特殊方法对应的运算符将支持对该<span class="hljs-string">&#x27;类的实例&#x27;</span>进行运算<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-title class_ inherited__">object</span>):<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, number</span>): <span class="hljs-comment"># 记录数值</span><br>		self.number = number<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>): <span class="hljs-comment"># 重载运算符+</span><br>		self.number = self.number + other<br>		<span class="hljs-keyword">return</span> self.number<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__sub__</span>(<span class="hljs-params">self, other</span>):<span class="hljs-comment"># 重载运算符-</span><br>		self.number = self.number - other<br>		<span class="hljs-keyword">return</span> self.number<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self,other</span>):<span class="hljs-comment">#重载运算符*</span><br>        self.number = self.number * other<br>        <span class="hljs-keyword">return</span> self.number<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__truediv__</span>(<span class="hljs-params">self,other</span>):<span class="hljs-comment">#重载运算符/</span><br>    	self.number = self.number / other<br>        <span class="hljs-keyword">return</span> self.number<br><br>calculator = Calculator(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(calculator + <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(calculator - <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(calculator * <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(calculator / <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>

<p>基类object中提供的一些特殊方法及其对应的运算符如表所示。</p>
<img src="https://s2.loli.net/2024/02/24/FTScBZ9mgkVprbo.png" alt="image-20211108203222925" style="zoom: 67%;" />

<p>好像只能使用表内的函数名进行重载</p>
<p>1、为什么要用多态性？<br>①增加了程序的灵活性。<br>    以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal)。<br>②增加了程序可扩展性。<br>通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用</p>
<p>2、多态性的实现手段有哪些？优缺点？<br>① 动态多态性。执行过程中动态添加<br>② 静态多态性。编写代码中分类添加，执行时候类型匹配。</p>
<h2 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h2><p>动态语言</p>
<p>• 在运行时代码可以根据某些条件改变自身结构<br>• 可以在运行时引进新的函数、对象、甚至代码，可以删除已有的函数等其他结构上的变化<br>• 常见的动态语言：Object-C、C#、JavaScript、PHP、 Python、Erlang</p>
<p>动态类型语言 </p>
<p>• 在运行期间检查数据类型的语言<br>• 数据类型不是在编译阶段决定的，而是把类型绑定延后到了运 行阶段<br>• 常见的动态类型语言：Python、Ruby、Erlang、JavaScript、 swift、PHP、</p>
<p>强类型语言</p>
<p> • 一旦一个变量被指定了某个数据类型，如果不经过强制类型转 换，那么它就永远是这个数据类型<br> • 常见的强类型语言：Java、C#、Python、Object-C、Ruby</p>
<p>Python是动态语言，动态类型语言，也是强类型语言。<br>所以Python可以在运行时改变自身结构，动态添加&#x2F; 删除属性和方法。</p>
<h3 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a>动态添加属性</h3><h4 id="添加对象属性"><a href="#添加对象属性" class="headerlink" title="添加对象属性"></a>添加对象属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span>(<span class="hljs-title class_ inherited__">object</span>):<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>		self.name = <span class="hljs-string">&#x27;chen&#x27;</span><br><br>obj = Obj()<br>obj.age = <span class="hljs-number">18</span><br><span class="hljs-built_in">print</span>(obj.age)	<span class="hljs-comment">#可以正常打印</span><br><br>obj2 = Obj()<br><span class="hljs-built_in">print</span>(obj2.age)	<span class="hljs-comment">#打印时报错</span><br><br><span class="hljs-comment">#通过[对象名.属性名]给类对象obj动态添加了对象属性age，</span><br>而Obj的另一个类对象obj2却不能调用这个属性。<br><span class="hljs-string">&#x27;注：通过对象名添加的对象属性，只有这个对象能使用&#x27;</span><br></code></pre></td></tr></table></figure>

<h4 id="添加类属性"><a href="#添加类属性" class="headerlink" title="添加类属性"></a>添加类属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Obj.score = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(obj.score)<br><span class="hljs-built_in">print</span>(obj2.score)<br><br><span class="hljs-comment">#通过[类名.属性名]给类Obj动态添加了类属性score，</span><br>Obj的类对象obj和obj2都能调用这个属性<br><span class="hljs-string">&#x27;注：通过类名添加的类属性，这个类的所有对象都能使用&#x27;</span><br></code></pre></td></tr></table></figure>

<h4 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> types<br><span class="hljs-comment">#定义了一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name = <span class="hljs-literal">None</span>, age = <span class="hljs-literal">None</span></span>):<br>        self.name = name<br>        self.age = age<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eat food&quot;</span>)<br><span class="hljs-comment">#类外定义</span><br><span class="hljs-comment">#定义一个实例方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, speed</span>):<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s在移动, 速度是 %d km/h&quot;</span>%(self.name, speed))<br><span class="hljs-comment">#定义一个类方法</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">testClass</span>(<span class="hljs-params">cls</span>):<br>	cls.num = <span class="hljs-number">100</span><br><span class="hljs-comment">#定义一个静态方法</span><br><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">testStatic</span>():<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---static method----&quot;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	P = Person(<span class="hljs-string">&#x27;chen&#x27;</span>,<span class="hljs-number">18</span>) <span class="hljs-comment">#创建对象</span><br><br><span class="hljs-number">1.</span><br><span class="hljs-comment">#给这个对象动态添加实例方法</span><br>P.run = types.MethodType(run,P)<br>		<span class="hljs-comment">#MethodType可以把外部函数(方法)绑定到类或类的实例中</span><br>P.run(<span class="hljs-number">180</span>)<br><span class="hljs-number">2.</span><br><span class="hljs-comment">#给Person类绑定类方法</span><br>Penson.testClass = testClass<br><span class="hljs-comment">#调用类方法</span><br><span class="hljs-built_in">print</span>(Person.num)<br>Person.testClass()<br><span class="hljs-built_in">print</span>(Person.num)<br><span class="hljs-number">3.</span><br><span class="hljs-comment">#给Person类绑定静态方法</span><br>Person.testStaticXXX = testStatic<br><span class="hljs-comment">#调用静态方法</span><br>Person.testStaticXXX()	<span class="hljs-comment">#XXX表示可以自己起</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">给类添加方法，是使用<span class="hljs-string">&#x27;类名.方法名 = xxxx&#x27;</span><br>给对象添加一个方法也是<span class="hljs-string">&#x27;对象.方法名 =xxxx&#x27;</span><br></code></pre></td></tr></table></figure>



<h3 id="动态删除属性"><a href="#动态删除属性" class="headerlink" title="动态删除属性"></a>动态删除属性</h3><p>运行的过程中删除属性、方法删除的方法: </p>
<ol>
<li>del 对象.属性名 </li>
<li>delattr(对象, “属性名”)</li>
</ol>
<p>相对于动态语言，静态语言 具有严谨性！</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>限制class的属性：使用 _<em>slots</em>_</p>
<p>Python允许在定义class的时候，定义一个特殊变量__slots__来 限制该class 能添加的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment">#限制创建的类对象只能有这两个属性</span><br><br>obj = Obj()<br>obj.name = <span class="hljs-string">&#x27;xiaoming&#x27;</span><br>obj.age = <span class="hljs-number">18</span><br>obj.score = <span class="hljs-number">99</span> <span class="hljs-comment">#动态添加对象属性失败 （没有属性）</span><br>	<span class="hljs-comment"># AttributeError: &#x27;Obj&#x27; object has no attribute&#x27;score&#x27;</span><br><br>Obj.score = <span class="hljs-number">100</span> <span class="hljs-comment">#给类添加属性成功</span><br><span class="hljs-built_in">print</span>(obj.score) <span class="hljs-comment"># 100</span><br>obj.score = <span class="hljs-number">99</span> <br>  <span class="hljs-comment"># AttributeError: &#x27;Obj&#x27; object attribute &#x27;score&#x27;is read-only</span><br>    (有了属性，但是权限只读)<br></code></pre></td></tr></table></figure>

<p>__slots__对Obj类的动态添加没有限制，<br>而 Obj类对象obj不能再动态添加对象属性和方法</p>
<p>注意：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">• __slots__只对类对象进行限制，不对类进行限制<br>• __slots__不仅限制类对象的属性，还限制类对象的方法<br>• __slots__仅对当前类起作用，对继承的子类不起作用<br>• 在子类中定义__slots__，子类允许定义的属性就是自身的__slots__加上父类的__slots__???	<span class="hljs-comment">#第四条待实验</span><br></code></pre></td></tr></table></figure>



<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>• 直接赋值：其实就是对象的引用（别名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br>a = b 直接赋值<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a),<span class="hljs-built_in">id</span>(b))	<span class="hljs-comment">#查看地址,a,b相同</span><br></code></pre></td></tr></table></figure>

<p>• 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部 的子对象。<br>• 深拷贝(deepcopy)：copy 模块的 deepcopy 方法,完全拷贝了父对象及其子对象</p>
<p>字典浅拷贝实例 需引入copy 模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = &#123;<span class="hljs-number">1</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br>b = a.copy()<br><span class="hljs-built_in">print</span>(a,b)<br>&gt;&gt;&gt;(&#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;, &#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;)<br>a[<span class="hljs-number">1</span>].append(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a,b)<br>&gt;&gt;&gt;(&#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;, &#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;)<br><span class="hljs-comment"># a添加后，b会同时更新</span><br>但是 a与b 的<span class="hljs-built_in">id</span>值不相同<br><br><span class="hljs-comment">#拷贝父对象，不会拷贝对象的内部的子对象，子对象还是指向相同地址</span><br></code></pre></td></tr></table></figure>

<p>字典深拷贝实例 需要引入 copy 模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>b = copy.deepcopy(a)<br><span class="hljs-built_in">print</span>(a,b)<br>&gt;&gt;&gt;(&#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;, &#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;)<br>a[<span class="hljs-number">1</span>].append(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a,b)<br>&gt;&gt;&gt;(&#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;, &#123;<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;)<br></code></pre></td></tr></table></figure>

<p>深浅拷贝还可用copy.copy（ 浅拷贝 ） 和（copy.deepcopy ）完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">c = copy.copy(a) <span class="hljs-comment"># 对象拷贝，浅拷贝</span><br>d = copy.deepcopy(a) <span class="hljs-comment"># 对象拷贝，深拷贝</span><br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/GVDwJTHcsYXqMSh.png" alt="image-20211109192024329" style="zoom:67%;" />

<p><img src="https://s2.loli.net/2024/02/24/GVDwJTHcsYXqMSh.png" alt="image-20211109192007976"></p>
<p><img src="https://s2.loli.net/2024/02/24/1qICLtQbZGrxiNM.png" alt="image-20211109192104644"></p>
<p>以下操作会产生浅拷贝效果<br>• 使用切片[:]操作<br>• 使用工厂函数（如list&#x2F;dir&#x2F;set）<br>• 使用copy模块中的copy()函数</p>
<p>特殊：</p>
<p>• 对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说 • 如果元祖变量只包含原子类型对象，则不能深拷贝.</p>
<p>总结：</p>
<p>•Python中对象的赋值都是进行对象引用（内存地址）传递<br>• 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素， 依然使用原始的引用(内存地址)<br>• 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素）， 可以使用copy.deepcopy()进行深拷贝</p>
<p>注意：<br>如果元组变量只包含空列表类型对象，则不能深拷贝，(元组不能被修改)</p>
<p><a href="file:///D:/笔记/python/python/python--对象--深浅拷贝.pdf">python–对象–深浅拷贝.pdf</a>（具体实例，之后可看）</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>如果某个变量值绑定着变量名，就是一个正常的变量，如果该变量值没有绑定着 门牌号，这个变量就是一个垃圾变量，对于垃圾变量，Python会触发垃圾回收机制回收这个变量所占有的内存。进而可以想到，Python中一个变量名一 定只能对应一个变量值。 在这里我们就引出一个新的名词——引用计数</p>
<p>在python中定义了一个变量值为2021，他可以表示不同的变量，</p>
<p>一个变量名只能对应一个变量值，而一个变量值可以对应多个变量名</p>
<p>当相同变量值被赋予不同的变量名时，变量值每增加一个变量名的赋予，该变量值的引用计数加1<br>查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">通过sys模块中的getrefcount()查看引用计数，默认从<span class="hljs-number">3</span>开始<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-comment"># 引用计数初始值为3</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为3</span><br>year = <span class="hljs-number">2021</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为4</span><br>height = <span class="hljs-number">2021</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为5</span><br><br><span class="hljs-keyword">del</span> year <span class="hljs-comment">#删除变量值2021的一个变量名，引用计数减1</span><br>	<span class="hljs-comment">#手工触发回收机制</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为4</span><br></code></pre></td></tr></table></figure>

<p>更严谨的讲，只有当一个变量值每一次被直接 或 间接引用时，引用计数才会增加</p>
<p>在Python中引用计数增加方法</p>
<ol>
<li>变量被创建，变量值引用计数加1</li>
<li>变量被引用，变量值引用计数加1</li>
<li>变量作为参数传入到一个函数，变量值引用计数加2<br>（实参到形参一次，形参引用再一次）</li>
</ol>
<p>在Python减少引用计数的方法：</p>
<ol>
<li>变量值对应的变量名被销毁 </li>
<li>变量值对应的变量名被赋予新的值 </li>
<li>变量值对应的变量名离开它的作用域 </li>
<li>变量值对应的变量名的容器被销毁</li>
</ol>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>getrefcount( )可以查看引用计数，当引用计数归0，也就是用getrefcount查看值又回到3时，则可以判断它触发了垃圾回收机制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为3</span><br>year = <span class="hljs-number">2021</span><br><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(year)) <span class="hljs-comment"># 输出4499932720</span><br><span class="hljs-built_in">print</span>(year) <span class="hljs-comment"># 输出2021</span><br>	<span class="hljs-comment">#自动垃圾回收</span><br>year = <span class="hljs-number">2022</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(year)) <span class="hljs-comment"># 输出4499932560</span><br><span class="hljs-built_in">print</span>(year) <span class="hljs-comment"># 输出2022</span><br></code></pre></td></tr></table></figure>

<p>那么是否可以证明只有当变量值2021的引用计数为0，时才能触发垃圾回收机制呢？ 而不是当变量值的变量名 被新的变量值引用了才会销毁呢？<br>因为变量值可以对应多个变量名？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为3</span><br>year = <span class="hljs-number">2021</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为4</span><br>height = <span class="hljs-number">2021</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为5</span><br>year = <span class="hljs-number">2022</span>	<span class="hljs-comment">#变量值的变量名被新的变量值</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为4</span><br><span class="hljs-keyword">del</span> height  <span class="hljs-comment">#删除变量值2021最后一个变量名，此时垃圾回收触发</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(<span class="hljs-number">2021</span>)) <span class="hljs-comment"># 输出为3</span><br></code></pre></td></tr></table></figure>

<p>当定义一个变量后，该变量对应的变量值引用计数可以不断增加，<br>引用计数不为0，Python就一直还在内存中保留着这个变量值并且对其引用，<br>只有当该变量的引用计数为0时，<br>Python才会触发垃圾回收机制对该变量值进行回收</p>
<p>回收机制种类： 一、引用计数  二、标记-清除  三、分代回收   四、缓存机制</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><h3 id="TCP-服务器"><a href="#TCP-服务器" class="headerlink" title="TCP  服务器"></a>TCP  服务器</h3><p>要导入socket 包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment"># 1、创建一个TCP服务端 套接字 对象 </span><br> tcp_sever = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 绑定本地的相关信息，如果不绑定，则系统会随机分配一个端口号</span><br>local_addr = (<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">12344</span>) 元组<br>		<span class="hljs-comment"># ip地址和端口号，ip一般不用写，表示本机的任何一个ip）</span><br>tcp_sever.bind(local_addr)<br><br><span class="hljs-comment"># 3、监听连接，使用socket创建的套接字默认的属性是主动的，使用listen接收别人的链接</span><br> tcp_sever.listen(<span class="hljs-number">5</span>)<span class="hljs-comment">#最大连接数5</span><br>    <br><span class="hljs-comment"># 4、等待连接，其返回值为连接过来的客户端套接字对象和IP地址</span><br> client_socket, client_addr = tcp_sever.accept()<br><br><span class="hljs-comment"># 5.1、打印连接过来的客户端信息及其ip地址</span><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;client_socket:&quot;</span>,client_socket)<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;clinet_addr :&quot;</span>,client_addr)<br><br><span class="hljs-comment"># 5.2、等待接收对方发送过来的数据</span><br> recv_data = client_socket.recv(<span class="hljs-number">1024</span>) <span class="hljs-comment"># 最大接收1024个字节</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Recvfrom&quot;</span>,client_addr,<span class="hljs-string">&quot;recv_data:&quot;</span>,recv_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment">#解决汉字问题</span><br><br><span class="hljs-comment"># 5.3、返回数据到客户端，非必须</span><br> send_data = <span class="hljs-string">&quot;I have got the date:&quot;</span> +recv_data.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br> client_socket.send(send_data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment"># 6、关闭套接字</span><br> tcp_sever.close()<br></code></pre></td></tr></table></figure>

<h3 id="TCP-客户端"><a href="#TCP-客户端" class="headerlink" title="TCP 客户端"></a>TCP 客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment"># 1、创建一个TCP服务端套接字对象,ipv4协议，使用SOCK_STREAM参数，</span><br><span class="hljs-comment"># 不填proto，就会默认自动选择tcp协议</span><br>tcp_client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 准备服务端的地址和端口，&#x27;192.168.0.107&#x27; 表示目的ip地址，12341表示目的端口号</span><br> dest_addr = (<span class="hljs-string">&#x27;192.168.0.107&#x27;</span>, <span class="hljs-number">12344</span>) <br>    	<span class="hljs-comment"># 注意这是一个元组，其中ip地址是字符串，端口号是数字</span><br>  <br><span class="hljs-comment"># 3、链接到服务器</span><br> tcp_client.connect(dest_addr)<br>    <br><span class="hljs-comment"># 4.1、发送数据</span><br> tcp_client.send(<span class="hljs-string">&quot;Hello, I am a tcp client.&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-comment"># 4.2、等待接收服务端发送过来的数据，最大接收1024个字节</span><br> recvData = tcp_client.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-comment"># 4.2.1、将接收到的数据打印出来</span><br> <span class="hljs-built_in">print</span>(recvData.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br> <br><span class="hljs-comment"># 5、关闭套接字</span><br> tcp_client.close()<br></code></pre></td></tr></table></figure>

<h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment"># 1、创建一个UDP套接字</span><br>udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)<br><br><span class="hljs-comment"># 2. 绑定本地的相关信息，如果不绑定，则系统会随机分配一个端口号</span><br>local_addr = (<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">8080</span>) <br>	<span class="hljs-comment"># ip地址和端口号，ip一般不用写，表示本机的任何一个ip</span><br>udp_socket.bind(local_addr)<br><br><span class="hljs-comment"># 3. 等待接收对方发送的数据</span><br>recv_data,recv_addr = udp_socket.recvfrom(<span class="hljs-number">1024</span>) <br>						<span class="hljs-comment"># 1024表示本次接收的最大字节数</span><br><br><span class="hljs-comment"># 4、打印接收到的数据</span><br><span class="hljs-built_in">print</span>(recv_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment"># 5. 关闭套接字</span><br>udp_socket.close()<br></code></pre></td></tr></table></figure>

<h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment"># 1、创建一个UDP套接字</span><br>udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)<br><br><span class="hljs-comment"># 2. 目标方的地址和端口，&#x27;192.168.0.107&#x27;表示目的ip地址，8080表示目的端口号</span><br>dest_addr = (<span class="hljs-string">&#x27;192.168.0.107&#x27;</span>, <span class="hljs-number">8080</span>) <br>		<span class="hljs-comment"># 注意这是一个元组，其中ip地址是字符串，端口号是数字</span><br><br><span class="hljs-comment"># 3. 发送数据到指定的ip和端口</span><br>udp_socket.sendto(<span class="hljs-string">&quot;Hello,I am a UDPsocket.&quot;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), dest_addr)<br><br><span class="hljs-comment"># 4. 关闭套接字</span><br>udp_socket.close()<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/Oryqa8CjIv3xBZA.png" alt="image-20211111182251581" style="zoom:80%;" />



<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>1、os.fork	  (windows 下无效)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">pid=os.fork()</span><br><span class="hljs-string"> 1.只用在Unix系统中有效，Windows系统中无效</span><br><span class="hljs-string"> 2.fork函数调用一次，返回两次：在父进程中返回值为子进程</span><br><span class="hljs-string">id，在子进程中返回值为0</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>pid = os.fork()<br><span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行子进程，子进程pid=&#123;pid&#125;,父进程ppid=&#123;ppid&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pid=os.getpid(), ppid=os.getppid()))<br><span class="hljs-keyword">else</span>:<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行父进程，子进程pid=&#123;pid&#125;,父进程ppid=&#123;ppid&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pid=pid, ppid=os.getpid()))<br></code></pre></td></tr></table></figure>



<p>2、使用multiprocessing模块:<br>      创建Process的实例，传入任务执行函数作为参数</p>
<p>生命周期：</p>
<p> 创建主进程&#x3D;&#x3D;》启动子进程 &#x3D;&#x3D;》执行子进程 &#x3D;&#x3D;》退出子进程 &#x3D;&#x3D;》回收子进程</p>
<p>父进程： 创建 &#x3D;&#x3D;》启动 。。。。&#x3D;&#x3D;》回收      ppid<br>子进程： 执行 &#x3D;&#x3D;》退出                                       pid 进程识别码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Process常用属性与方法：</span><br><span class="hljs-string"> name:进程名</span><br><span class="hljs-string"> pid：进程id</span><br><span class="hljs-string"> run()，自定义子类时覆写</span><br><span class="hljs-string"> start()，开启进程</span><br><span class="hljs-string"> join(timeout=None)，阻塞进程</span><br><span class="hljs-string"> terminate(),终止进程</span><br><span class="hljs-string"> is_alive()，判断进程是否存活</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(): <span class="hljs-comment"># 子进程1执行空间，每次子进程执行的时候从该函数进入</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程1执行中&gt;&gt;&gt; pid=&#123;0&#125;,ppid=&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid(), os.getppid()))<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是子进程1 &quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程1终止&gt;&gt;&gt; pid=&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker2</span>(): <span class="hljs-comment"># 子进程2执行空间，每次子进程执行的时候从该函数进入</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程2执行中&gt;&gt;&gt; pid=&#123;0&#125;,ppid=&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid(), os.getppid()))<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        time.sleep(<span class="hljs-number">3</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是子进程2 &quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程2终止&gt;&gt;&gt; pid=&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程执行中&gt;&gt;&gt; pid=&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br>    ps = []<br>    <span class="hljs-comment"># 创建子进程实例</span><br>    p1 = Process(target=worker, name=<span class="hljs-string">&quot;worker1&quot;</span> , args=())<br>    ps.append(p1)<br>    p2 = Process(target=worker2, name=<span class="hljs-string">&quot;worker2&quot;</span>, args=())<br>    ps.append(p2)<br>    <br>    <span class="hljs-comment"># 开启子进程并运行各自的执行空间</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        ps[i].start()<br>	<br>    <span class="hljs-comment"># 阻塞等待子进程退出并回收子进程资源</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        ps[i].join()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程终止&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	main()<br><br>主进程 遇到 p1.start 开启两个独立的子进程 独立运行互不影响<br></code></pre></td></tr></table></figure>



<p>3、 使用multiprocessing模块: 派生Process的子类，重写 run方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcess</span>(<span class="hljs-title class_ inherited__">Process</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        Process.__init__(self)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>): <span class="hljs-comment">#子进程1的执行空间</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程1开始&gt;&gt;&gt; pid=&#123;0&#125;,ppid=&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid(),os.getppid()))<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程1终止&gt;&gt;&gt; pid=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcess2</span>(<span class="hljs-title class_ inherited__">Process</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        Process.__init__(self)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>): <span class="hljs-comment">#子进程2的执行空间</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程2开始&gt;&gt;&gt; pid=&#123;0&#125;,ppid=&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid(),os.getppid()))<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程2终止&gt;&gt;&gt; pid=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(): <span class="hljs-comment">#原来的主进程</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程开始&gt;&gt;&gt; pid=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br>    p1 = MyProcess()  <span class="hljs-comment"># 创建了一个新的对象，本身就是一个子进程</span><br>    p2 = MyProcess2()<br><br>    p1.start()<br>    p2.start()<br><br>    p1.join()<br>    p2.join()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程终止&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	main()<br><span class="hljs-comment">#进程操作相同时，可以不需要重写类</span><br></code></pre></td></tr></table></figure>



<p>4、 使用进程池Pool</p>
<p>多进程构成一个池，如果需要从中获取，如果没有，则等待释放，节省资源</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">arg</span>): 任务函数<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程开始执行&gt;&gt;&gt; pid=&#123;&#125;,ppid=&#123;&#125;,编号&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid(),os.getppid(),arg))<br>    time.sleep(<span class="hljs-number">0.5</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;子进程终止&gt;&gt;&gt; pid=&#123;&#125;,ppid=&#123;&#125;,编号&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid(),os.getppid(),arg))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程开始执行&gt;&gt;&gt; pid=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br>    	<span class="hljs-comment">#一次行创建多个进程放到池里</span><br>    ps=Pool(<span class="hljs-number">5</span>) <span class="hljs-comment">#1024的上限值</span><br>	<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>    	<span class="hljs-comment">#ps.apply(worker,args=(i,)) </span><br>        			<span class="hljs-comment">#同步执行，有先后次序，依次执行,arg顺序增加</span><br> 		ps.apply_async(worker,args=(i,)) <br>        			<span class="hljs-comment">#异步执行，没有次序，随机启动，退出后资源重启</span><br>        <br>        ps.close()<span class="hljs-comment"># 关闭进程池，停止接受其它进程</span><br>       <br>		ps.join()	<span class="hljs-comment"># 阻塞进程</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>

<p>双工通信，一个进程收，一个进程发</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程一般是进程的一个内部资源。<br>多进程 &#x3D;&#x3D;》消耗资源大 &#x3D;&#x3D;》进程间通信 &#x3D;&#x3D;&#x3D;》同步协调<br>多线程 &#x3D;&#x3D;》互斥锁，信号量，共享内存</p>
<p>Python中使用线程有两种方式：函数 或者 用类来包装线程对象</p>
<p>函数式：</p>
<p>调用 _thread 模块中的start_new_thread()函数来产生 新线程<br>语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">_thread.start_new_thread ( function, args[, kwargs] )<span class="hljs-comment">#元组类型</span><br></code></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> _thread<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 为线程定义一个函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_time</span>(<span class="hljs-params"> threadName, delay</span>):<span class="hljs-comment">#线程执行空间</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:<br>        time.sleep(delay)<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;%s: %s&quot;</span>%(threadName, time.ctime(time.time())))<br>       <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mytest_thread</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br><br><span class="hljs-comment">#创建并启动线程    </span><br>_thread.start_new_thread( print_time, (<span class="hljs-string">&quot;Thread-1&quot;</span>, <span class="hljs-number">2</span>, ) )<br>_thread.start_new_thread( print_time, (<span class="hljs-string">&quot;Thread-2&quot;</span>, <span class="hljs-number">4</span>, ) )<br>_thread.start_new_thread(mytest_thread,()) <br>									<span class="hljs-comment">#参数2不能为空，必须是元组类型</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>: <span class="hljs-comment">#主进程不能退出，子线程运行依赖。</span><br>	<span class="hljs-keyword">pass</span> <span class="hljs-comment">#空指令，但必须执行 一次，防止机器高速空转</span><br>主进程不能退出，线程属于进程，如果进程退出线程也会随进程一起退出<br></code></pre></td></tr></table></figure>

<p> _thread 提供了低级别的、原始的线程以及一个简单的锁，<br>    它相比于 threading 模块的功能还是比较有限的。</p>
<h4 id="线程模块-threading"><a href="#线程模块-threading" class="headerlink" title="线程模块 threading"></a>线程模块 threading</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：<br>• threading.currentThread(): 返回当前的线程变量。<br>• threading.<span class="hljs-built_in">enumerate</span>(): 返回一个包含正在运行的线程的<span class="hljs-built_in">list</span>。<br><br>正在运行指线程启动后、结束前，不包括启动前和终止后的线程。<br>• threading.activeCount(): 返回正在运行的线程数量，与<span class="hljs-built_in">len</span>(threading.<span class="hljs-built_in">enumerate</span>())有相同的结果。<br><br>除了使用方法外，线程模块同样提供了Thread类来处理线程，<br>Thread类提供了以下方法:<br>◇ run(): 用以表示线程活动的方法，由子线程执行。<br>◇ start():启动线程活动，由主进程执行。<br><br>◇ join([time]): 等待子线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。<br>◇ isAlive(): 返回线程是否活动的。<br>◇ getName(): 返回线程名。<br>◇ setName(): 设置线程名<br></code></pre></td></tr></table></figure>

<p>可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程， 即它调用线程的 run() 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myThread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, threadID, name, counter</span>):<br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 子线程的执行空间位置</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始线程：&quot;</span> + self.name)<br>        print_time(self.name, self.counter, <span class="hljs-number">5</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出线程：&quot;</span> + self.name)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_time</span>(<span class="hljs-params">threadName, delay, counter</span>):<br>    <span class="hljs-comment"># 子线程的执行函数，内容可以自定义</span><br>    <span class="hljs-keyword">while</span> counter:<br>        time.sleep(delay)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s: %s&quot;</span> % (threadName,time.ctime(time.time())))<br> 		counter -= <span class="hljs-number">1</span><br> 	exit() <span class="hljs-comment"># 建议退出位置</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程开始&quot;</span>)<br><span class="hljs-comment"># 创建新线程</span><br>thread1 = myThread(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Thread-1&quot;</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 1 是线程id “Thread-1” 是线程名称 1 线程内部参数，此处用于时</span><br>thread2 = myThread(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Thread-2&quot;</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启新线程</span><br>thread1.start() <span class="hljs-comment"># 启动执行线程</span><br>thread2.start()<br><span class="hljs-comment"># 回收资源</span><br>thread1.join()<span class="hljs-comment">#阻塞等待tdread1结束		</span><br>thread2.join()<span class="hljs-comment">#阻塞等待tdread2结束</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出主线程&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>使用以上两个线程创建方式之一，完成多个不同线程的任意输出<br>(可以通过线程名进行判断区分，if-else)</p>
<p>扩展内容： 线程同步 线程优先级队列</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>SQL(Structured Query Language 结构化查询语句)是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统</p>
<p>SQL基于关系代数和元组关系演算，包括一个数据定义语言和数据操控语言。<br>SQL的范围包括数据插入、查询、更新、和删除，数据库模式创建修改已经数据访问控制</p>
<h2 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h2><p>SQLite，是一款轻型的关系型数据库，是遵守ACID的关系型数据库管理系统，<br>它的设计目标是”嵌入式”的，而且已经在很多嵌入式产品中使用了它，<br>它占用资源非常的低，它能够支持Windows&#x2F;Linux&#x2F;Unix等等主流的操作系统， 同时能够跟很多程序语言相结合,并且支持标准的SQL语句</p>
<p>文件型数据库</p>
<p>不支持网络操作，数据容量只有4T</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ACID:</span>关系型数据库的特性<br>原子性（atomicity，或称不可分割性）、<br>一致性（consistency）、<br>隔离性（isolation，又称独立性）、<br>持久性（durability）。<br></code></pre></td></tr></table></figure>

<p>SQL 结构化查询语言 &#x3D;&#x3D;》数据库脚本语言</p>
<p>下载地址：<a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a></p>
<p>(压缩打开，添加环境变量后直接使用)</p>
<h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span>值(不是空值)<br><span class="hljs-type">INTEGER</span> 带符号的整数<br><span class="hljs-type">REAL</span> 浮点值(<span class="hljs-number">8</span>字节)<br>TEXT 文本字符串(UTF<span class="hljs-number">-8</span>,UTF<span class="hljs-number">-16</span>BE,UTF<span class="hljs-number">-16</span>LE)<br><span class="hljs-type">BLOB</span> <span class="hljs-type">BLOB</span>数据类型<br>(Sqlite 没有单独的<span class="hljs-type">Boolean</span>类型,在数据库中存储为整数<span class="hljs-number">0</span>(<span class="hljs-literal">false</span>),<span class="hljs-number">1</span>(<span class="hljs-literal">true</span>))<br>(Sqlite 没有单独的<span class="hljs-type">Date</span>类,存储时会变成TEXT,<span class="hljs-type">INTEGER</span>,<span class="hljs-type">REAL</span>类型)<br></code></pre></td></tr></table></figure>



<h3 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">D:\ dir 查看目录下文件信息<br>D:\ cls 清理屏幕显示<br>D:\ cd  xxx 进入到目标代码目录<br><br>D:\ sqlite3 回车 命令行会自动进入该目录下<br>D:\ sqlite3 test.db 新建一个数据库<br>sqlite<span class="hljs-operator">&gt;</span> 表示正常进入到dbms系统中 （.q退出）<br></code></pre></td></tr></table></figure>

<p>先有数据库 &#x3D;&#x3D;》创建数据表 &#x3D;&#x3D;》增加数据 &#x3D;&#x3D;》维护（增加，删 除，修改，查询）</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>1、创建数据库文件并登录；<br> Sqlite3 test.db &#x3D;&#x3D;&#x3D;》.db 后缀的是数据库文件，其中允许创建多个表格。<br> 手工创建 xxx.db 也可以，只要保证文件后缀是 .db 即可。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>2、在数据库中新建表； SQL 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">create table test(id int , name text, pass text);<br></code></pre></td></tr></table></figure>

<p>注意：表名（test） 可以自由定义，表的字段名称也可以自由定义 但是类型要正确，必须为存储类型中的一种<br>            如果出现 syntax error 表示SQL 语句有语法错误</p>
<p>.tables 查看创建的表是否成功，不是标准sql语句，是sqlite3内置命令</p>
<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">create table test (id integer primary key autoincrement notnull,name text);<br></code></pre></td></tr></table></figure>

<p>id integer primary key autoincrement not null (限制id属性，每行自动增长)<br> 整形   		主键 			自动增长 				非空</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>3、向数据库中插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test (name) <span class="hljs-keyword">values</span> (&quot;bilibili&quot;); #指定值插入<br>	inser <span class="hljs-keyword">into</span> 是插入关键字 <br>	test 是表名称 <br>	name是表中的列名称 <br>	<span class="hljs-keyword">values</span>是关键字<br>	“bilibili”是插入的列对应的数据值。<br>	<span class="hljs-keyword">SQL</span> 语句默认以 “ ; ” 结尾标识。<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test(id,name,pass) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,&quot;zhang&quot;,&quot;123345&quot;); <br>	#全列匹配插入<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,&quot;asd&quot;,“<span class="hljs-number">2345</span>”); <br>	#全列默认匹配插入，必须值一一匹配<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test (id,name) <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>,&quot;afasdf&quot;); <br>	#指定值插入<br></code></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>4、查询所有表中数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test; #查询所有表中记录并打印输出<br>	<span class="hljs-keyword">select</span> 是查询关键字<br>	<span class="hljs-operator">*</span> 是通配符，表示所有列都输出<br>	<span class="hljs-keyword">from</span> 是关键字<br>	test 是表名字<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">where</span> 辅助查询关键字，限定范围<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> pass <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span>“张三”; #与<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;	#或<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br><br>#指定列 <span class="hljs-operator">*</span>查所有列<br><span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> test; 	#指定 列 的时候可以间隔列名<br><span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; #列名和限定词一起组合查询<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> doctor <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = &quot;xxx&quot;;<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> doctor <span class="hljs-keyword">where</span> id &gt;= <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>5、修改指定表中数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> test <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span> ; #会修改表中所有name记录(一列） ，慎用<br>	<span class="hljs-keyword">update</span> 是修改关键字<br>	test 是修改的表名字<br>	<span class="hljs-keyword">set</span> 是设置关键字<br>	name 是列名字<br>	<span class="hljs-operator">=</span> ”xxx“ 是修改后的值<br><br>#整常情况下，需要<span class="hljs-keyword">where</span>限定成某一行 <br><span class="hljs-keyword">update</span> test <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;xxx&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">update</span> test <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;xxx&quot;, pass <span class="hljs-operator">=</span> &quot;yyy&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">update</span> test <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;xxx&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> pass <span class="hljs-operator">=</span> <span class="hljs-number">2345</span>;<br></code></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>6、删除表中指定数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 是删除关键字<br>	test 是要删除信息的表名字<br>	<span class="hljs-keyword">where</span> 限定词<br>	id<span class="hljs-operator">=</span><span class="hljs-number">1</span> 限定条件<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> pass <span class="hljs-operator">=</span> <span class="hljs-number">2345</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">or</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test ; #删除表test中所有数据，直接删除无法恢复。慎用<br></code></pre></td></tr></table></figure>

<p>7、退出数据库<br>      以下不属于sql语句，属于数据库sqltie3自己的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">.exit .q #退出<br>	.tables //显示当前数据库的表格<br> 	.schema tablename; //显示表格结构<br> 	.help #显示DBMS中所有相关的内部指令<br></code></pre></td></tr></table></figure>

<p>​	可视化操作 	<a href="http://sqliteadmin.orbmu2k.de/">http://sqliteadmin.orbmu2k.de/</a>      sqlite administor</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>、 删除表<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> test1; <br><br><span class="hljs-number">2</span>、 排序 默认是 <span class="hljs-keyword">ASC</span>:升序,    <span class="hljs-keyword">DESC</span>:降序 不区分大小写<br>	id <span class="hljs-keyword">ASC</span> ; id <span class="hljs-keyword">DESC</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> price <span class="hljs-operator">&lt;</span> <span class="hljs-number">103</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> price <span class="hljs-keyword">desc</span> limit <span class="hljs-number">5</span> ;<br>	# <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> xxx 按照xxx所在的列排序<br>	# limit num 只需要查询指定的前num个数据<br><br><span class="hljs-number">3</span>、去重<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> name <span class="hljs-keyword">from</span> test;<br><br><span class="hljs-number">4</span>、模糊查询<br><span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;200%&#x27;</span>  查找以 <span class="hljs-string">&#x27;200 开头&#x27;</span>的任意值<br><span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%200%&#x27;</span> 查找任意位置<span class="hljs-string">&#x27;包含 200 &#x27;</span>的任意值<br><span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_00%&#x27;</span>  查找<span class="hljs-string">&#x27;第二位和第三位为 00 &#x27;</span>的任意值<br><span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;2_%_%&#x27;</span> 查找以 <span class="hljs-number">2</span> 开头，且长度至少为 <span class="hljs-number">3</span>个字符的任意值<br>	#其中 _ 是一个占位符， <span class="hljs-operator">%</span>是任意长度占位 <br></code></pre></td></tr></table></figure>

<h3 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">5</span>、<span class="hljs-keyword">where</span> 子句：<br>	<span class="hljs-keyword">and</span> :在<span class="hljs-keyword">where</span>中可以连接多个条件<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">13</span> <span class="hljs-keyword">and</span> price <span class="hljs-operator">&gt;=</span> <span class="hljs-number">105</span>;<br><br>	<span class="hljs-keyword">or</span> :或<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">13</span> <span class="hljs-keyword">or</span> price <span class="hljs-operator">&lt;</span> <span class="hljs-number">200</span>;<br><br>	<span class="hljs-keyword">not</span> <span class="hljs-operator">!=</span> :否定,一般和<span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">between</span> 等合用<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name <span class="hljs-operator">!=</span> &quot;aaa&quot;<br><br>	<span class="hljs-keyword">between</span> :在两个值之间进行搜索<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">12</span> <span class="hljs-keyword">and</span> <span class="hljs-number">17</span>; <br><br>	<span class="hljs-keyword">in</span> :返回值等于匹配值的数据<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">12</span>,<span class="hljs-number">15</span>);<br><br>	<span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> :和<span class="hljs-keyword">in</span>相反<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">12</span>,<span class="hljs-number">15</span>);<br><br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Y%&#x27;</span>;<br> <br>	<span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> :用于把某个值和<span class="hljs-keyword">NULL</span>进行比对<br>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br> <br><span class="hljs-keyword">is</span> :类似于 <span class="hljs-operator">=</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> :类似于 <span class="hljs-operator">!=</span><br><br></code></pre></td></tr></table></figure>

<p>6、导入导出</p>
<p>导出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">导出命令：<br>sqlite3 data.db <br><span class="hljs-operator">&gt;</span>.output dd.sql 导出的数据库脚本名称为 dd.sql <br><span class="hljs-operator">&gt;</span>.dump 导出所有数据<br><span class="hljs-operator">&gt;</span>.q 退出数据库<br><br>另一种：<br>sqltie3 xxx.db .dump <span class="hljs-operator">&gt;</span> yyy.sql 在数据库尚未登录时候操作<br> <span class="hljs-operator">&gt;</span> 符号在这里表示输出到某个文件<br> #doc的输出重定向<br></code></pre></td></tr></table></figure>

<p>导入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">导入命令: <br>sqlite3 新数据库.db <br><span class="hljs-operator">&gt;</span>.read dd.sql <br><span class="hljs-operator">&gt;</span>.tables 查看导入效果<br><br>另一种：<br>sqlite3 xxx.db <span class="hljs-operator">&lt;</span> xxx.sql<br>	<span class="hljs-operator">&lt;</span> 符号在这里表示从某个脚本导入文件内容<br></code></pre></td></tr></table></figure>



<h3 id="Python-与-sqlite3的接口"><a href="#Python-与-sqlite3的接口" class="headerlink" title="Python 与 sqlite3的接口"></a>Python 与 sqlite3的接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、首先需要导入sqlite3模块<br>	<span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-number">2</span>、连接数据库（如果数据库不存在则创建新的数据库）<br>	con = sqlite3.connnect(<span class="hljs-string">&quot;test.db&quot;</span>)	<span class="hljs-comment">#创建对象</span><br><span class="hljs-number">3</span>、创建游标  <span class="hljs-comment">#临时的保存 所有操作都会储存在游标，所有最后需要提交</span><br>	cur = con.cursor()	<br><br><span class="hljs-number">4</span>、常规的 增删改查 等SQL操作<br>sql = <span class="hljs-string">&quot;CREATE TABLE IF NOT EXISTS test(id INTEGER PRIMARY KEY,name TEXT,age INTEGER)&quot;</span> <span class="hljs-comment">#组织SQL命令串</span><br><span class="hljs-comment">#str = &quot;insert into user values (7,&#x27;wo&#x27;,&#x27;8888&#x27;);&quot;</span><br><span class="hljs-comment">#str = &quot;delete from user where id = 7;&quot;</span><br><span class="hljs-comment">#str = &quot;update user set pass =&#x27;123456&#x27; where id = 6;&quot;</span><br>cur.execute(sql) <span class="hljs-comment">#执行SQL命令串</span><br><br>查询：<br>cur.execute(<span class="hljs-string">&#x27;SELECT * FROM user&#x27;</span>)<br><span class="hljs-comment"># print(cur.fetchone()) #取游标第一行数据形成元组</span><br><span class="hljs-comment"># res = cur.fetchmany(3) #取多行指定数据形成列表</span><br><span class="hljs-comment"># print(res) #结果是列表中存储的三行元组信息</span><br><span class="hljs-comment"># res = cur.fetchall() #取表中所有数据记录</span><br><span class="hljs-comment"># for line in res: #遍历所有的查询记录</span><br><span class="hljs-comment"># print(line) #以元组形式输出所有select的结果数据</span><br><br><span class="hljs-number">5</span>、事务的提交和回滚<br>con.commit() <span class="hljs-comment">#提交 正式生效到数据库文件</span><br>con.rollback() <span class="hljs-comment">#回滚 撤销刚才的内存操作</span><br><br><span class="hljs-number">6</span>、断开会话连接，释放资源 <br>cur.close() <span class="hljs-comment"># 关闭游标</span><br>con.close() <span class="hljs-comment"># 断开数据库连接</span><br></code></pre></td></tr></table></figure>

<p> 用户自定义输入</p>
<p>添加表中数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入要插入数据库的id,name,pass的数据&quot;</span>)<br><span class="hljs-built_in">id</span>= <span class="hljs-built_in">input</span>()<br>name=<span class="hljs-built_in">input</span>()<br>pasd=<span class="hljs-built_in">input</span>()<br><span class="hljs-comment">#1 字符串的拼装</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;insert into user values (&quot;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>)+<span class="hljs-string">&quot;,&#x27;&quot;</span>+name+<span class="hljs-string">&quot;&#x27;,&#x27;&quot;</span>+pasd+<span class="hljs-string">&quot;&#x27;);&quot;</span><br><span class="hljs-comment">#2 用元组占位拼装</span><br>cur.execute(<span class="hljs-string">&quot;insert into user values (%d,&#x27;%s&#x27;,&#x27;%s&#x27;);&quot;</span>%(<span class="hljs-built_in">id</span>,name,pasd))<br><span class="hljs-comment">#3 用问号占位拼装（和&#123;&#125;一样）</span><br>cur.execute(<span class="hljs-string">&quot;insert into user values (?,?,?);&quot;</span>,(<span class="hljs-built_in">id</span>,name,pasd))<br></code></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br>con = sqlite3.connect(<span class="hljs-string">&quot;text.db&quot;</span>)<br>cur = con.cursor()<br> <span class="hljs-comment">#sql = &quot;insert into user values (7,&#x27;wo&#x27;,&#x27;8888&#x27;);&quot;</span><br> <span class="hljs-comment">#sql = &quot;delete from user where id = 7;&quot;</span><br> <span class="hljs-comment">#sql = &quot;update user set pass =&#x27;123456&#x27; where id = 6;&quot;</span><br><span class="hljs-built_in">id</span> = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入id&quot;</span>)<br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入name&quot;</span>)<br>passd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入passwd&quot;</span>)<br><br>sql = <span class="hljs-string">&quot;insert into use values (&#123;&#125;,&#x27;&#123;&#125;&#x27;,&#x27;&#123;&#125;&#x27;);&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>,name,passd)<br><br>cur.execute(sql)<br>cun.commit()<br>con.close()<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">注意：关于数据库句柄和游标还有如下属性说明<br>sqlite3的方法说明：<br><br>connect方法返回con对象，即是数据库链接对象，它提供了以下方法：<br>.cursor() 方法来创建一个游标对象<br>.commit() 方法来处理事务提交<br>.rollback() 方法来处理事务回滚<br>.close() 方法来关闭一个数据库连接<br><br>对数据库的查询需要使用到游标对象，首先通过cursor()<span class="hljs-string">&#x27;建一个游标对象：</span><br><span class="hljs-string"></span><br><span class="hljs-string">游标对象有以下方法支持数据库操作：</span><br><span class="hljs-string">.execute()用来执行sql语句</span><br><span class="hljs-string">.executemany()用来执行多条sql语句</span><br><span class="hljs-string">.close() 用来关闭游标</span><br><span class="hljs-string">.fetchone()用来从结果中取一条记录，并将游标指向下一条记录</span><br><span class="hljs-string">.fetchmany()用来从结果中取多条记录。</span><br><span class="hljs-string">.fetchall()用来从结果中取出所以记录</span><br><span class="hljs-string">.scroll()用于游标滚动</span><br></code></pre></td></tr></table></figure>

<p><a href="file:///D:/笔记/python/python/python--数据库--sqlite3.pdf">python–数据库–sqlite3.pdf</a>  例子 ？</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>安装：(<a href="https://www.mysql.com/cn/downloads/)%E5%AE%98%E7%BD%91">https://www.mysql.com/cn/downloads/)官网</a></p>
<p>可视化工具：Navicat for MySQL</p>
<h3 id="基本维护操作"><a href="#基本维护操作" class="headerlink" title="基本维护操作"></a>基本维护操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">1.停止/启动mysql服务<br>C:\Users\chen&gt;net stop mysql	#停<br>The MySQL service is stopping....<br>The MySQL service was stopped successfully.<br><br>C:\Users\chen&gt;net start mysql	#起<br>The MySQL service is starting..<br>The MySQL service was started successfully.<br><br>2.进入mysql<br>C:\Users\chen&gt;mysql -u root -p<br>Enter password: ******<br></code></pre></td></tr></table></figure>

<p>pymysql 应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> timeit <span class="hljs-keyword">import</span> default_timer<br><br><br>host = <span class="hljs-string">&#x27;localhost&#x27;</span><br>port = <span class="hljs-number">3306</span><br>db = <span class="hljs-string">&#x27;mysql_test&#x27;</span><br>user = <span class="hljs-string">&#x27;mysql_test&#x27;</span><br>password = <span class="hljs-string">&#x27;mysql_test&#x27;</span><br><br><span class="hljs-comment"># ---- 用pymysql 操作数据库</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_connection</span>():	<span class="hljs-comment">#连接到mysql</span><br>	conn = pymysql.connect(host=host, port=port, db=db, user=user,password=password)<br>	<span class="hljs-keyword">return</span> conn<br><br><span class="hljs-comment"># ---- 使用 with 的方式来优化代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UsingMysql</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, commit=<span class="hljs-literal">True</span>, log_time=<span class="hljs-literal">True</span>, log_label=<span class="hljs-string">&#x27;总用时&#x27;</span></span>):<br> 		<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">	  :param commit: 是否在最后提交事务(设置为False的时候方便单元测试)</span><br><span class="hljs-string"> 	  :param log_time: 是否打印程序运行总时间</span><br><span class="hljs-string"> 	  :param log_label: 自定义log的文字</span><br><span class="hljs-string">		&quot;&quot;&quot;</span><br>        <br>        self._log_time = log_time	<span class="hljs-comment">#日志时间</span><br> 		self._commit = commit		<span class="hljs-comment">#日志标签</span><br>		self._log_label = log_label	<span class="hljs-comment">#是否打印日志</span><br>        <br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-comment"># 如果需要记录时间</span><br>		<span class="hljs-keyword">if</span> self._log_time <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>			self._start = default_timer()<br>        <br>		<span class="hljs-comment"># 在进入的时候自动获取连接和cursor</span><br>		conn = get_connection()<br>        	<span class="hljs-comment">#创建游标</span><br>		cursor = conn.cursor(pymysql.cursors.DictCursor)<br>		conn.autocommit = <span class="hljs-literal">False</span>	<span class="hljs-comment">#提交到数据库操作，默认关闭</span><br>        <br>        self._conn = conn<br>		self._cursor = cursor<br>		<span class="hljs-keyword">return</span> self<br>    <br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, *exc_info</span>):<br>        <span class="hljs-comment"># 提交事务</span><br>        <span class="hljs-keyword">if</span> self._commit:<br>        	self._conn.commit()<br>        <span class="hljs-comment"># 在退出的时候自动关闭连接和cursor</span><br>        self._cursor.close()<br>        self._conn.close()<br>        <br>        <span class="hljs-keyword">if</span> self._log_time <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br> 			diff = default_timer() - self._start<br> 			<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-- %s: %.6f 秒&#x27;</span> % (self._log_label, diff))<br>            <br><span class="hljs-meta">        @property</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">cursor</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-keyword">return</span> self._cursor<br> <span class="hljs-comment">#封装结束</span><br>==========================================================        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_it</span>():<br>    <span class="hljs-keyword">with</span> UsingMysql(log_time=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> um:<br>        um.cursor.execute(<span class="hljs-string">&quot;select count(id) as total from Product&quot;</span>)<br>        data = um.cursor.fetchone()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-- 当前数量: %d &quot;</span> % data[<span class="hljs-string">&#x27;total&#x27;</span>])<br><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	check_it()        <br></code></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫</title>
    <url>/2020/12/18/Python/%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h1><p>什么是爬虫</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-number">1.</span>通过一个程序，根据<span class="hljs-built_in">url</span>进行爬取网页，获取有用信息<br><span class="hljs-number">2.</span>使用程序模拟浏览器，去向服务器发送请求，获取相应信息<br></code></pre></td></tr></table></figure>

<p>核心</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.爬取网页：爬取整个网页，包含网页中所有的内容<br>2.解析数据：将网页中你得到的数据 进行解析<br>3.难点，爬虫与反爬虫之间的博弈<br></code></pre></td></tr></table></figure>

<p>用途</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">数据分析/人工数据集 <br></code></pre></td></tr></table></figure>

<p>分类</p>
<p>通用爬虫</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">通用爬虫：<br>	实例<br>		百度、<span class="hljs-number">360</span>、google、sougou等搜索引擎‐‐‐伯乐在线<br>	功能<br>		访问网页‐&gt;抓取数据‐&gt;数据存储‐&gt;数据处理‐&gt;提供检索服务<br>	robots协议<br>		一个约定俗成的协议，添加robots.txt文件，来说明本网站哪些内容不可以被抓取，起不到限制作用<br>		<span class="hljs-comment">#自己写的爬虫无需遵守</span><br>	网站排名(SEO)<br>		<span class="hljs-number">1.</span> 根据pagerank算法值进行排名（参考个网站流量、点击率等指标）<br>		<span class="hljs-number">2.</span> 百度竞价排名<br>	缺点<br>		<span class="hljs-number">1.</span> 抓取的数据大多是无用的<br>		<span class="hljs-number">2.</span>不能根据用户的需求来精准获取数据<br></code></pre></td></tr></table></figure>

<p>聚焦爬虫</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">根据需求，实现爬虫程序，抓取需要的数据<br>设计思路<br>	<span class="hljs-number">1</span>.确定要爬取的url<br>	<span class="hljs-number">2</span>.模拟浏览器通过http协议访问url，获取服务器返回的<span class="hljs-selector-tag">html</span>代码<br>	<span class="hljs-number">3</span>.解析<span class="hljs-selector-tag">html</span>代码（根据一定规则提取需要的数据）<br></code></pre></td></tr></table></figure>



<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;！DOCTYPE html&gt; 声明为html5文档<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    	头部信息...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span> = <span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> 页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  table 表格 tr 行 td列--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> 可见文档主体<br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>html 超文本标记语言  <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage<br>html文档也叫做web页面</p>
<p>doctype 声明是不区分大小写的，用来告知 Web 浏览器页面使用了哪种 HTML 版本</p>
<p>web浏览器用于读取html文件，并将其作为网页显示</p>
<h3 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h3><p>html 标题<br>    通过<h1> - <h6>来定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>... 逐级递减<br></code></pre></td></tr></table></figure>

<p>html 段落	<p>来定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另外一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>html 连接  标签<a>来定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>html 图像 通过 <img>来定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/images/logo.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;258&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;39&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>图像的名称和尺寸以属性形式提供</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- ul li 无序列表 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>喵喵喵<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>汪汪汪<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- ol li	有序列表 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> 第一步<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> 第二步<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h4><p>编码的格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。例如空格的编码值是”%20”</p>
<p>先转ASCII码，在转16进制</p>
<h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><h3 id="urllib库基本使用"><a href="#urllib库基本使用" class="headerlink" title="urllib库基本使用"></a>urllib库基本使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">urllib.request.urlopen() 模拟浏览器向服务器发送请求<br>response 服务器返回的数据<br>	response的数据类型是HttpResponse<br>	字节‐‐&gt;字符串<br>			解码decode<br>	字符串‐‐&gt;字节<br>			编码encode<br>       read() 字节形式读取二进制 扩展：rede(<span class="hljs-number">5</span>)返回前几个字节<br>       readline() 读取一行<br>       readlines() 一行一行读取 直至结束<br>       getcode() 获取状态码<br>       geturl() 获取url<br>       getheaders() 获取headers<br><br>   urllib.request.urlretrieve() <span class="hljs-comment">#下载</span><br>       请求网页<br>       请求图片<br>       请求视频<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br><br>url = <span class="hljs-string">&#x27;http://www.daidu.com&#x27;</span><br><span class="hljs-comment"># url = &#x27;https://fanyi.baidu.com&#x27;</span><br><span class="hljs-comment"># 模拟浏览器向服务器发送请求</span><br>response = urllib.request.urlopen(url)<br><br><span class="hljs-comment"># 获取相应中的页面源码</span><br>    <span class="hljs-comment">#read方法 返回的是字节形式的二进制数据</span><br>    <span class="hljs-comment">#将二进制的数据转换为字符串，解码 decode(“utf-8”)</span><br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure>

<h4 id="一个类型"><a href="#一个类型" class="headerlink" title="一个类型"></a>一个类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">response = urllib.request.urlopen(url)<br>ptint (<span class="hljs-built_in">type</span>(response))<br><span class="hljs-comment"># response 是HTTPResponse类型</span><br></code></pre></td></tr></table></figure>

<h4 id="六个方法"><a href="#六个方法" class="headerlink" title="六个方法"></a>六个方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">content = response.read()	<span class="hljs-comment">#read()按字节读取</span><br><br>content = response.readline() <span class="hljs-comment">#readline 读取一行</span><br><br>content = response.readlines() <span class="hljs-comment">#按行读取到结束</span><br><br><span class="hljs-comment">#返回状态码 </span><br><span class="hljs-built_in">print</span>(response.getcode()) <span class="hljs-number">200</span>访问成功<br><br><span class="hljs-comment">#返回url地址</span><br><span class="hljs-built_in">print</span>(response.geturl())<br><br><span class="hljs-comment">#获取状态信息</span><br><span class="hljs-built_in">print</span>(response.getheaders())<br></code></pre></td></tr></table></figure>

<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>urlretrieve(url , filename)</p>
<p>url代表 下载路径，filename保存文件名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">url_page = <span class="hljs-string">&#x27;http://baidu.com&#x27;</span><br>urllib.request.urlretrieve(url_page,<span class="hljs-string">&#x27;baidu.html&#x27;</span>)<br><br>url_img = <span class="hljs-string">&#x27;&#x27;</span><br>urllib.request.urlretrieve(url_img, <span class="hljs-string">&#x27;jxy.jpg&#x27;</span>)<br><br>url_video = <span class="hljs-string">&#x27;&#x27;</span><br>urllib.request.urlretrieve(url_video,<span class="hljs-string">&#x27;jxy.mp4&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="请求对象的定制"><a href="#请求对象的定制" class="headerlink" title="请求对象的定制"></a>请求对象的定制</h3><p>请求对象的定制是解决反爬 的第一种手段</p>
<p>url组成</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">https</span>://www.baidu.com/s?wd=xxx<br><br><span class="hljs-keyword">http</span>/<span class="hljs-keyword">https</span>    www.baidu.com    <span class="hljs-number">80</span>/<span class="hljs-number">443</span>     s    wd=xxx    <span class="hljs-comment">#</span><br>   协议			域名/主机		端口号    路径     参数    锚点<br>   <br><span class="hljs-keyword">http</span> <span class="hljs-number">80</span>		<span class="hljs-keyword">https</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">UA介绍：Uesr Agent 用户代理，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本，CPU 类型，浏览器及版本。<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">语法：request = urllib.requset.Request()<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> urllib.request<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;user-agent&#x27;</span>:<span class="hljs-string">&#x27; Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br>&#125;<br><br>response = urllib.request.urlopen(url,headers) <span class="hljs-comment">#错误写法</span><br><br><span class="hljs-comment">#因为urlopen 方法中不能存储字典，所以headers不能传递进去，可以传递Request对象</span><br>  则需要请求对象的定制<br>    <br>url = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span><br><span class="hljs-number">1.</span>请求对象的定制<br>request = urllib.request.Request(url = url ,headers= headers)<br><span class="hljs-comment">#注意 因为参数顺序的问题 不能直接写url 和headers 中间还有data参数，所以我们需要关键字传参</span><br><br><span class="hljs-number">2.</span>模拟浏览器向服务器发送请求<br>response = urllib.request.urlopen(request)<br><br><span class="hljs-number">3.</span>获取响应内容<br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-number">4.</span>打印数据<br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure>

<h3 id="get请求（编解码）"><a href="#get请求（编解码）" class="headerlink" title="get请求（编解码）"></a>get请求（编解码）</h3><h4 id="1-get请求方式：urllib-parse-quote"><a href="#1-get请求方式：urllib-parse-quote" class="headerlink" title="1.get请求方式：urllib.parse.quote( )"></a>1.get请求方式：urllib.parse.quote( )</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">UnicodeEncodeError: <span class="hljs-string">&#x27;ascii&#x27;</span> codec can<span class="hljs-string">&#x27;t encode characters in position 10-12: ordinal not in range(128)</span><br></code></pre></td></tr></table></figure>

<p>不同类型编码，在一起无法识别，转为unicode编码的格式</p>
<p>依赖于	urllib.parse</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.parse<br><br>name = urllib.parse.quote(<span class="hljs-string">&#x27;毛不易&#x27;</span>) <span class="hljs-comment">#将其转为unicode编码</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.parse<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br><br>    &#125;<br>url = <span class="hljs-string">&#x27;https://www.baidu.com/s?wd=&#x27;</span><br>name = urllib.parse.quote(<span class="hljs-string">&#x27;毛不易&#x27;</span>)<br>url = url + name<br><br>request = urllib.request.Request(url = url ,headers= headers)<br><br>response = urllib.request.urlopen(request)<br><br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure>

<h4 id="2-get请求方式：urllib-parse-urlencode"><a href="#2-get请求方式：urllib-parse-urlencode" class="headerlink" title="2.get请求方式：urllib.parse.urlencode"></a>2.get请求方式：urllib.parse.urlencode</h4><p>urlencode应用场景：多个参数的时候</p>
<p>‘ wd&#x3D; ‘搜索 ：将中文转为urlencode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span>  urllib.request<br><span class="hljs-keyword">import</span>  urllib.parse<br>date =&#123;<br>    <span class="hljs-string">&#x27;wd&#x27;</span>:<span class="hljs-string">&#x27;毛不易&#x27;</span>,<br>    <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br>base_url = <span class="hljs-string">&#x27;https://www.baidu.com/s?&#x27;</span><br><br>******new_date = urllib.parse.urlencode(date) <br><br>url = base_url + new_date<br><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br> &#125;<br><span class="hljs-comment">#请求对象的定制</span><br>request = urllib.request.Request(url = url,headers = headers)<br><span class="hljs-comment">#模拟浏览器发送请求</span><br>response = urllib.request.urlopen(request)<br><span class="hljs-comment">#获取网页源码</span><br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(content)<br><br></code></pre></td></tr></table></figure>

<h4 id="3-post请求"><a href="#3-post请求" class="headerlink" title="3.post请求"></a>3.post请求</h4><p>post请求需要传递参数</p>
<p>urlencode 解码 后需要encode编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#post 请求方式的参数 必须解码</span><br>data = urllib.parse.urlencode(data)<br><br><span class="hljs-comment">#编码之后 必须调用encode方法 </span><br>	(requset data参数接收字节变量，unicode编码是<span class="hljs-built_in">str</span>类型)<br>data = urllib.parse.urlencode(data).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-comment">#参数是放在请求对象定制的方法中</span><br>request = urllib.request.Request(url = url,data = data, headers =  headers)<br><br></code></pre></td></tr></table></figure>

<p>eg.百度翻译实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.parse<br><span class="hljs-keyword">import</span> urllib.request<br><br>url = <span class="hljs-string">&#x27;https://fanyi.baidu.com/sug&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br> &#125;<br><br>keyword = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要翻译的内容&quot;</span>)<br>data = &#123;<br>    <span class="hljs-string">&#x27;kw&#x27;</span>:keyword<br>&#125;<br><br><span class="hljs-comment">#post请求的参数，必须要进行encode编码</span><br>data = urllib.parse.urlencode(data).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-comment">#post的请求的参数 是不会拼接在url后面的，而是放在请求对象的定制的参数中</span><br><span class="hljs-comment">#post请求的参数 必须要进行编码</span><br><br>request = urllib.request.Request(url = url ,data= data,headers=headers)<br>response = urllib.request.urlopen(request)<br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>content 类型为<span class="hljs-built_in">str</span>  不可读<br>json字符串 转为 json对象 则为正常中文编码<br><span class="hljs-comment">#字符串 ———》 json对象</span><br><br><span class="hljs-keyword">import</span> json<br>obj = json.loads(content)<br><span class="hljs-built_in">print</span>(obj)<br></code></pre></td></tr></table></figure>

<p>总节：post和get区别？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>：get请求方式的参数必须编码，参数是拼接到url后面，编码之后不需要调用encode方法<br><span class="hljs-number">2</span>：post请求方式的参数必须编码，参数是放在请求对象定制的方法中，编码之后需要调用encode方法<br></code></pre></td></tr></table></figure>



<p>案例：百度翻译详细翻译</p>
<p>反爬机制 Cookie 和 token 认证（常理应该解决，但仍无法爬取）</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>



<h3 id="ajax的get请求"><a href="#ajax的get请求" class="headerlink" title="ajax的get请求"></a>ajax的get请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">当在headers中看到<br><span class="hljs-string">&#x27;X-Requested-With: XMLHttpRequest&#x27;</span><br>则为ajax请求<br></code></pre></td></tr></table></figure>

<p>豆瓣电影</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#爬取豆瓣电影前10页数据</span><br><br><br><span class="hljs-comment">#下载豆瓣电影前10页的数据</span><br><span class="hljs-keyword">import</span> urllib.parse<br><span class="hljs-keyword">import</span> urllib.request<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_request</span>(<span class="hljs-params">page</span>):<span class="hljs-comment">#1.请求对象定制</span><br>    base_url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;&#x27;</span><br><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br>    &#125;<br><br>    base_date = &#123;<br>        <span class="hljs-string">&#x27;start&#x27;</span> : (page - <span class="hljs-number">1</span>) * <span class="hljs-number">20</span>,<br>        <span class="hljs-string">&#x27;limit&#x27;</span> : <span class="hljs-number">20</span><br>    &#125;<br><br>    date = urllib.parse.urlencode(base_date)<br><br>    url = base_url + date<br><br>    requset = urllib.request.Request(url = url , headers= headers)<br><br>    <span class="hljs-keyword">return</span> requset<br><br><span class="hljs-comment">#获取响应内容</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_content</span>(<span class="hljs-params">request</span>): <br>    response = urllib.request.urlopen(request)<br>    content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">return</span> content<br><br><span class="hljs-comment">#下载</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">down_load</span>(<span class="hljs-params">content</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;douban.json&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>,encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(content)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入起始的页码&#x27;</span>))<br>    end_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入结束的页面&#x27;</span>))<br><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_page,end_page+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment">#每一页都要有自己的请求对象定制</span><br>        request = create_request(page)<br>        content = get_content(request)<br>        down_load(content)<br><br></code></pre></td></tr></table></figure>

<h3 id="ajax的post请求"><a href="#ajax的post请求" class="headerlink" title="ajax的post请求"></a>ajax的post请求</h3><p>案例：KFC官网地址信息获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.parse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_request</span>(<span class="hljs-params">page</span>):<br>    base_url = <span class="hljs-string">&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&#x27;</span><br><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br>    &#125;<br><br>    data = &#123;<br>        <span class="hljs-string">&#x27;cname&#x27;</span>: <span class="hljs-string">&#x27;西安&#x27;</span>,<br>        <span class="hljs-string">&#x27;pid&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-string">&#x27;pageIndex&#x27;</span>: page ,<br>        <span class="hljs-string">&#x27;pageSize&#x27;</span>: <span class="hljs-string">&#x27;10&#x27;</span><br>    &#125;<br>    data = urllib.parse.urlencode(data).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    request = urllib.request.Request(url= base_url , data = data , headers= headers)<br>    <span class="hljs-keyword">return</span>  request<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_content</span>(<span class="hljs-params">request</span>):<br>    response = urllib.request.urlopen(request)<br><br>    content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  ******<br>    <span class="hljs-keyword">return</span> content<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">down_load</span>(<span class="hljs-params">content</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;kcf.json&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(content)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入起始的页码&#x27;</span>))<br>    end_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入结束的页面&#x27;</span>))<br><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_page,end_page+<span class="hljs-number">1</span>):<br>        request = create_request(page)<br>        content = get_content(request)<br>        down_load(content)<br><br></code></pre></td></tr></table></figure>

<h3 id="爬虫异常"><a href="#爬虫异常" class="headerlink" title="爬虫异常"></a>爬虫异常</h3><p>URLError\HTTPError</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">简介:<span class="hljs-number">1.</span>HTTPError类是URLError类的子类<br>	<span class="hljs-number">2.</span>导入的包urllib.error.HTTPError urllib.error.URLError<br>	<span class="hljs-number">3.</span>http错误：http错误是针对浏览器无法连接到服务器而增加出来的错误提示。引导并告诉浏览者该页是哪里出了问题。<br>	<span class="hljs-number">4.</span>通过urllib发送请求的时候，有可能会发送失败，这个时候如果想让你的代码更加的健壮，可以通过<span class="hljs-keyword">try</span>‐<span class="hljs-keyword">except</span>进行捕获异常，异常有两类，URLError\HTTPError<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.error<br><br>url = <span class="hljs-string">&#x27;http://jwxt1.xsyu.edu.cn/eams/login.action1&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br> &#125;<br><span class="hljs-keyword">try</span>:<br>    request = urllib.request.Request(url = url , headers = headers )<br><br>    response = urllib.request.urlopen(request)<br><br>    content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span> (content)<br><span class="hljs-keyword">except</span> urllib.error.HTTPError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不想理你。。&#x27;</span>)<br><span class="hljs-keyword">except</span> urllib.error.URLError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;就是不想理你。。&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="cookie登录"><a href="#cookie登录" class="headerlink" title="cookie登录"></a>cookie登录</h3><p>适用场景：数据采集的时候 需要绕过登录 然后进入到某个页面</p>
<p>反爬手段：个人信息页面是utf-8  但是还报了编码错误  因为没有进入到个人信息页面  而是跳转到了登录页面，登录页面不是utf-8所以报错</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">cookie 中携带着登录信息，如果有登录后的cookie，那么我们就可以携带着cookie进入到任何页面<br><br><span class="hljs-built_in">ref</span>erer 一般情况下做图片的防盗链 <br>	判断当前路径是不是由上一个路径来的  微博有时需要验证有时不需要<br></code></pre></td></tr></table></figure>

<p>案例：微博登录页面 和 qq空间登录</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">qq空间登录 <span class="hljs-selector-tag">html</span> 文件获取正常<br>微博 <span class="hljs-selector-tag">html</span> 获取到，但无法打开 显示获取数据失败 代码见cookie登录<br></code></pre></td></tr></table></figure>



<h3 id="handler处理器"><a href="#handler处理器" class="headerlink" title="handler处理器"></a>handler处理器</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">为什么要学习handler？<br>		urllib.request.urlopen(url)<br>		不能定制请求头<br>		urllib.request.Request(url,headers,data)<br>		可以定制请求头  <span class="hljs-comment">#都是静态cookie</span><br>	Handler<br>		定制更高级的请求头（随着业务逻辑的复杂 请求对象的定制已经满足不了我们的需求（动态cookie和代理不能使用请求对象的定制）<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br>url = <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br>&#125;<br><br>request = urllib.request.Request(url = url , headers = headers)<br><br><span class="hljs-comment">#   1.获取hanlder对象</span><br>handler = urllib.request.HTTPHandler()<br><span class="hljs-comment">#   2.获取opener对象</span><br>opener = urllib.request.build_opener(handler)<br><span class="hljs-comment">#   3.调用open方法</span><br>response = opener.<span class="hljs-built_in">open</span>(request)<br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure>

<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>代理的常用功能?<br>	<span class="hljs-number">1.</span>突破自身IP访问限制，访问国外站点。<br>	<span class="hljs-number">2.</span>访问一些单位或团体内部资源<br>			扩展：某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务<br>器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。<br>	<span class="hljs-number">3.</span>提高访问速度<br>		扩展：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>	<span class="hljs-number">4.</span>隐藏真实IP<br>		扩展：上网者也可以通过这种方法隐藏自己的IP，免受攻击。<br>	<span class="hljs-number">2.</span>代码配置代理<br>        创建Reuqest对象<br>        创建ProxyHandler对象<br>        用handler对象创建opener对象<br>        使用opener.<span class="hljs-built_in">open</span>函数发送请求<br><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br>url = <span class="hljs-string">&#x27;http://cn.bing.com/search?q=ip&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br>&#125;<br><br>request = urllib.request.Request(url = url , headers = headers<br>                                 <br>proxies = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;220.135.165.38:8080&#x27;</span>&#125;<br>handler = urllib.request.ProxyHandler(proxies= proxies)<br>                                 <br>opener = urllib.request.build_opener()<br>response = opener.<span class="hljs-built_in">open</span>(request)<br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;daili.html&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(content)<br></code></pre></td></tr></table></figure>

<h4 id="代理池"><a href="#代理池" class="headerlink" title="代理池"></a>代理池</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">proxies_pool = [<br>    &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;220.135.165.38:2770&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;220.135.165.38:8080&#x27;</span>&#125;,<br>]<br><br><span class="hljs-keyword">import</span> random<br><br>proxies = random.choice(proxies_pool)<br><span class="hljs-comment">#每次在代理池中，随机使用一个ip</span><br></code></pre></td></tr></table></figure>





<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><p>xpath使用</p>
<p>​		安装xpath helper 插件</p>
<p>​		如果使用edge浏览器 下载插件 可以从 <a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome Web Store</a> 获取 edge基于Chromium基础上做的，应该是可以使用</p>
<p>​		安装成功 ctrl + shift + X 出现 黑框</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>安装lxml库<br>		pip install lxml ‐i https://pypi.douban.com/simple<br><span class="hljs-number">2.</span>导入lxml.etree<br>		<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-number">3.</span>etree.parse() 解析本地文件<br>		html_tree = etree.parse(<span class="hljs-string">&#x27;XX.html&#x27;</span>)<br><span class="hljs-number">4.</span>etree.HTML() 服务器响应文件<br>		html_tree = etree.HTML(response.read().decode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<br><span class="hljs-number">4.</span>html_tree.xpath(xpath路径)<br><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">xpath基本语法：<br>	<span class="hljs-number">1.</span>路径查询<br>        //：查找所有子孙节点，不考虑层级关系 <span class="hljs-comment">#无限嵌套</span><br>        / ：找直接子节点<br>	<span class="hljs-number">2.</span>谓词查询<br>        //div[@<span class="hljs-built_in">id</span>]<br>        //div[@<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;maincontent&quot;</span>]<br>    <span class="hljs-number">3.</span>属性查询<br>            //@<span class="hljs-keyword">class</span><br>    <span class="hljs-number">4.</span>模糊查询<br>            //div[contains(@<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;he&quot;</span>)]<br>            //div[starts‐<span class="hljs-keyword">with</span>(@<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;he&quot;</span>)]<br>    <span class="hljs-number">5.</span>内容查询<br>            //div/h1/text()<br>    <span class="hljs-number">6.</span>逻辑运算 			<br>            //div[@<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-keyword">and</span> @<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;s_down&quot;</span>]<br>        		与<span class="hljs-comment">#不能跨标签使用</span><br>            //title | //price<br>            	或<span class="hljs-comment">#只能针对标签使用</span><br>/text()查看内容以中文显示<br></code></pre></td></tr></table></figure>

<p>eg.xpath 解析本地文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-comment"># xpath 解析</span><br><span class="hljs-comment">#     (1)本地文件                                             etree.parse</span><br><span class="hljs-comment">#     (2)服务器响应数据 response.read().decode(&#x27;utf-8&#x27;)        etree.HTML()</span><br><span class="hljs-comment">#      xpath 严格遵守html要求所有标签必须成对出现</span><br><span class="hljs-comment">#xpath解析本地文件</span><br>tree = etree.parse(<span class="hljs-string">&#x27;12.xpath_基本使用.html&#x27;</span>)<br><br><span class="hljs-comment"># tree.xpath(&#x27;xpath路径‘)</span><br><br><span class="hljs-comment">#1.查找ul下面的li</span><br><span class="hljs-comment"># li_list = tree.xpath(&#x27;//body//li&#x27;)</span><br><br><span class="hljs-comment"># //是匹配 子 孙 节点   /只是匹配子节点</span><br><br><span class="hljs-comment">#2.查找所有有id属性的li标签   [@属性名]</span><br><span class="hljs-comment"># li_list = tree.xpath(&#x27;//ul/li[@id]&#x27;)</span><br><br><span class="hljs-comment">#3.text()获取标签中的内容</span><br>li_list = tree.xpath(<span class="hljs-string">&#x27;//ul/li[@id]/text()&#x27;</span>)<br><br><span class="hljs-comment">#4.找到id为l1的li标签  注意引号的问题</span><br>li_list = tree.xpath(<span class="hljs-string">&#x27;//ul/li[@id=&quot;l1&quot;]/text()&#x27;</span>)<br><br><span class="hljs-comment">#5.查找到id为l1的li标签的class的属性值</span><br>li = tree.xpath(<span class="hljs-string">&#x27;//ul/li[@id=&quot;l1&quot;]/@class&#x27;</span>)<br><span class="hljs-built_in">print</span>(li)<br><br><span class="hljs-comment">#6.查找id中包含l的li标签   #模糊查询 contains 包含</span><br>li_list = tree.xpath(<span class="hljs-string">&#x27;//ul/li[contains(@id,&quot;l&quot;)]/text()&#x27;</span>)<br><br><span class="hljs-comment">#7.查找id的值以c开头的li标签  #starts-with 以什么开头</span><br>li_list = tree.xpath(<span class="hljs-string">&#x27;//ul/li[starts-with(@id,&quot;c&quot;)]/text()&#x27;</span>)<br><br><span class="hljs-comment">#8.查询id为l1和class 为c1的标  # 不能跨标签使用</span><br>li_list = tree.xpath(<span class="hljs-string">&#x27;//ul/li[@id=&quot;l1&quot; and @class=&quot;c1&quot;]/text()&#x27;</span>)<br><br><span class="hljs-comment">#9.查询id为l1 和 id为 c1</span><br><br>li_list = tree.xpath(<span class="hljs-string">&#x27;//ul/li[@id=&quot;l1&quot;]/text() | //ul/li[@id=&quot;c1&quot;]/text()&#x27;</span>)<br><span class="hljs-comment">#   判断列表的长度</span><br><span class="hljs-built_in">print</span>(li_list)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(li_list))<br><br></code></pre></td></tr></table></figure>

<p>xpath 解析服务器响应数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取百度_百度一下</span><br>出现问题 前期UA错误 导致源码获取与网页查询不一致，重新获取UA即可<br>linux 和 win的源码标签有区别<br><br>xpath 路径获取可以通过右键直接复制<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br><br>url = <span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Edg/97.0.1072.55&#x27;</span><br> &#125;<br><br>request = urllib.request.Request(url = url ,headers = headers)<br>response = urllib.request.urlopen(request)<br>content = response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;baidu.html&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file :<br>     file.write(content)<br><span class="hljs-comment"># print(content)</span><br><br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br>tree = etree.HTML(content)<br><br>result = tree.xpath(<span class="hljs-string">&#x27;//input[@id=&quot;su&quot;]/@value&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(result)<br><br><br></code></pre></td></tr></table></figure>

<p>应用案例：1.站长素材照片爬取    ——照片的懒加载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">down_load</span>(<span class="hljs-params">content</span>):<br>    <span class="hljs-comment">#下载图片</span><br>    tree = etree.HTML(content)<br>    name_list = tree.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;container&quot;]//a/img/@alt&#x27;</span>)<br>    <span class="hljs-comment">#一般设计图片的网站都会进行懒加载</span><br>    src_list = tree.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;container&quot;]//a/img/@src2&#x27;</span>)<br>    <span class="hljs-comment"># print(len(name_list),len(src_list))</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(name_list)):<br>        name = name_list[i]<br>        src = src_list[i]<br>        url = <span class="hljs-string">&#x27;https:&#x27;</span> + src<br><br>        url = url.replace(<span class="hljs-string">&#x27;_s&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-comment"># print(name , url )</span><br>        urllib.request.urlretrieve(url = url , filename = <span class="hljs-string">&#x27;../miao/&#x27;</span> + name + <span class="hljs-string">&#x27;.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="JsonPath"><a href="#JsonPath" class="headerlink" title="JsonPath"></a>JsonPath</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">jsonpath的安装及使用方式：<br>		pip安装：<br>			pip install jsonpath<br>		jsonpath的使用：<br>            obj = json.load(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;json文件&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf‐8&#x27;</span>))<br>            ret = jsonpath.jsonpath(obj, <span class="hljs-string">&#x27;jsonpath语法&#x27;</span>)<br>	<span class="hljs-comment">#json只能解析本地文件 ，不能解析服务器文件</span><br>    <br></code></pre></td></tr></table></figure>

<p>教程连接（<a href="http://blog.csdn.net/luxideyao/article/details/77802389%EF%BC%89">http://blog.csdn.net/luxideyao/article/details/77802389）</a></p>
<p><img src="https://s2.loli.net/2024/02/24/2tjg9HyT7iBXvKe.png" alt="image-20220112221858720"></p>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><h4 id="1-基本简介"><a href="#1-基本简介" class="headerlink" title="1.基本简介"></a>1.基本简介</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>BeautifulSoup简称：<br>	bs4<br><span class="hljs-number">2.</span>什么是BeatifulSoup？<br>	BeautifulSoup，和lxml一样，是一个html的解析器，主要功能也是解析和提取数据<br><span class="hljs-number">3.</span>优缺点？<br>    缺点：效率没有lxml的效率高<br>    优点：接口设计人性化，使用方便<br><br></code></pre></td></tr></table></figure>

<h4 id="2-安装以及创建"><a href="#2-安装以及创建" class="headerlink" title="2.安装以及创建"></a>2.安装以及创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>安装<br>	pip install bs4<br>    安装解析器lxml（第三方解析器）<br>    pip install lxml<br><span class="hljs-number">2.</span>导入<br>	<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-number">3.</span>创建对象<br>	服务器响应的文件生成对象<br>		soup = BeautifulSoup(response.read().decode(), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>	本地文件生成对象<br>		soup = BeautifulSoup(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;1.html&#x27;</span>), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>注意：默认打开文件的编码格式gbk所以需要指定打开编码格式<br></code></pre></td></tr></table></figure>

<h4 id="3-节点定位"><a href="#3-节点定位" class="headerlink" title="3.节点定位"></a>3.节点定位</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>根据标签名查找节点<br>		soup.a 【注】只能找到第一个a<br>			soup.a.name<br>			soup.a.attrs<br><br><span class="hljs-number">2.</span>函数<br>        (<span class="hljs-number">1</span>).find(返回一个对象)<br>                find(<span class="hljs-string">&#x27;a&#x27;</span>)：只找到第一个a标签<br>        		find(<span class="hljs-string">&#x27;a&#x27;</span>, title=<span class="hljs-string">&#x27;名字&#x27;</span>)<br>        		find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;名字&#x27;</span>)<br>        (<span class="hljs-number">2</span>).find_all(返回一个列表)<br>        		find_all(<span class="hljs-string">&#x27;a&#x27;</span>) 查找到所有的a<br>        		find_all([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;span&#x27;</span>]) 返回所有的a和span<br>        		find_all(<span class="hljs-string">&#x27;a&#x27;</span>, limit=<span class="hljs-number">2</span>) 只找前两个a<br><span class="hljs-comment">#如果想获取的是多个标签的数据 那么需要在find_all中添加的参数为列表的参数 </span><br>		(<span class="hljs-number">3</span>).select(根据选择器得到节点对象)【推荐】<br>                <span class="hljs-number">1.</span>element<br>                	eg:p<br>                <span class="hljs-number">2.</span>.<span class="hljs-keyword">class</span>  <span class="hljs-comment">#类选择器  .</span><br>                	eg:<span class="hljs-built_in">print</span>(soup.select(<span class="hljs-string">&#x27;.a1&#x27;</span>))<br>                <span class="hljs-number">3.</span><span class="hljs-comment">#id     #id选择器</span><br>               		eg:<span class="hljs-built_in">print</span>(soup.select(<span class="hljs-string">&#x27;#l1&#x27;</span>))<br>                <br>                <span class="hljs-number">4.</span>属性选择器<br>                	<span class="hljs-comment">#属性选择器 -- 通过属性寻找对应标签</span><br>                    [attribute]<br>                    	eg:li = soup.select(<span class="hljs-string">&#x27;li[class]&#x27;</span>)<br>                    [attribute=value]<br>                    	eg:li = soup.select(<span class="hljs-string">&#x27;li[class=&quot;mm1&quot;]&#x27;</span>)<br>                <span class="hljs-number">5.</span>层级选择器<br>                element element 后代选择器 (空格)<br>                	div p<br>                element&gt;element  子代选择器(&gt;)<br>                	div&gt;p<br>                    soup.select(<span class="hljs-string">&#x27;div&gt;ul&gt;li&#x27;</span>)<br>                element,element  (,) 并列两个标签   <br>                	div,p<br>                    soup.select(<span class="hljs-string">&#x27;a,li&#x27;</span>)<br>                eg:soup = soup.select(<span class="hljs-string">&#x27;a,span&#x27;</span>)<br>        <br></code></pre></td></tr></table></figure>

<h4 id="4-节点信息"><a href="#4-节点信息" class="headerlink" title="4.节点信息"></a>4.节点信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(<span class="hljs-number">1</span>).获取节点内容：适用于标签中嵌套标签的结构<br>        obj.string<br>        obj.get_text()【推荐】<br><span class="hljs-comment"># 如果标签对象中  只有内容那么string和get_text()都可以使用</span><br><span class="hljs-comment"># 如果标签对象中，除了内容还有标签那么只有get_text()可以使用        </span><br>(<span class="hljs-number">2</span>).节点的属性<br>    tag.name 获取标签名<br>        eg:tag = find(<span class="hljs-string">&#x27;li)</span><br><span class="hljs-string">            print(tag.name)</span><br><span class="hljs-string">   	tag.attrs将属性值作为一个字典返回</span><br><span class="hljs-string">(3).获取节点属性</span><br><span class="hljs-string">        obj.attrs.get(&#x27;</span>title<span class="hljs-string">&#x27;)【常用】</span><br><span class="hljs-string">        obj.get(&#x27;</span>title<span class="hljs-string">&#x27;) </span><br><span class="hljs-string">        obj[&#x27;</span>title<span class="hljs-string">&#x27;]</span><br></code></pre></td></tr></table></figure>

<h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>什么是selenium？<br>    （<span class="hljs-number">1</span>）Selenium是一个用于Web应用程序测试的工具。<br>    （<span class="hljs-number">2</span>）Selenium 测试<span class="hljs-string">&#x27;直接运行&#x27;</span>在浏览器中，就像真正的用户在操作一样。<br>    （<span class="hljs-number">3</span>）支持通过各种driver（FirfoxDriver，IternetExplorerDriver，OperaDriver，ChromeDriver）驱动真实浏览器完成测试。<br>	（<span class="hljs-number">4</span>）selenium也是支持无界面浏览器操作的。<br><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">2.</span>为什么使用selenium？<br>	模拟浏览器功能，自动执行网页中的js代码，实现动态加载<br>    <br>eg. 京东秒杀 <span class="hljs-built_in">id</span> = <span class="hljs-string">&#x27;J_seckill&#x27;</span> 的数据 是由js渲染出来的，而js要在浏览器中运行，直接openurl无法使用，所以引入了selenium<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">3.</span>如何安装selenium？<br>	(<span class="hljs-number">1</span>)下载浏览器引擎<br>		Microsoft Edge<br>		https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/<br>	(<span class="hljs-number">2</span>)安装 selenium<br>		pip install selenium<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pycparser, cffi, attrs, sortedcontainers, sniffio, six, outcome, h11, cryptography, <span class="hljs-keyword">async</span>-generator, wsproto, trio, pyOpenSSL, trio-websocket, selenium<br>安装selenium产生的依赖库<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">4.</span>selenium 使用步骤<br><br><span class="hljs-comment"># (1)导入selenium</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-comment"># (2) 创建浏览器的操作对象</span><br>path = <span class="hljs-string">&#x27;msedgedriver.exe&#x27;</span><br>browser = webdriver.Edge(path)  <span class="hljs-comment"># 注意 Edge &#x27;E&#x27;必须大写 否则会出现TypeError:&#x27;module&#x27; object is not callable(模块对象不可调用)</span><br><br><span class="hljs-comment">#访问网站</span><br>url = <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span><br>browser.get(url)<br></code></pre></td></tr></table></figure>

<h4 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h4><p>selenium的元素定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">元素定位：自动化要做的就是模拟鼠标和键盘来操作来操作这些元素，点击、输入等等。操作这些元素前首先要找到它们，WebDriver提供很多定位元素的方法<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">方法：<br><span class="hljs-number">1.</span>find_element_by_id	<span class="hljs-comment">#根据id来找到对象</span><br>	eg:button = browser.find_element_by_id(<span class="hljs-string">&#x27;su&#x27;</span>)<br>        <br><span class="hljs-number">2.</span>find_elements_by_name	<span class="hljs-comment">#根据标签属性的属性值来获取对象的</span><br>	eg:name = browser.find_element_by_name(<span class="hljs-string">&#x27;wd&#x27;</span>)<br>        <br><span class="hljs-number">3.</span>find_elements_by_xpath	<span class="hljs-comment">#根据xpath语句来获取对象</span><br>	eg:xpath1 = browser.find_elements_by_xpath(<span class="hljs-string">&#x27;//input[@id=&quot;su&quot;]&#x27;</span>)<br>        <br><span class="hljs-number">4.</span>find_elements_by_tag_name	<span class="hljs-comment">#根据标签的名字来获取对象</span><br>	eg:names = browser.find_elements_by_tag_name(<span class="hljs-string">&#x27;input&#x27;</span>)<br>        <br><span class="hljs-number">5.</span>find_elements_by_css_selector	<span class="hljs-comment">#使用的是bs4的语法来获取对象</span><br>	eg:my_input = browser.find_elements_by_css_selector(<span class="hljs-string">&#x27;#kw&#x27;</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-number">6.</span>find_elements_by_link_text	<span class="hljs-comment">#获取连接文本  及标签为a的</span><br>	eg:browser.find_element_by_link_text(<span class="hljs-string">&quot;新闻&quot;</span>)<br><br><span class="hljs-string">&#x27;注：_element_ 与 _elements_ 区别：&#x27;</span>s<span class="hljs-string">&#x27;是以列表形式返回值&#x27;</span><br></code></pre></td></tr></table></figure>

<h4 id="访问元素信息"><a href="#访问元素信息" class="headerlink" title="访问元素信息"></a>访问元素信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">获取元素属性<br>	.get_attribute(<span class="hljs-string">&#x27;class&#x27;</span>)<br>获取元素文本	<span class="hljs-comment">#表情头和标签尾中间的内容</span><br>	.text<br>获取标签名<br>	.tag_name<br></code></pre></td></tr></table></figure>

<h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h4><h4 id="handless"><a href="#handless" class="headerlink" title="handless"></a>handless</h4><p>无界面使用</p>
<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>只属于python，其他编程语言没有</p>
<h3 id="urllib和request的区别"><a href="#urllib和request的区别" class="headerlink" title="urllib和request的区别"></a>urllib和request的区别</h3><p>urllib</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>一个类型和六个方法<br><span class="hljs-number">2.</span>get请求 <br>	urllib.parse.quote<br>    urllib.parse.urlencode<br>        两种方法处理url中,（无法识别中文）中文的编解码问题 <br>            quote处理单个参数的解码，转化为unicode编码<br>            urlencode处理date数据（多个数据）的解码<br><span class="hljs-number">3.</span>post请求 	百度翻译<br><span class="hljs-number">4.</span>ajax的get请求<br><span class="hljs-number">5.</span>ajax的post请求<br><span class="hljs-number">6.</span>cookie登录 <br><span class="hljs-number">7.</span>代理<br></code></pre></td></tr></table></figure>

<p>request</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>一个类型及<span class="hljs-number">6</span>个属性<br><span class="hljs-number">2.</span>get请求<br><span class="hljs-number">3.</span>post请求<br><span class="hljs-number">4.</span>代理<br><span class="hljs-number">5</span>，cookie  破解验证码<br></code></pre></td></tr></table></figure>

<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>文档：<br>官方文档<br>http://cn.python‐requests.org/zh_CN/latest/<br>快速上手<br>http://cn.python‐requests.org/zh_CN/latest/user/quickstart.html<br><br>测试地址：http://httpbin.org<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">2.</span>安装<br>	pip install request<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">3.</span>request 的属性及类型<br><span class="hljs-comment">#一个类型 6个属性</span><br>	类型				:models.Response<br>	r.text 			:获取网页源码（以字符串形式返回）<br>	r.encoding		:设置响应的编码格式<br>	r.url			:获取请求的url<br>	r.content		:获取二进制的数据（用来下载照片等文件）<br>	r.status_code	：获取响应的状态码<br>	r.headers		:获取相应头的信息<br>        <br><span class="hljs-comment">#encoding使用</span><br>requests的猜测解码方式和网页真正的编码方式不一致导致会出现乱码<br>则需手动指定requests的解码方式<br>	response.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>response.apparent_encoding  <span class="hljs-comment">#获取网页编码格式</span><br>	response.encoding = response.apparent_encoding<br></code></pre></td></tr></table></figure>

<h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#总结：</span><br> <span class="hljs-number">1.</span>参数使用params传递<br> <span class="hljs-number">2.</span>参数无需使用urlencode编码<br> <span class="hljs-number">3.</span>不需要请求对象的定制<br> <span class="hljs-number">4.</span>请求资源路径中的<span class="hljs-string">&#x27;?&#x27;</span>可以加也可以不加<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://www.baidu.com/s&#x27;</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Mobile Safari/537.36 Edg/97.0.1072.55&#x27;</span><br>&#125;<br><br>data = &#123;<br>    <span class="hljs-string">&#x27;wd&#x27;</span>:<span class="hljs-string">&#x27;西安&#x27;</span><br>&#125;<br><br><span class="hljs-comment">#get属性 可以传递的参数</span><br><span class="hljs-comment">#url 请求资源路径</span><br><span class="hljs-comment">#params 参数 类型any不限 不需要编码</span><br><span class="hljs-comment">#headers 头部         #可以直接传递，所以不需要请求头部的定制</span><br><span class="hljs-comment">#kwargs 字典</span><br>response = requests.get(url=url,params=data,headers=headers)<br>content = response.text<br><br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure>

<h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>urllib中需要先urlencode 解码encode编码，在进行请求对象调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 总结</span><br><span class="hljs-number">1.</span>post请求 不需要编解码<br><span class="hljs-number">2.</span>post请求的参数是data<br><span class="hljs-number">3.</span>不需要请求对象的定制<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://fanyi.baidu.com/sug&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Edg/97.0.1072.69&#x27;</span>,&#125;<br><br><span class="hljs-comment"># keyword = input(&quot;请输入要翻译的内容:&quot;)</span><br>data = &#123;<br>    <span class="hljs-string">&#x27;kw&#x27;</span>:<span class="hljs-string">&#x27;spider&#x27;</span><br>&#125;<br><br><span class="hljs-comment">#post属性 可以传递的参数</span><br><span class="hljs-comment">#url 请求资源路径</span><br><span class="hljs-comment">#data 参数</span><br><span class="hljs-comment">#json</span><br><span class="hljs-comment">#kwargs 字典</span><br>response =requests.post(url=url ,data= data, headers= headers)<br><br>content = response.text<br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-comment"># obj = json.loads(content,encoding=&#x27;utf-8&#x27;) #弃用错误</span><br>obj = json.loads(content.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)) <span class="hljs-comment">#使用response自身的属性即可</span><br><span class="hljs-built_in">print</span>(obj)<br><br></code></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">get</span>和<span class="hljs-built_in">post</span>区别？<br>    <span class="hljs-number">1</span>： <span class="hljs-built_in">get</span>请求的参数名字是<span class="hljs-built_in">params</span> <span class="hljs-built_in">post</span>请求的参数的名字是data<br>    <span class="hljs-number">2</span>： 请求资源路径后面可以不加?<br>    <span class="hljs-number">3</span>： 不需要手动编解码<br>    <span class="hljs-number">4</span>： 不需要做请求对象的定制<br></code></pre></td></tr></table></figure>



<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">proxy定制 代理池<br>	在请求中设置proxies参数<br>	<br>proxy = &#123;  <br><span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;219.149.59.250:9797&#x27;</span><br>&#125;<br>requests.get(url=url,params=data,headers=headers,proxies=proxy)<br><br></code></pre></td></tr></table></figure>

<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>初识 验证码登录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#requests中一个个方法 session() 通过session的返回值，将请求变为一个对象</span><br><span class="hljs-comment">#可以保持两次访问在 属于一次大访问之下（验证码访问和提交验证码访问）</span><br></code></pre></td></tr></table></figure>

<h3 id="参数详情"><a href="#参数详情" class="headerlink" title="参数详情"></a>参数详情</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">requests.request(method,url,**kwargs）<br>• method：请求方法，常见有GET、POST请求【此外还有HEAD、PUT、<br>PATCH、DELETE、OPTIONS】（前<span class="hljs-number">6</span>种就是HTTP协议所对应的请求方式，OPTIONS事实上是向服务器获取一些服务器跟客户端能够打交道的参数）<br>• url：请求的URL地址<br>•**kwargs：是一个可变的参数类型，在传实参时，以关键字参数的形式传入，python会自动解析成字典的形式<br>                 <br><span class="hljs-number">1.</span> params : 字典或元组列表或字节，作为参数增加到url中；一般用于get请<br>求，post请求也可用(不常用)。<br><span class="hljs-number">2.</span> data : 字典，元组列表，字节或文件对象,作为post请求的参数。<br><span class="hljs-number">3.</span> json : JSON格式的数据，作为post请求的json参数。<br><span class="hljs-number">4.</span> headers : 字典类型, HTTP请求头信息。<br><span class="hljs-number">5.</span> cookies : 字典或CookieJar，Request中的auth : 元组支持HTTP认证功能<br><span class="hljs-number">6.</span> files : 字典类型，传输文件，作为post请求文件流数据。<br><span class="hljs-number">7.</span> timeout : 设定超时时间，秒为单位<br><span class="hljs-number">8.</span> proxies : 字典类型，设定访问代理服务器，可以增加登录认证<br><span class="hljs-number">9.</span> allow_redirects : <span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>，默认为<span class="hljs-literal">True</span>，重定向开关<br><span class="hljs-number">10.</span> stream : <span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>，默认为<span class="hljs-literal">True</span>，获取内容立即下载开关<br><span class="hljs-number">11.</span> verify : <span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>，默认为<span class="hljs-literal">True</span>，认证SSL证书开关<br><span class="hljs-number">12.</span> cert : 本地SSL证书<br><span class="hljs-number">13.</span> auth : 元组，支持HTTP认证功能<br>                 <br><span class="hljs-comment">#params、data、json区别：</span><br>params：get请求 中接收参数，params=字典类型的数据<br>data：post请求中接收参数，data=字典格式的数据（content_type为键值对的编码格式）<br>json：post请求中接收参数，json=字典格式的数据（content_type为application/json），使用json接收会自动将字典转换为json；也可以用data接收json格式的数据，data=json.dump(字典格式的数据)<br></code></pre></td></tr></table></figure>

<h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><h3 id="1-scrapy"><a href="#1-scrapy" class="headerlink" title="1.scrapy"></a>1.scrapy</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">（<span class="hljs-number">1</span>）scrapy是什么？<br>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的<span class="hljs-string">&#x27;应用框架&#x27;</span>。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br></code></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用国内源</span><br>pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Successfully</span> built protego PyDispatcher<br><span class="hljs-attribute">Installing</span> collected packages: twisted-iocpsupport, PyDispatcher, pyasn1, priority, incremental, hyperframe, hpack, constantly, zope.interface, w3lib, typing-extensions, queuelib, pyasn1-modules, protego, jmespath, itemadapter, hyperlink, h2, cssselect, Automat, Twisted, parsel, service-identity, itemloaders, scrapy<br><br><span class="hljs-attribute">Successfully</span> installed Automat-<span class="hljs-number">20</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span> PyDispatcher-<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">5</span> Twisted-<span class="hljs-number">22</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> constantly-<span class="hljs-number">15</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> cssselect-<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> h2-<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span> hpack-<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> hyperframe-<span class="hljs-number">5</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span> hyperlink-<span class="hljs-number">21</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> incremental-<span class="hljs-number">21</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span> itemadapter-<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span> itemloaders-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span> jmespath-<span class="hljs-number">0</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span> parsel-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span> priority-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span> protego-<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">16</span> pyasn1-<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">8</span> pyasn1-modules-<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">8</span> queuelib-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> scrapy-<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> service-identity-<span class="hljs-number">21</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> twisted-iocpsupport-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span> typing-extensions-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> w3lib-<span class="hljs-number">1</span>.<span class="hljs-number">22</span>.<span class="hljs-number">0</span> zope.interface-<span class="hljs-number">5</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>可能出现的错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">报错<span class="hljs-number">1</span>：<br>	pip install Scrapy<br>    building <span class="hljs-string">&#x27;twisted.test.raiser&#x27;</span> extension<br>    error: Microsoft Visual C++ <span class="hljs-number">14.0</span> <span class="hljs-keyword">is</span> required. Get it <span class="hljs-keyword">with</span> <span class="hljs-string">&quot;Microsoft Visual C++Build Tools&quot;</span>:http://landinghub.visualstudio.com/visual‐cpp‐build‐tools<br><br>解决方案：<br>    http://www.lfd.uci.edu/~gohlke/pythonlibs/<span class="hljs-comment">#twisted</span><br>    下载twisted对应版本的whl文件（如我的Twisted‐<span class="hljs-number">17.5</span><span class="hljs-number">.0</span>‐cp36‐cp36m‐win_amd64.whl），cp后面是python版本，amd64代表<span class="hljs-number">64</span>位，<br>    运行命令：<br>    pip install C:\Users\...\Twisted‐<span class="hljs-number">17.5</span><span class="hljs-number">.0</span>‐cp36‐cp36m‐win_amd64.whl<br>    pip install Scrapy<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">实在不行使用<span class="hljs-string">&#x27;anaconda&#x27;</span>下载   <span class="hljs-comment">#会下载许多目前用不到的包</span><br>	pycharm 需要将环境变量更改为 anaconda的环境<br>    使用步骤：<br>        打开anaconda<br>        点击environments<br>        点击<span class="hljs-keyword">not</span> installed<br>        输入scrapy<br>        apply<br>        在pycharm中选择anaconda的环境<br></code></pre></td></tr></table></figure>

<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>scrapy项目的创建以及运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>创建scrapy项目：<br>		终端输入 scrapy startproject 项目名称<br>		<span class="hljs-comment">#名称不能以 数字开头，也不能包含中午</span><br><br><span class="hljs-number">2.</span>创建爬虫文件<br>		要在spiders文件夹中创建爬虫文件<br>    	cd 项目的名字\项目的名字\spiders<br>        <br>        创建爬虫文件<br>        	scrapy  genspider 爬虫文件的名字  要爬取的网页<br>            eg. scrapy genspider baidu  www.baidu.com<br>            	<span class="hljs-comment">#网页url 不需要添加http协议</span><br><span class="hljs-number">3.</span> 运行爬虫代码<br>		scrapy crawl 爬虫的名字<br>    	eg. scrapy crawl baidu<br>        <br>        <span class="hljs-comment">#需要修改robots.txt 协议</span><br>        在settings.py中修改,将ROBOTSTXT_OBEY = <span class="hljs-literal">True</span>注释掉<br></code></pre></td></tr></table></figure>

<h4 id="scrapy项目的结构"><a href="#scrapy项目的结构" class="headerlink" title="scrapy项目的结构"></a>scrapy项目的结构</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">项目名字<br>	项目名字<br>		spiders文件夹（存储的是爬虫文件）<br>			__init__<br>			自定义的爬虫文件	由我们自己创建，是实现爬虫核心功能的文件<br><br>		__init__<br>		items			定义数据结构的地方  爬取的数据都包含那些<br>		middleware 		中间件		代理<br>		pipelines 		管道		 用来处理下载的数据<br>		settings 		配置文件	robbts协议 ua定义等<br></code></pre></td></tr></table></figure>

<p>response的属性和方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">爬虫文件的基本组成：<br>	继承scrapy.Spider类<br>        name = <span class="hljs-string">&#x27;baidu&#x27;</span> ‐‐‐》 运行爬虫文件时使用的名字<br>        allowed_domains‐‐‐》 爬虫允许的域名，在爬取的时候，如果不是此域名之下的url，会被过滤掉<br>        start_urls ‐‐‐》声明了爬虫的起始地址，可以写多个url，一般是一个<br>        parse(self, response) ‐‐‐》解析数据的回调函数<br>            response.text ‐‐‐》响应的是字符串<br>            response.body ‐‐‐》响应的是二进制文件（类似content）<br>            response.xpath()‐》xpath方法的返回值类型是selector列表<br>            extract() ‐‐‐》提取的是selector对象的是data<br>            extract_first() ‐‐‐》提取的是selector列表中的第一个数据<br></code></pre></td></tr></table></figure>

<p>解析数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#不需要引入库，直接使用</span><br> span = response.xpath(<span class="hljs-string">&#x27;xpath语句&#x27;</span>) <br> span.extract() 的是selector对象的是data数据<br>		<span class="hljs-comment">#eg.&lt;Selector xpath = &#x27;路径&#x27;,data = &#x27;xxx&#x27;&gt;</span><br> span.extract_first()<br>		获取selector列表第一个数据的data值<br></code></pre></td></tr></table></figure>

<h4 id="scrapy架构组成"><a href="#scrapy架构组成" class="headerlink" title="scrapy架构组成"></a>scrapy架构组成</h4><figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">（<span class="hljs-number">1</span>）引擎 ‐‐‐》自动运行，无需关注，会自动组织所有的请求对象，分发给下载器<br>（<span class="hljs-number">2</span>）下载器 ‐‐‐》从引擎处获取到请求对象后，请求数据<br>（<span class="hljs-number">3</span>）<span class="hljs-variable">spiders</span> ‐‐‐》<span class="hljs-variable">Spider</span>类定义了如何爬取某个<span class="hljs-punctuation">(</span>或某些<span class="hljs-punctuation">)</span>网站。包括了爬取的动作<span class="hljs-punctuation">(</span>例如<span class="hljs-operator">:</span>是否跟进链接<span class="hljs-punctuation">)</span>以及如何从网页的内容中提取结构化数据<span class="hljs-punctuation">(</span>爬取<span class="hljs-variable">item</span><span class="hljs-punctuation">)</span>。 换句话说，<span class="hljs-variable">Spider</span>就是您定义爬取的动作及分析某个网页<span class="hljs-punctuation">(</span>或者是有些网页<span class="hljs-punctuation">)</span>的地方。<br>（<span class="hljs-number">4</span>）调度器 ‐‐‐》有自己的调度规则，无需关注<br>（<span class="hljs-number">5</span>）管道（<span class="hljs-built_in">Item</span> <span class="hljs-variable">pipeline</span>） ‐‐‐》最终处理数据的管道，会预留接口供我们处理数据当<span class="hljs-built_in">Item</span>在<span class="hljs-variable">Spider</span>中被收集之后，它将会被传递到<span class="hljs-built_in">Item</span> <span class="hljs-variable">Pipeline</span>，一些组件会按照一定的顺序执行对<span class="hljs-built_in">Item</span>的处理。<br><br>每个<span class="hljs-variable">item</span> <span class="hljs-variable">pipeline</span>组件<span class="hljs-punctuation">(</span>有时称之为“<span class="hljs-built_in">Item</span> <span class="hljs-variable">Pipeline</span>”<span class="hljs-punctuation">)</span>是实现了简单方法的<span class="hljs-variable">Python</span>类。他们接收到<span class="hljs-built_in">Item</span>并通过它执行一些行为，同时也决定此<span class="hljs-built_in">Item</span>是否继续通过<span class="hljs-variable">pipeline</span>，或是被丢弃而不再进行处理。<br>        以下是<span class="hljs-variable">item</span> <span class="hljs-variable">pipeline</span>的一些典型应用：<br>        <span class="hljs-number">1.</span> 清理<span class="hljs-variable">HTML</span>数据<br>        <span class="hljs-number">2.</span> 验证爬取的数据<span class="hljs-punctuation">(</span>检查<span class="hljs-variable">item</span>包含某些字段<span class="hljs-punctuation">)</span><br>        <span class="hljs-number">3.</span> 查重<span class="hljs-punctuation">(</span>并丢弃<span class="hljs-punctuation">)</span><br>        <span class="hljs-number">4.</span> 将爬取结果保存到数据库中<br><br></code></pre></td></tr></table></figure>

<h4 id="scrapy工作原理"><a href="#scrapy工作原理" class="headerlink" title="scrapy工作原理"></a>scrapy工作原理</h4><img src="https://s2.loli.net/2024/02/24/Ad7SgLB1I6cGV9m.png" alt="image-20220213142311558"  />

<h3 id="scrapy-shell"><a href="#scrapy-shell" class="headerlink" title="scrapy shell"></a>scrapy shell</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>什么是scrapy shell？<br>Scrapy终端，是一个交互终端，供您在未启动spider的情况下尝试及调试您的爬取代码。 其本意是用来测试提取数据的代码，不过您可以将其作为正常的Python终端，在上面测试任何的Python代码。<br>该终端是用来测试XPath或CSS表达式，查看他们的工作方式及从爬取的网页中提取的数据。 在编写您的spider时，该终端提供了交互性测试您的表达式代码的功能，免去了每次修改后运行spider的麻烦。<br>一旦熟悉了Scrapy终端后，您会发现其在开发和调试spider时发挥的巨大作用。<br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">进入到scrapy shell的终端 直接在window的终端中输入<br>		scrapy shell  域名<br><span class="hljs-comment">#如果需要 高亮 或者 自动补全 那么可以安装 ipython</span><br>		pip install ipython<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/07/05/MySQL/MySQL/</url>
    <content><![CDATA[<h1 id="导入表的问题"><a href="#导入表的问题" class="headerlink" title="导入表的问题"></a>导入表的问题</h1><p><strong>导入数据时外键约束问题</strong></p>
<p>数据导入指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">source d:\xxx.sql<br></code></pre></td></tr></table></figure>

<p>通过FOREIGN_KEY_CHECKS解决，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">set FOREIGN_KEY_CHECKS=0;  #在导入前设置为不检查外键约束<br>set FOREIGN_KEY_CHECKS=1;  #在导入后恢复检查外键约束<br></code></pre></td></tr></table></figure>

<h1 id="第三章-最基本的SELECT语句"><a href="#第三章-最基本的SELECT语句" class="headerlink" title="第三章_最基本的SELECT语句"></a>第三章_最基本的SELECT语句</h1><h2 id="1-SQL语言的规则和规范"><a href="#1-SQL语言的规则和规范" class="headerlink" title="1. SQL语言的规则和规范"></a>1. SQL语言的规则和规范</h2><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1) 基本规则"></a>1) 基本规则</h3><ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 </li>
<li>每条命令以 ; 或 \g 或 \G 结束 </li>
<li>关键字不能被缩写也不能分行 </li>
<li>关于标点符号 <ul>
<li>必须保证所有的()、单引号、双引号是成对结束的 </li>
<li>必须使用英文状态下的半角输入方式 </li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示 </li>
<li>列的别名，尽量使用双引号（” “），而且不建议省略as</li>
</ul>
</li>
</ul>
<h3 id="2-SQL大小写规范（建议遵守）"><a href="#2-SQL大小写规范（建议遵守）" class="headerlink" title="2) SQL大小写规范（建议遵守）"></a>2) SQL大小写规范（建议遵守）</h3><ul>
<li>MySQL 在 Windows 环境下是大小写不敏感的 </li>
<li>MySQL 在 Linux 环境下是大小写敏感的 <ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的 </li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li>推荐采用统一的书写规范： <ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写 </li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3) 注释"></a>3) 注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">单行注释：#注释文字(MySQL特有的方式)<br>单行注释：-- 注释文字(--后面必须包含一个空格。)<br>多行注释：/* 注释文字 */<br></code></pre></td></tr></table></figure>

<h3 id="4-命名规则"><a href="#4-命名规则" class="headerlink" title="4) 命名规则"></a>4) 命名规则</h3><ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个 </li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符 </li>
<li>数据库名、表名、字段名等对象名中间不要包含空格 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；</li>
<li>同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用&#96;（着重号）引起来 </li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h2 id="2-基本的SELECT语句"><a href="#2-基本的SELECT语句" class="headerlink" title="2. 基本的SELECT语句"></a>2. 基本的SELECT语句</h2><h3 id="1-SELECT-…-FROM"><a href="#1-SELECT-…-FROM" class="headerlink" title="1) SELECT … FROM"></a>1) SELECT … FROM</h3><ul>
<li>语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 标识选择哪些列<br>FROM 标识从哪个表中选择<br></code></pre></td></tr></table></figure>

<ul>
<li>选择全部列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM departments;<br></code></pre></td></tr></table></figure>

<ul>
<li>选择特定的列：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_id, location_id<br>FROM departments;<br></code></pre></td></tr></table></figure>

<h3 id="2-列的别名"><a href="#2-列的别名" class="headerlink" title="2) 列的别名"></a>2) 列的别名</h3><ul>
<li>重命名一个列 </li>
<li>便于计算 </li>
<li>紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特 殊的字符并区分大小写。 </li>
<li>AS 可以省略 </li>
<li>建议别名简短，见名知意 </li>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name AS name, commission_pct comm<br>FROM employees;<br></code></pre></td></tr></table></figure>

<h3 id="3-去除重复行"><a href="#3-去除重复行" class="headerlink" title="3) 去除重复行"></a>3) 去除重复行</h3><p>DISTINCT关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT department_id FROM employees;<br></code></pre></td></tr></table></figure>

<h3 id="4-空值参与运算"><a href="#4-空值参与运算" class="headerlink" title="4) 空值参与运算"></a>4) 空值参与运算</h3><p>空值：null ( 不等同于0, ’ ‘, ’null‘ )</p>
<p>实际问题的解决方案：引入IFNULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, salary &quot;月工资&quot;, salary * (1 + IFNULL(commission_pct, 0)) * 12 &quot;年工资&quot; FROM employees;<br></code></pre></td></tr></table></figure>

<p>这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h3 id="5-着重号"><a href="#5-着重号" class="headerlink" title="5) 着重号 &#96;&#96;"></a>5) 着重号 &#96;&#96;</h3><p>必须保证你的字段没有和保留字、数据库系统或常见方法冲突。</p>
<p>如果坚持使用，在SQL语句中使用 ` ` 引起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM `order`;<br></code></pre></td></tr></table></figure>

<h3 id="6-查询常数"><a href="#6-查询常数" class="headerlink" title="6) 查询常数"></a>6) 查询常数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT &#x27;小张科技&#x27; as &quot;公司名&quot;, employee_id, last_name FROM employees;<br></code></pre></td></tr></table></figure>

<h2 id="3-显示表结构"><a href="#3-显示表结构" class="headerlink" title="3. 显示表结构"></a>3. 显示表结构</h2><p>显示表中字段的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DESCRIBE employees;<br>或<br>DESC employees;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; desc employees;<br>+----------------+-------------+------+-----+---------+-------+<br>| Field | Type | Null | Key | Default | Extra |<br>+----------------+-------------+------+-----+---------+-------+<br>| employee_id | int(6) | NO | PRI | 0 | |<br>| first_name | varchar(20) | YES | | NULL | |<br>| last_name | varchar(25) | NO | | NULL | |<br>| email | varchar(25) | NO | UNI | NULL | |<br>| phone_number | varchar(20) | YES | | NULL | |<br>| hire_date | date | NO | | NULL | |<br>| job_id | varchar(10) | NO | MUL | NULL | |<br>| salary | double(8,2) | YES | | NULL | |<br>| commission_pct | double(2,2) | YES | | NULL | |<br>| manager_id | int(6) | YES | MUL | NULL | |<br>| department_id | int(4) | YES | MUL | NULL | |<br>+----------------+-------------+------+-----+---------+-------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>其中，各个字段的含义分别解释如下： </p>
<ul>
<li>Field：表示字段名称。 </li>
<li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。 </li>
<li>Null：表示该列是否可以存储NULL值。 </li>
<li>Key：表示该列是否已编制索引。</li>
<li>PRI表示该列是表主键的一部分；</li>
<li>UNI表示该列是UNIQUE索引的一 部分；</li>
<li>MUL表示在列中某个给定值允许出现多次。 </li>
<li>Default：表示该列是否有默认值，如果有，那么值是多少。 </li>
<li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li>
</ul>
<h2 id="4-过滤数据"><a href="#4-过滤数据" class="headerlink" title="4. 过滤数据"></a>4. 过滤数据</h2><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段1,字段2<br>FROM 表名<br>WHERE 过滤条件<br></code></pre></td></tr></table></figure>

<p>使用WHERE 子句，将不满足条件的行过滤掉。WHERE子句紧随 FROM子句。</p>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, job_id, department_id<br>FROM employees<br>WHERE department_id = 90;<br></code></pre></td></tr></table></figure>

<h1 id="第四章-运算符"><a href="#第四章-运算符" class="headerlink" title="第四章_运算符"></a>第四章_运算符</h1><p><strong>DUAL</strong> 伪表</p>
<h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 100 + 0, 100 + 50 * 30, 100 - 35.5 FROM DUAL;<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li>
<li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li>
<li>在Java中， + 的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中 + 只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（注：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）</li>
<li>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</li>
</ul>
</blockquote>
<h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><h3 id="1-等号运算符"><a href="#1-等号运算符" class="headerlink" title="1) 等号运算符"></a>1) 等号运算符</h3><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果 为假则返回0，其他情况则返回NULL。 </p>
<p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<p>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 = 1, 1 = &#x27;1&#x27;, 1 = 0, &#x27;a&#x27; = &#x27;a&#x27;, (5 + 3) = (2 + 6), &#x27;&#x27; = NULL , NULL = NULL;<br>+-------+---------+-------+-----------+-------------------+-----------+-------------+<br>| 1 = 1 | 1 = &#x27;1&#x27; | 1 = 0 | &#x27;a&#x27; = &#x27;a&#x27; | (5 + 3) = (2 + 6) | &#x27;&#x27; = NULL | NULL = NULL |<br>+-------+---------+-------+-----------+-------------------+-----------+-------------+<br>|   1   |    1    |   0   |     1     |          1        |    NULL   |     NULL    |<br>+-------+---------+-------+-----------+-------------------+-----------+-------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 = 2, 0 = &#x27;abc&#x27;, 1 = &#x27;abc&#x27; FROM DUAL;<br>+-------+-----------+-----------+<br>| 1 = 2 | 0 = &#x27;abc&#x27; | 1 = &#x27;abc&#x27; |<br>+-------+-----------+-----------+<br>|   0   |     1     |     0     |<br>+-------+-----------+-----------+<br>1 row in set, 2 warnings (0.00 sec)<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI编码是否相等。 </li>
<li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。 </li>
<li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。 </li>
<li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ysql&gt; SELECT 1 &lt;=&gt; &#x27;1&#x27;, 1 &lt;=&gt; 0, &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27;, (5 + 3) &lt;=&gt; (2 + 6), &#x27;&#x27; &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual;<br>+-----------+---------+-------------+---------------------+-------------+---------------+<br>| 1 &lt;=&gt; &#x27;1&#x27; | 1 &lt;=&gt; 0 | &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27; | (5 + 3) &lt;=&gt; (2 + 6) | &#x27;&#x27; &lt;=&gt; NULL | NULL &lt;=&gt; NULL |<br>+-----------+---------+-------------+---------------------+-------------+---------------+<br>|     1     |    0    |      1      |           1         |      0      |       1       |<br>+-----------+---------+-------------+---------------------+-------------+---------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。</p>
<h3 id="2-不等于运算符"><a href="#2-不等于运算符" class="headerlink" title="2) 不等于运算符"></a>2) 不等于运算符</h3><p>不等于运算符（&lt;&gt;和!&#x3D;）用于判断两边的数字、字符串或者表达式的值是否不相等， 如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL， 或两边都为NULL，则结果为NULL。 SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, &#x27;a&#x27; != &#x27;b&#x27;, (3+4) &lt;&gt; (2+6), &#x27;a&#x27; != NULL, NULL &lt;&gt; NULL;<br>+--------+--------+------------+----------------+-------------+--------------+<br>| 1 &lt;&gt; 1 | 1 != 2 | &#x27;a&#x27; != &#x27;b&#x27; | (3+4) &lt;&gt; (2+6) | &#x27;a&#x27; != NULL | NULL &lt;&gt; NULL |<br>+--------+--------+------------+----------------+-------------+--------------+<br>|    0   |    1   |      1     |        1       |     NULL    |      NULL    |<br>+--------+--------+------------+----------------+-------------+--------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>此外，还有非符号类型的运算符：</p>
<img src="https://s2.loli.net/2024/02/24/pz4oOtXjN8iD9am.png" alt="image-20220531154418141" style="float:left;" />

<h3 id="3-空运算符"><a href="#3-空运算符" class="headerlink" title="3) 空运算符"></a>3) 空运算符</h3><p>空运算符 (IS NULL 或者 ISNULL) 判断一个值是否为NULL，如果为NULL则返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL(&#x27;a&#x27;), 1 IS NULL;<br>+--------------+--------------+-------------+-----------+<br>| NULL IS NULL | ISNULL(NULL) | ISNULL(&#x27;a&#x27;) | 1 IS NULL |<br>+--------------+--------------+-------------+-----------+<br>|      1       |       1      |      0      |     0     |<br>+--------------+--------------+-------------+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<h3 id="4-非空运算符"><a href="#4-非空运算符" class="headerlink" title="4) 非空运算符"></a>4) 非空运算符</h3><p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。</p>
<h3 id="5-最小值运算符"><a href="#5-最小值运算符" class="headerlink" title="5) 最小值运算符"></a>5) 最小值运算符</h3><p>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有 两个或多个参数的情况下，返回最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT LEAST (1,0,2), LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), LEAST(1,NULL,2);<br>+---------------+--------------------+-----------------+<br>| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |<br>+---------------+--------------------+-----------------+<br>|       0       |          a         |        NULL     |<br>+---------------+--------------------+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字 母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<h3 id="6-最大值运算符"><a href="#6-最大值运算符" class="headerlink" title="6) 最大值运算符"></a>6) 最大值运算符</h3><p>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有 两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT GREATEST(1,0,2), GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), GREATEST(1,NULL,2);<br>+-----------------+-----------------------+--------------------+<br>| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |<br>+-----------------+-----------------------+--------------------+<br>|         2       |             c         |         NULL       |<br>+-----------------+-----------------------+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时， 返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<h3 id="7-BETWEEN-AND运算符"><a href="#7-BETWEEN-AND运算符" class="headerlink" title="7) BETWEEN AND运算符"></a>7) BETWEEN AND运算符</h3><p>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p>
<h3 id="8-IN运算符"><a href="#8-IN运算符" class="headerlink" title="8) IN运算符"></a>8) IN运算符</h3><p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给 定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 IN (2,3), NULL IN (&#x27;a&#x27;,&#x27;b&#x27;), &#x27;a&#x27; IN (&#x27;a&#x27;, NULL);<br>+----------------------+------------+-------------------+--------------------+<br>| &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 IN (2,3) | NULL IN (&#x27;a&#x27;,&#x27;b&#x27;) | &#x27;a&#x27; IN (&#x27;a&#x27;, NULL) |<br>+----------------------+------------+-------------------+--------------------+<br>|            1         |      0     |         NULL      |          1         |<br>+----------------------+------------+-------------------+--------------------+<br></code></pre></td></tr></table></figure>

<h3 id="9-NOT-IN运算符"><a href="#9-NOT-IN运算符" class="headerlink" title="9) NOT IN运算符"></a>9) NOT IN运算符</h3><p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一 个值，则返回1，否则返回0。</p>
<h3 id="10-LIKE运算符"><a href="#10-LIKE运算符" class="headerlink" title="10) LIKE运算符"></a>10) LIKE运算符</h3><p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">“%”：匹配0个或多个字符。<br>“_”：只能匹配一个字符。<br></code></pre></td></tr></table></figure>

<h3 id="11-ESCAPE"><a href="#11-ESCAPE" class="headerlink" title="11) ESCAPE"></a>11) ESCAPE</h3><p>回避特殊符号的：使用转义符。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT job_id<br>FROM jobs<br>WHERE job_id LIKE ‘IT\_%‘;<br></code></pre></td></tr></table></figure>

<p>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT job_id<br>FROM jobs<br>WHERE job_id LIKE ‘IT$_%‘ escape ‘$‘;<br></code></pre></td></tr></table></figure>

<h3 id="12-REGEXP运算符"><a href="#12-REGEXP运算符" class="headerlink" title="12) REGEXP运算符"></a>12) REGEXP运算符</h3><p>REGEXP运算符用来匹配字符串，语法格式为： expr REGEXP 匹配条件 。</p>
<blockquote>
<p>（1）‘^’匹配以该字符后面的字符开头的字符串。 </p>
<p>（2）‘$’匹配以该字符前面的字符结尾的字符串。 </p>
<p>（3）‘.’匹配任何一个单字符。 </p>
<p>（4）“[…]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</p>
<p>（5）‘<em>’匹配零个或多个在它前面的字符。例如，“x</em>”匹配任何数量的‘x’字符，“[0-9]<em>”匹配任何数量的数字， 而“</em>”匹配任何数量的任何字符。</p>
</blockquote>
<h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。 </p>
<p>MySQL中支持4种逻辑运算符如下：</p>
<p><img src="https://s2.loli.net/2024/02/24/AME5hZSJ4pjizRs.png" alt="image-20220531195405333"></p>
<h2 id="4-位运算"><a href="#4-位运算" class="headerlink" title="4. 位运算"></a>4. 位运算</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数。 </p>
<p>MySQL支持的位运算符如下：</p>
<p><img src="https://s2.loli.net/2024/02/24/JWvp2ZGh6I8lHPC.png" alt="image-20220531195442995"></p>
<h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><p>数字编号越大，优先级越高，优先级高的运算符先进行计算。</p>
<p><img src="https://s2.loli.net/2024/02/24/n5qlsOFDpcEwzjP.png" alt="image-20220531195522668"></p>
<h2 id="扩展：使用正则表达式查询"><a href="#扩展：使用正则表达式查询" class="headerlink" title="扩展：使用正则表达式查询"></a>扩展：使用正则表达式查询</h2><p><img src="https://s2.loli.net/2024/02/24/DYEhJT9SpAeC7Mg.png" alt="image-20220531204253508"></p>
<h1 id="第五章-排序与分页"><a href="#第五章-排序与分页" class="headerlink" title="第五章_排序与分页"></a>第五章_排序与分页</h1><h2 id="1-排序规则"><a href="#1-排序规则" class="headerlink" title="1. 排序规则"></a>1. 排序规则</h2><ul>
<li><p>使用 ORDER BY 子句排序</p>
<ul>
<li>ASC（ascend）: 升序 </li>
<li>DESC（descend）:降序</li>
</ul>
</li>
<li><p>ORDER BY 子句在SELECT语句的结尾。</p>
</li>
</ul>
<h3 id="1-单列排序"><a href="#1-单列排序" class="headerlink" title="1) 单列排序"></a>1) 单列排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, job_id, department_id, hire_date<br>FROM employees<br>ORDER BY hire_date;<br></code></pre></td></tr></table></figure>

<h3 id="2-多列排序"><a href="#2-多列排序" class="headerlink" title="2) 多列排序"></a>2) 多列排序</h3><ul>
<li>可以使用不在SELECT列表中的列排序。 </li>
<li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第 一列数据中所有值都是唯一的，将不再对第二列进行排序。</li>
</ul>
<h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><ul>
<li>格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">LIMIT [位置偏移量,] 行数<br></code></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">--前10条记录：<br>SELECT * FROM 表名 LIMIT 0,10;<br>或者<br>SELECT * FROM 表名 LIMIT 10;<br>--第11至20条记录：<br>SELECT * FROM 表名 LIMIT 10,10;<br>--第21至30条记录：<br>SELECT * FROM 表名 LIMIT 20,10;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p>
</blockquote>
<ul>
<li>分页显式公式：（当前页数-1）* 每页条数，每页条数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM table<br>LIMIT(PageNo - 1) * PageSize, PageSize;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意：LIMIT 子句必须放在整个SELECT语句的最后！</p>
</li>
<li><p>使用LIMIT的好处</p>
</li>
</ul>
<p>约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有 1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p>
<h1 id="第六章-多表查询"><a href="#第六章-多表查询" class="headerlink" title="第六章_多表查询"></a>第六章_多表查询</h1><h2 id="1-多表查询分类讲解"><a href="#1-多表查询分类讲解" class="headerlink" title="1. 多表查询分类讲解"></a>1. 多表查询分类讲解</h2><h3 id="1-自连接"><a href="#1-自连接" class="headerlink" title="1) 自连接"></a>1) 自连接</h3><p>题目：查询employees表，返回 &lt;员工 works for 老板&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT CONCAT(worker.last_name , &#x27; works for &#x27;, manager.last_name)<br>FROM employees worker, employees manager<br>WHERE worker.manager_id = manager.employee_id;<br></code></pre></td></tr></table></figure>

<h3 id="2-内连接与外连接"><a href="#2-内连接与外连接" class="headerlink" title="2) 内连接与外连接"></a>2) 内连接与外连接</h3><ul>
<li>内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</li>
</ul>
<p><strong>SQL92语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT emp.employee_id, dep.department_name<br>FROM employee emp, department dep<br>WHERE emp.`department_id` = dep.`department_id`;<br></code></pre></td></tr></table></figure>

<p><strong>SQL99语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT emp.employee_id, dep.department_name<br>FROM employee emp JOIN department dep<br>ON emp.`department_id` = dep.`department_id`;<br></code></pre></td></tr></table></figure>

<ul>
<li>外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。 </li>
<li>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。</li>
</ul>
<p><strong>LEFT OUTER JOIN</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, department_name<br>FROM employees emp LEFT OUTER JOIN department dep<br>ON emp.`department_id` = dep.`department_id`;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</li>
</ul>
<p><strong>RIGHT OUTER JOIN</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, department_name<br>FROM employees emp RIGHT OUTER JOIN department dep<br>ON emp.`department_id` = dep.`department_id`;<br></code></pre></td></tr></table></figure>

<h2 id="2-UNION的使用"><a href="#2-UNION的使用" class="headerlink" title="2. UNION的使用"></a>2. UNION的使用</h2><p><strong>合并查询结果</strong> </p>
<p>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并 时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT column,... FROM table1<br>UNION [ALL]<br>SELECT column,... FROM table2<br></code></pre></td></tr></table></figure>

<p><strong>UNION操作符</strong></p>
<p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p>
<p><strong>UNION ALL操作符</strong></p>
<p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
<blockquote>
<p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
</blockquote>
<p>举例：查询部门编号&gt;90或邮箱包含a的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式1<br>SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式2<br>SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27;<br>UNION<br>SELECT * FROM employees WHERE department_id&gt;90;<br></code></pre></td></tr></table></figure>

<p>举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT id,cname FROM t_chinamale WHERE csex=&#x27;男&#x27;<br>UNION ALL<br>SELECT id,tname FROM t_usmale WHERE tGender=&#x27;male&#x27;;<br></code></pre></td></tr></table></figure>

<h2 id="3-七种SQL-JOINS的实现"><a href="#3-七种SQL-JOINS的实现" class="headerlink" title="3.七种SQL JOINS的实现"></a>3.七种SQL JOINS的实现</h2><img src="https://s2.loli.net/2024/02/24/ePpS4bqua9sCONA.png" alt="image-20220531224324213" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 中图：内连接<br>SELECT employee_id,department_name<br>FROM employees e JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br><br># 左上图：左外连接<br>SELECT employee_id,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br><br># 右上图：右外连接<br>SELECT employee_id,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br><br># 左中图：<br>SELECT employee_id,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_id` IS NULL;<br><br># 右中图：<br>SELECT employee_id,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`department_id` IS NULL;<br><br><br># 左下图：满外连接<br># 方式1：左上图 UNION ALL 右中图<br>SELECT employee_id,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>UNION ALL<br>SELECT employee_id,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`department_id` IS NULL;<br><br><br># 方式2：左中图 UNION ALL 右上图<br>SELECT employee_id,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_id` IS NULL<br>UNION ALL<br>SELECT employee_id,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`;<br><br># 右下图：左中图  UNION ALL 右中图<br>SELECT employee_id,department_name<br>FROM employees e LEFT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_id` IS NULL<br>UNION ALL<br>SELECT employee_id,department_name<br>FROM employees e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`department_id` IS NULL;<br></code></pre></td></tr></table></figure>

<h2 id="4-SQL99语法的新特性"><a href="#4-SQL99语法的新特性" class="headerlink" title="4. SQL99语法的新特性"></a>4. SQL99语法的新特性</h2><h3 id="1-自然连接"><a href="#1-自然连接" class="headerlink" title="1) 自然连接"></a>1) 自然连接</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行 等值 连接 。</p>
<p>在SQL92标准中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>AND e.`manager_id` = d.`manager_id`;<br></code></pre></td></tr></table></figure>

<p>在 SQL99 中你可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e NATURAL JOIN departments d;<br></code></pre></td></tr></table></figure>

<h3 id="2-USING连接"><a href="#2-USING连接" class="headerlink" title="2) USING连接"></a>2) USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配 合JOIN一起使用。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e JOIN departments d<br>USING (department_id);<br></code></pre></td></tr></table></figure>

<p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下 面的 SQL 查询结果是相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id,last_name,department_name<br>FROM employees e ,departments d<br>WHERE e.department_id = d.department_id;<br></code></pre></td></tr></table></figure>

<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING </p>
<ul>
<li>WHERE：适用于所有关联查询 </li>
<li>ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起 写，但分开写可读性更好。 </li>
<li>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字 段值相等</li>
</ul>
<blockquote>
<p>我们要控制连接表的数量 。</p>
<p>多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下 降得很严重，因此不要连接不必要的表。</p>
<p>在许多 DBMS 中，也都会有最大连接表的限制。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 习题巩固<br># 注意：当两个表外连接之后，组成主表和从表，主表的连接字段是不为空的，从表的连接字段可能为空，因此从表的关键字段用来判断是否为空。<br><br># 1.查询哪些部门没有员工<br># 方式一<br>SELECT d.department_id<br>FROM departments d LEFT JOIN employees e<br>ON d.`department_id` = e.`department_id`<br>WHERE e.`department_id` IS NULL;<br><br># 方式二<br>SELECT department_id<br>FROM departments d<br>WHERE NOT EXISTS (<br>		SELECT *<br>    	FROM employees e<br>    	WHERE e.`department_id` = d.`department_id`<br>);<br><br># 2.查询哪个城市没有部门<br>SELECT l.location_id, l.city<br>FROM locations l LEFT JOIN departments d<br>ON l.`location_id` = d.`location_id`<br>WHERE d.`location_id` IS NULL;<br><br># 3.查询部门名为 Sales 或 IT 的员工信息<br>SELECT e.employee_id, e.last_name, e.department_id<br>FROM employees e JOIN department d<br>ON e.`department_id` = d.`department_id`<br>WHERE d.`department_name` IN (&#x27;Sales&#x27;, &#x27;IT&#x27;);<br></code></pre></td></tr></table></figure>

<h1 id="第七章-单行函数"><a href="#第七章-单行函数" class="headerlink" title="第七章_单行函数"></a>第七章_单行函数</h1><h2 id="1-数值函数"><a href="#1-数值函数" class="headerlink" title="1. 数值函数"></a>1. 数值函数</h2><h3 id="1-基本函数"><a href="#1-基本函数" class="headerlink" title="1) 基本函数"></a>1) 基本函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIGN(X)</td>
<td>单元格</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值</td>
</tr>
<tr>
<td>CEIL(x)，CEILING(x)</td>
<td>返回大于或等于某个值的最小整数</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>返回小于或等于某个值的最大整数</td>
</tr>
<tr>
<td>LEAST(e1,e2,e3…)</td>
<td>返回列表中的最小值</td>
</tr>
<tr>
<td>GREATEST(e1,e2,e3…)</td>
<td>返回列表中的最大值</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回X除以Y后的余数</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1的随机值</td>
</tr>
<tr>
<td>RAND(x)</td>
<td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机 数</td>
</tr>
<tr>
<td>ROUND(x)</td>
<td>返回一个对x的值进行四舍五入后，最接近于X的整数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td>
</tr>
<tr>
<td>TRUNCATE(x,y)</td>
<td>返回数字x截断为y位小数的结果</td>
</tr>
<tr>
<td>SQRT(x)</td>
<td>返回x的平方根。当X的值为负数时，返回NULL</td>
</tr>
</tbody></table>
<h3 id="2-角度与弧度互换函数"><a href="#2-角度与弧度互换函数" class="headerlink" title="2) 角度与弧度互换函数"></a>2) 角度与弧度互换函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>RADIANS(x)</td>
<td>将角度转化为弧度，其中，参数x为角度值</td>
</tr>
<tr>
<td>DEGREES(x)</td>
<td>将弧度转化为角度，其中，参数x为弧度值</td>
</tr>
</tbody></table>
<h3 id="3-三角函数"><a href="#3-三角函数" class="headerlink" title="3) 三角函数"></a>3) 三角函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>SIN(x)</td>
<td>将角度转化为弧度，其中，参数x为角度值</td>
</tr>
<tr>
<td>ASIN(x)</td>
<td>将弧度转化为角度，其中，参数x为弧度值</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回x的余弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ACOS(x)</td>
<td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>TAN(x)</td>
<td>返回x的正切值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ATAN(x)</td>
<td>返回x的反正切值，即返回正切值为x的值</td>
</tr>
<tr>
<td>ATAN2(m,n)</td>
<td>返回两个参数的反正切值</td>
</tr>
<tr>
<td>COT(x)</td>
<td>返回x的余切值，其中，X为弧度值</td>
</tr>
</tbody></table>
<h3 id="4-指数与对数函数"><a href="#4-指数与对数函数" class="headerlink" title="4) 指数与对数函数"></a>4) 指数与对数函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>POW(x,y)，POWER(X,Y)</td>
<td>返回x的y次方</td>
</tr>
<tr>
<td>EXP(X)</td>
<td>返回e的X次方，其中e是一个常数，2.718281828459045</td>
</tr>
<tr>
<td>LN(X)，LOG(X)</td>
<td>返回以e为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG10(X)</td>
<td>返回以10为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG2(X)</td>
<td>返回以2为底的X的对数，当X &lt;&#x3D; 0 时，返回NULL</td>
</tr>
</tbody></table>
<h3 id="5-进制间的转换"><a href="#5-进制间的转换" class="headerlink" title="5) 进制间的转换"></a>5) 进制间的转换</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>BIN(x)</td>
<td>返回x的二进制编码</td>
</tr>
<tr>
<td>HEX(x)</td>
<td>返回x的十六进制编码</td>
</tr>
<tr>
<td>OCT(x)</td>
<td>返回x的八进制编码</td>
</tr>
<tr>
<td>CONV(x,f1,f2)</td>
<td>返回f1进制数变成f2进制数</td>
</tr>
</tbody></table>
<h2 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2. 字符串函数"></a>2. 字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII(S)</td>
<td>返回字符串S中的第一个字符的ASCII码值</td>
</tr>
<tr>
<td>CHAR_LENGTH(s)</td>
<td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td>
</tr>
<tr>
<td>LENGTH(s)</td>
<td>返回字符串s的字节数，和字符集有关</td>
</tr>
<tr>
<td>CONCAT(s1,s2,……,sn)</td>
<td>连接s1,s2,……,sn为一个字符串</td>
</tr>
<tr>
<td>CONCAT_WS(x, s1,s2,……,sn)</td>
<td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td>
</tr>
<tr>
<td>INSERT(str, idx, len, replacestr)</td>
<td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td>
</tr>
<tr>
<td>REPLACE(str, a, b)</td>
<td>用字符串b替换字符串str中所有出现的字符串a</td>
</tr>
<tr>
<td>UPPER(s) 或 UCASE(s)</td>
<td>将字符串s的所有字母转成大写字母</td>
</tr>
<tr>
<td>LOWER(s) 或LCASE(s)</td>
<td>将字符串s的所有字母转成小写字母</td>
</tr>
<tr>
<td>LEFT(str,n)</td>
<td>返回字符串str最左边的n个字符</td>
</tr>
<tr>
<td>RIGHT(str,n)</td>
<td>返回字符串str最右边的n个字符</td>
</tr>
<tr>
<td>LPAD(str, len, pad)</td>
<td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td>
</tr>
<tr>
<td>RPAD(str ,len, pad)</td>
<td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td>
</tr>
<tr>
<td>LTRIM(s)</td>
<td>去掉字符串s左侧的空格</td>
</tr>
<tr>
<td>RTRIM(s)</td>
<td>去掉字符串s右侧的空格</td>
</tr>
<tr>
<td>TRIM(s)</td>
<td>去掉字符串s开始与结尾的空格</td>
</tr>
<tr>
<td>TRIM(s1 FROM s)</td>
<td>去掉字符串s开始与结尾的s1</td>
</tr>
<tr>
<td>TRIM(LEADING s1 FROM s)</td>
<td>去掉字符串s开始处的s1</td>
</tr>
<tr>
<td>TRIM(TRAILING s1 FROM s)</td>
<td>去掉字符串s结尾处的s1</td>
</tr>
<tr>
<td>REPEAT(str, n)</td>
<td>返回str重复n次的结果</td>
</tr>
<tr>
<td>SPACE(n)</td>
<td>返回n个空格</td>
</tr>
<tr>
<td>STRCMP(s1,s2)</td>
<td>比较字符串s1,s2的ASCII码值的大小</td>
</tr>
<tr>
<td>SUBSTR(s,index,len)</td>
<td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同</td>
</tr>
<tr>
<td>LOCATE(substr,str)</td>
<td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td>
</tr>
<tr>
<td>ELT(m,s1,s2,…,sn)</td>
<td>返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn</td>
</tr>
<tr>
<td>FIELD(s,s1,s2,…,sn)</td>
<td>返回字符串s在字符串列表中第一次出现的位置</td>
</tr>
<tr>
<td>FIND_IN_SET(s1,s2)</td>
<td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td>
</tr>
<tr>
<td>REVERSE(s)</td>
<td>返回s反转后的字符串</td>
</tr>
<tr>
<td>NULLIF(value1,value2)</td>
<td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：MySQL中，字符串的位置是从1开始的。</p>
</blockquote>
<h2 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3. 日期和时间函数"></a>3. 日期和时间函数</h2><h3 id="1-获取日期、时间"><a href="#1-获取日期、时间" class="headerlink" title="1) 获取日期、时间"></a>1) 获取日期、时间</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE() ，CURRENT_DATE()</td>
<td>返回当前日期，只包含年、 月、日</td>
</tr>
<tr>
<td>CURTIME() ， CURRENT_TIME()</td>
<td>返回当前时间，只包含时、 分、秒</td>
</tr>
<tr>
<td>NOW() &#x2F; SYSDATE() &#x2F; CURRENT_TIMESTAMP() &#x2F; LOCALTIME() &#x2F; LOCALTIMESTAMP()</td>
<td>返回当前系统日期和时间</td>
</tr>
<tr>
<td>UTC_DATE()</td>
<td>返回UTC（世界标准时间） 日期</td>
</tr>
<tr>
<td>UTC_TIME()</td>
<td>返回UTC（世界标准时间） 时间</td>
</tr>
</tbody></table>
<h3 id="2-日期与时间戳的转换"><a href="#2-日期与时间戳的转换" class="headerlink" title="2) 日期与时间戳的转换"></a>2) 日期与时间戳的转换</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>UNIX_TIMESTAMP()</td>
<td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - &gt;1634348884</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP(date)</td>
<td>将时间date以UNIX时间戳的形式返回。</td>
</tr>
<tr>
<td>FROM_UNIXTIME(timestamp)</td>
<td>将UNIX时间戳的时间转换为普通格式的时间</td>
</tr>
</tbody></table>
<h3 id="3-获取月份、星期、星期数、天数等函数"><a href="#3-获取月份、星期、星期数、天数等函数" class="headerlink" title="3) 获取月份、星期、星期数、天数等函数"></a>3) 获取月份、星期、星期数、天数等函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR(date) &#x2F; MONTH(date) &#x2F; DAY(date)</td>
<td>返回具体的日期值</td>
</tr>
<tr>
<td>HOUR(time) &#x2F; MINUTE(time) &#x2F; SECOND(time)</td>
<td>返回具体的时间值</td>
</tr>
<tr>
<td>FROM_UNIXTIME(timestamp)</td>
<td>将UNIX时间戳的时间转换为普通格式的时间</td>
</tr>
<tr>
<td>MONTHNAME(date)</td>
<td>返回月份：January，…</td>
</tr>
<tr>
<td>DAYNAME(date)</td>
<td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td>
</tr>
<tr>
<td>WEEKDAY(date)</td>
<td>返回周几，注意，周1是0，周2是1，。。。周日是6</td>
</tr>
<tr>
<td>QUARTER(date)</td>
<td>返回日期对应的季度，范围为1～4</td>
</tr>
<tr>
<td>WEEK(date) ， WEEKOFYEAR(date)</td>
<td>返回一年中的第几周</td>
</tr>
<tr>
<td>DAYOFYEAR(date)</td>
<td>返回日期是一年中的第几天</td>
</tr>
<tr>
<td>DAYOFMONTH(date)</td>
<td>返回日期位于所在月份的第几天</td>
</tr>
<tr>
<td>DAYOFWEEK(date)</td>
<td>返回周几，注意：周日是1，周一是2，。。。周六是 7</td>
</tr>
</tbody></table>
<h3 id="4-日期的操作函数"><a href="#4-日期的操作函数" class="headerlink" title="4) 日期的操作函数"></a>4) 日期的操作函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>EXTRACT(type FROM date)</td>
<td>返回指定日期中特定的部分，type指定返回的值</td>
</tr>
</tbody></table>
<p>EXTRACT(type FROM date)函数中type的取值与含义：</p>
<p><img src="https://s2.loli.net/2024/02/24/SeDPukqrlnJfBvU.png" alt="image-20220601162705975"></p>
<h3 id="5-时间和秒钟转换的函数"><a href="#5-时间和秒钟转换的函数" class="headerlink" title="5) 时间和秒钟转换的函数"></a>5) 时间和秒钟转换的函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>TIME_TO_SEC(time)</td>
<td>将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟 *60+秒</td>
</tr>
<tr>
<td>SEC_TO_TIME(seconds)</td>
<td>将 seconds 描述转化为包含小时、分钟和秒的时间</td>
</tr>
</tbody></table>
<h3 id="6-计算日期和时间的函数"><a href="#6-计算日期和时间的函数" class="headerlink" title="6) 计算日期和时间的函数"></a>6) 计算日期和时间的函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_ADD(datetime, INTERVAL expr type)， ADDDATE(date,INTERVAL expr type)</td>
<td>返回与给定日期时间相差INTERVAL时间段的日期时间</td>
</tr>
<tr>
<td>DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type)</td>
<td>返回与date相差INTERVAL时间间隔的日期</td>
</tr>
</tbody></table>
<p>上述函数中type的取值：</p>
<p><img src="https://s2.loli.net/2024/02/24/eBGJlCEOP9Q57nU.png" alt="image-20220601165055639"></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ADDTIME(time1,time2)</td>
<td>返回time1加上time2的时间。当time2为一个数字时，代表的是 秒 ，可以为负数</td>
</tr>
<tr>
<td>SUBTIME(time1,time2)</td>
<td>返回time1减去time2后的时间。当time2为一个数字时，代表的 是 秒 ，可以为负数</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回date1 - date2的日期间隔天数</td>
</tr>
<tr>
<td>TIMEDIFF(time1, time2)</td>
<td>返回time1 - time2的时间间隔</td>
</tr>
<tr>
<td>FROM_DAYS(N)</td>
<td>返回从0000年1月1日起，N天以后的日期</td>
</tr>
<tr>
<td>TO_DAYS(date)</td>
<td>返回日期date距离0000年1月1日的天数</td>
</tr>
<tr>
<td>LAST_DAY(date)</td>
<td>返回date所在月份的最后一天的日期</td>
</tr>
<tr>
<td>MAKEDATE(year,n)</td>
<td>针对给定年份与所在年份中的天数返回一个日期</td>
</tr>
<tr>
<td>MAKETIME(hour,minute,second)</td>
<td>将给定的小时、分钟和秒组合成时间并返回</td>
</tr>
<tr>
<td>PERIOD_ADD(time,n)</td>
<td>返回time加上n后的时间</td>
</tr>
</tbody></table>
<h3 id="7-日期的格式化与解析"><a href="#7-日期的格式化与解析" class="headerlink" title="7)  日期的格式化与解析"></a>7)  日期的格式化与解析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_FORMAT(date,fmt)</td>
<td>按照字符串fmt格式化日期date值</td>
</tr>
<tr>
<td>TIME_FORMAT(time,fmt)</td>
<td>按照字符串fmt格式化时间time值</td>
</tr>
<tr>
<td>GET_FORMAT(date_type,format_type)</td>
<td>返回日期字符串的显示格式</td>
</tr>
<tr>
<td>STR_TO_DATE(str, fmt)</td>
<td>按照字符串fmt对str进行解析，解析为一个日期</td>
</tr>
</tbody></table>
<p>上述 非GET_FORMAT 函数中fmt参数常用的格式符：</p>
<table>
<thead>
<tr>
<th>格式符</th>
<th>说明</th>
<th>格式符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>4位数字表示年份</td>
<td>%y</td>
<td>表示两位数字表示年份</td>
</tr>
<tr>
<td>%M</td>
<td>月名表示月份（January,….）</td>
<td>%m</td>
<td>两位数字表示月份 （01,02,03。。。）</td>
</tr>
<tr>
<td>%b</td>
<td>缩写的月名（Jan.，Feb.，….）</td>
<td>%c</td>
<td>数字表示月份（1,2,3,…）</td>
</tr>
<tr>
<td>%D</td>
<td>英文后缀表示月中的天数 （1st,2nd,3rd,…）</td>
<td>%d</td>
<td>两位数字表示月中的天数(01,02…)</td>
</tr>
<tr>
<td>%e</td>
<td>数字形式表示月中的天数 （1,2,3,4,5…..）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>两位数字表示小数，24小时制 （01,02..）</td>
<td>%h 和%I</td>
<td>两位数字表示小时，12小时制 （01,02..）</td>
</tr>
<tr>
<td>%k</td>
<td>数字形式的小时，24小时制(1,2,3)</td>
<td>%l</td>
<td>数字形式表示小时，12小时制 （1,2,3,4….）</td>
</tr>
<tr>
<td>%i</td>
<td>两位数字表示分钟（00,01,02）</td>
<td>%S 和%s</td>
<td>两位数字表示秒(00,01,02…)</td>
</tr>
<tr>
<td>%W</td>
<td>一周中的星期名称（Sunday…）</td>
<td>%a</td>
<td>一周中的星期缩写（Sun.， Mon.,Tues.，..）</td>
</tr>
<tr>
<td>%w</td>
<td>以数字表示周中的天数 (0&#x3D;Sunday,1&#x3D;Monday….)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%j</td>
<td>以3位数字表示年中的天数(001,002…)</td>
<td>%U</td>
<td>以数字表示年中的第几周， （1,2,3。。）其中Sunday为周中第一 天</td>
</tr>
<tr>
<td>%u</td>
<td>以数字表示年中的第几周， （1,2,3。。）其中Monday为周中第一 天</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%T</td>
<td>24小时制</td>
<td>%r</td>
<td>12小时制</td>
</tr>
<tr>
<td>%p</td>
<td>AM或PM</td>
<td>%%</td>
<td>表示%</td>
</tr>
</tbody></table>
<h2 id="4-流程控制函数"><a href="#4-流程控制函数" class="headerlink" title="4. 流程控制函数"></a>4. 流程控制函数</h2><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。 MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value,value1,value2)</td>
<td>如果value的值为TRUE，返回value1， 否则返回value2</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为NULL，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END</td>
<td>相当于Java的if…else if…else…</td>
</tr>
<tr>
<td>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td>
<td>相当于Java的switch…case…</td>
</tr>
</tbody></table>
<h2 id="5-加密与解密函数"><a href="#5-加密与解密函数" class="headerlink" title="5. 加密与解密函数"></a>5. 加密与解密函数</h2><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>PASSWORD(str)</td>
<td>返回字符串str的加密版本，41位长的字符串。加密结果不可逆 ，常用于用户的密码加密</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL</td>
</tr>
<tr>
<td>SHA(str)</td>
<td>从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。</td>
</tr>
<tr>
<td>ENCODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码加密value</td>
</tr>
<tr>
<td>DECODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码解密value</td>
</tr>
</tbody></table>
<h2 id="6-MySQL信息函数"><a href="#6-MySQL信息函数" class="headerlink" title="6. MySQL信息函数"></a>6. MySQL信息函数</h2><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地 对数据库进行维护工作。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>VERSION()</td>
<td>返回当前MySQL的版本号</td>
</tr>
<tr>
<td>CONNECTION_ID()</td>
<td>返回当前MySQL服务器的连接数</td>
</tr>
<tr>
<td>DATABASE()，SCHEMA()</td>
<td>返回MySQL命令行当前所在的数据库</td>
</tr>
<tr>
<td>USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER()</td>
<td>返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名”</td>
</tr>
<tr>
<td>CHARSET(value)</td>
<td>返回字符串value自变量的字符集</td>
</tr>
<tr>
<td>COLLATION(value)</td>
<td>返回字符串value的比较规则</td>
</tr>
</tbody></table>
<p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视 的。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>FORMAT(value,n)</td>
<td>返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留 到小数点后n位</td>
</tr>
<tr>
<td>CONV(value,from,to)</td>
<td>将value的值进行不同进制之间的转换</td>
</tr>
<tr>
<td>INET_ATON(ipvalue)</td>
<td>将以点分隔的IP地址转化为一个数字</td>
</tr>
<tr>
<td>INET_NTOA(value)</td>
<td>将数字形式的IP地址转化为以点分隔的IP地址</td>
</tr>
<tr>
<td>BENCHMARK(n,expr)</td>
<td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间</td>
</tr>
<tr>
<td>CONVERT(value USING char_code)</td>
<td>将value所使用的字符编码修改为char_code</td>
</tr>
</tbody></table>
<h1 id="第八章-聚合函数"><a href="#第八章-聚合函数" class="headerlink" title="第八章_聚合函数"></a>第八章_聚合函数</h1><h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><ul>
<li>什么是聚合函数</li>
</ul>
<p>聚合函数作用于一组数据，并对一组数据返回一个值。</p>
<ul>
<li>聚合函数类型<ul>
<li>AVG()</li>
<li>SUM()</li>
<li>MAX()</li>
<li>MIN()</li>
<li>COUNT()</li>
</ul>
</li>
</ul>
<h3 id="1-AVG和SUM函数"><a href="#1-AVG和SUM函数" class="headerlink" title="1) AVG和SUM函数"></a>1) AVG和SUM函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)<br>FROM employees<br>WHERE job_id LIKE &#x27;%REP%&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="2-MIN和MAX函数"><a href="#2-MIN和MAX函数" class="headerlink" title="2) MIN和MAX函数"></a>2) MIN和MAX函数</h3><p>可以对任意数据类型的数据使用 MIN 和 MAX 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT MIN(hire_date), MAX(hire_date)<br>FROM employees;<br></code></pre></td></tr></table></figure>

<h3 id="3-COUNT函数"><a href="#3-COUNT函数" class="headerlink" title="3) COUNT函数"></a>3) COUNT函数</h3><p>COUNT(*)返回表中记录总数，适用于任意数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*)<br>FROM employees<br>WHERE department_id = 50;<br></code></pre></td></tr></table></figure>

<p>COUNT(expr) 返回expr不为空的记录总数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT COUNT(commission_pct)<br>FROM employees<br>WHERE department_id = 50;<br></code></pre></td></tr></table></figure>

<ul>
<li>问题：用count(*)，count(1)，count(列名)谁好呢?</li>
</ul>
<p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好 于具体的count(列名)。</p>
<ul>
<li>问题：能不能使用count(列名)替换count(*)?</li>
</ul>
<p>不要使用 count(列名)来替代 count(<em>) ， count(</em>) 是 SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1) 基本使用"></a>1) 基本使用</h3><p>可以使用GROUP BY子句将表中的数据分成若干组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT column, group_function(column)<br>FROM table<br>[WHERE condition]<br>[GROUP BY group_by_expression]<br>[ORDER BY column];<br></code></pre></td></tr></table></figure>

<blockquote>
<p>结论1：SELECT中出现的非组函数的字段必须声明在GROUP BY中。</p>
<p>​			反之，GROUP BY中声明的字段可以不出现在SELECT中。</p>
<p>结论2：GROUP BY声明在FROM后面、WHERE后面、ORDER BY前面、LIMIT前面。</p>
</blockquote>
<h3 id="2-使用WITH-ROLLUP"><a href="#2-使用WITH-ROLLUP" class="headerlink" title="2) 使用WITH ROLLUP"></a>2) 使用WITH ROLLUP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_id,AVG(salary)<br>FROM employees<br>WHERE department_id &gt; 80<br>GROUP BY department_id WITH ROLLUP;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意： 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p>
</blockquote>
<h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="1-基本使用-1"><a href="#1-基本使用-1" class="headerlink" title="1) 基本使用"></a>1) 基本使用</h3><p>过滤分组：HAVING子句 </p>
<ol>
<li>行已经被分组。 </li>
<li>使用了聚合函数。 </li>
<li>满足HAVING 子句中条件的分组将被显示。 </li>
<li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_id, MAX(salary)<br>FROM employees<br>GROUP BY department_id<br>HAVING MAX(salary)&gt;10000 ;<br></code></pre></td></tr></table></figure>

<p><strong>要求</strong></p>
<ul>
<li>如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE。否则，报错。</li>
<li>当过滤条件中没有聚合函数时，则次过滤条件声明在WHERE中或HAVING中都可以。但是，建议声明在WHERE中的执行效率高。</li>
<li>HAVING必须声明在GROUP BY 的后面</li>
<li>开发中，我们使用HAVING的前提是SQL中使用了GROUP BY。</li>
</ul>
<h3 id="2-WHERE和HAVING的对比"><a href="#2-WHERE和HAVING的对比" class="headerlink" title="2) WHERE和HAVING的对比"></a>2) WHERE和HAVING的对比</h3><p><strong>区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</strong></p>
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。</p>
<p><strong>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。</strong></p>
<p>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。</p>
<p>小结如下：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用法</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td>先筛选数据再关联，执行效率高</td>
<td>不能使用分组中的计算函数进行筛选</td>
</tr>
<tr>
<td>HAVING</td>
<td>可以使用分组中的计算函数</td>
<td>在最后的结果集中进行筛选，执行效率较低</td>
</tr>
</tbody></table>
<p><strong>开发中的选择：</strong> </p>
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组 统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发 挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很 大的差别。</p>
<h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><h3 id="1-查询的结构"><a href="#1-查询的结构" class="headerlink" title="1) 查询的结构"></a>1) 查询的结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式1：<br>SELECT ...,....,...<br>FROM ...,...,....<br>WHERE 多表的连接条件<br>AND 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br>#方式2：<br>SELECT ...,....,...<br>FROM ... JOIN ...<br>ON 多表的连接条件<br>JOIN ...<br>ON ...<br>WHERE 不包含组函数的过滤条件<br>AND/OR 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br>#其中：<br>#（1）from：从哪些表中筛选<br>#（2）on：关联多表查询时，去除笛卡尔积<br>#（3）where：从表中筛选的条件<br>#（4）group by：分组依据<br>#（5）having：在统计结果中再次筛选<br>#（6）order by：排序<br>#（7）limit：分页<br></code></pre></td></tr></table></figure>

<p><strong>需要记住 SELECT 查询时的两个顺序：</strong></p>
<p><font color=red>1. 关键字的顺序是不能颠倒的：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...<br></code></pre></td></tr></table></figure>

<p><font color=red>1. SELECT 语句的执行顺序</font>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT<br></code></pre></td></tr></table></figure>

<p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5<br>FROM player JOIN team ON player.team_id = team.team_id # 顺序 1<br>WHERE height &gt; 1.80 # 顺序 2<br>GROUP BY player.team_id # 顺序 3<br>HAVING num &gt; 2 # 顺序 4<br>ORDER BY num DESC # 顺序 6<br>LIMIT 2 # 顺序 7<br></code></pre></td></tr></table></figure>

<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步 骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h3 id="2-SQL的执行原理"><a href="#2-SQL的执行原理" class="headerlink" title="2) SQL的执行原理"></a>2) SQL的执行原理</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li>
<li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li>
</ol>
<ul>
<li><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。</p>
</li>
<li><p>然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。</p>
</li>
<li><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。</p>
</li>
<li><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。</p>
</li>
<li><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。</p>
</li>
<li><p>最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。</p>
</li>
<li><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p>
</li>
</ul>
<p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序，所谓底层运行的原理，就是我们刚才讲到的执行顺序。</p>
<h1 id="第九章-子查询"><a href="#第九章-子查询" class="headerlink" title="第九章_子查询"></a>第九章_子查询</h1><h2 id="1-基本使用-2"><a href="#1-基本使用-2" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><ul>
<li>子查询的基本语法结构：</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/zSjcqIdYKiOGE17.png" alt="image-20220603133759153"></p>
<ul>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用 。</li>
<li><strong>注意事项</strong><ul>
<li>子查询要包含在括号内</li>
<li>将子查询放在比较条件的右侧</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
</ul>
<h2 id="2-子查询的分类"><a href="#2-子查询的分类" class="headerlink" title="2. 子查询的分类"></a>2. 子查询的分类</h2><p><strong>分类方式1：</strong></p>
<p>我们按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询 。</p>
<ul>
<li>单行子查询</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/b74PGrIUlkxWDh3.png" alt="image-20220603135507360"></p>
<ul>
<li>多行子查询</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/MaFBVJypNZrv9we.png" alt="image-20220603135544144"></p>
<p><strong>分类方式2：</strong></p>
<p>我们按内查询是否被执行多次，将子查询划分为 相关(或关联)子查询 和 不相关(或非关联)子查询 。 </p>
<p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。 </p>
<p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p>
<h2 id="3-单行子查询"><a href="#3-单行子查询" class="headerlink" title="3. 单行子查询"></a>3. 单行子查询</h2><h3 id="1-单行比较操作符"><a href="#1-单行比较操作符" class="headerlink" title="1) 单行比较操作符"></a>1) 单行比较操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>equal to</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>greater than or equal to</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>less than or equal to</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal to</td>
</tr>
</tbody></table>
<h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2) 代码示例"></a>2) 代码示例</h3><ul>
<li>题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, job_id, salary<br>FROM eployees<br>WHERE job_id = (<br>	SELECT job_id<br>	FROM eployees<br>    WHERE employee_id = 141<br>)<br>AND salary &gt; (<br>	SELECT salary<br>	FROM eployees<br>    WHERE employee_id = 143<br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id， manager_id，department_id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 实现方式一：不成对比较<br>SELECT employee_id, manager_id, department_id<br>FROM employees<br>WHERE manager_id IN<br>        (SELECT manager_id<br>        FROM employees<br>        WHERE employee_id IN (174,141))<br>AND department_id IN<br>        (SELECT department_id<br>        FROM employees<br>        WHERE employee_id IN (174,141))<br>AND employee_id NOT IN(174,141);<br><br># 实现方式二：成对比较<br>SELECT employee_id, manager_id, department_id<br>FROM employees<br>WHERE (manager_id, department_id) IN<br>        (SELECT manager_id, department_id<br>        FROM employees<br>        WHERE employee_id IN (141,174))<br>AND employee_id NOT IN (141,174);<br></code></pre></td></tr></table></figure>

<ul>
<li>题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_id, MIN(salary)<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary) &gt;<br>            (SELECT MIN(salary)<br>            FROM employees<br>            WHERE department_id = 50);<br></code></pre></td></tr></table></figure>

<h3 id="3-CASE中的子查询"><a href="#3-CASE中的子查询" class="headerlink" title="3) CASE中的子查询"></a>3) CASE中的子查询</h3><p>题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name,<br>    (CASE department_id<br>    WHEN<br>        (SELECT department_id FROM departments<br>        WHERE location_id = 1800)<br>    THEN &#x27;Canada&#x27; ELSE &#x27;USA&#x27; END) location<br>FROM employees;<br></code></pre></td></tr></table></figure>

<h3 id="4-子查询中的空值问题"><a href="#4-子查询中的空值问题" class="headerlink" title="4) 子查询中的空值问题"></a>4) 子查询中的空值问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, job_id<br>FROM employees<br>WHERE job_id =<br>(SELECT job_id<br>FROM employees<br>WHERE last_name = &#x27;Haas&#x27;);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>子查询不返回任何行</p>
</blockquote>
<h3 id="5-非法使用子查询"><a href="#5-非法使用子查询" class="headerlink" title="5) 非法使用子查询"></a>5) 非法使用子查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name<br>FROM employees<br>WHERE salary =<br>(SELECT MIN(salary)<br>FROM employees<br>GROUP BY department_id);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>多行子查询使用单行比较符</p>
</blockquote>
<h2 id="4-多行子查询"><a href="#4-多行子查询" class="headerlink" title="4. 多行子查询"></a>4. 多行子查询</h2><ul>
<li>也称为集合比较子查询</li>
<li>内查询返回多行</li>
<li>使用多行比较操作符</li>
</ul>
<h3 id="1-多行比较操作符"><a href="#1-多行比较操作符" class="headerlink" title="1) 多行比较操作符"></a>1) 多行比较操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>等于列表中的任意一个</td>
</tr>
<tr>
<td>ANY</td>
<td>需要和单行比较操作符一起使用，和子查询返回的某一个值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>需要和单行比较操作符一起使用，和子查询返回的所有值比较</td>
</tr>
<tr>
<td>SOME</td>
<td>实际上是ANY的别名，作用相同，一般常使用ANY</td>
</tr>
</tbody></table>
<h3 id="2-代码示例-1"><a href="#2-代码示例-1" class="headerlink" title="2) 代码示例"></a>2) 代码示例</h3><ul>
<li>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, job_id, salary<br>FROM employees<br>WHERE job_id &lt;&gt; &#x27;IT_PROG&#x27; <br>AND salary &lt; ANY(<br>	SELECT salary<br>    FROM emplyees<br>    WHERE job_id = &#x27;IT_PROG&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>题目：查询平均工资最低的部门id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式1：<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary) = (<br>        SELECT MIN(avg_sal)<br>        FROM (<br>            SELECT AVG(salary) avg_sal<br>            FROM employees<br>            GROUP BY department_id<br>            ) dept_avg_sal<br>);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式2：<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary) &lt;= ALL (<br>        SELECT AVG(salary) avg_sal<br>        FROM employees<br>        GROUP BY department_id<br>);<br></code></pre></td></tr></table></figure>

<h3 id="3-空值问题"><a href="#3-空值问题" class="headerlink" title="3) 空值问题"></a>3) 空值问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name<br>FROM employees<br>WHERE employee_id NOT IN (<br>    SELECT manager_id<br>    FROM employees<br>    WHERE manager_id IS NOT NULL<br>);<br></code></pre></td></tr></table></figure>

<h2 id="5-相关子查询"><a href="#5-相关子查询" class="headerlink" title="5. 相关子查询"></a>5. 相关子查询</h2><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件 关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。 </p>
<p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<p><img src="https://s2.loli.net/2024/02/24/1gdiPzGnR8ylFO3.png" alt="image-20220603154919387"></p>
<p><img src="https://s2.loli.net/2024/02/24/kT1rxNJDZpaColQ.png" alt="image-20220603155013864"></p>
<blockquote>
<p>说明：子查询中使用主查询中的列</p>
</blockquote>
<h3 id="1-代码示例"><a href="#1-代码示例" class="headerlink" title="1) 代码示例"></a>1) 代码示例</h3><ul>
<li>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式一：使用相关子查询<br>SELECT last_name, salary, department<br>FROM employees e1<br>WHERE salary &gt; (<br>		SELECT AVG(salary)<br>    	FROM employees e2<br>    	WHERE department_id = e1.`department_id`<br>);<br># 方式二：在FROM中声明子查询<br>SELECT e.last_name, e.salary, e.department_id<br>FROM employees e, (<br>    			SELECT department_id, AVG(salary) avg_sal<br>    			FROM employees<br>    			GROUP BY department_id) t_dept_avg_salary<br>WHERE e.department_id = t_dept_avg_salary.department_id<br>AND e.salary &gt; t_dept_avg_salary.avg_sal;<br></code></pre></td></tr></table></figure>

<p>在ORDER BY 中使用子查询：</p>
<ul>
<li>查询员工的id,salary,按照department_name 排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, salary<br>FROM employees e<br>ORDER BY (<br>	SELECT department_name<br>    FROM departments d<br>    WHERE e.`department_id` = d.`department_id`<br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同 id的员工的employee_id,last_name和其job_id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT e.employee_id, last_name,e.job_id<br>FROM employees e<br>WHERE 2 &lt;= (SELECT COUNT(*)<br>        FROM job_history<br>        WHERE employee_id = e.employee_id<br>);<br></code></pre></td></tr></table></figure>

<h3 id="2-EXISTS-与-NOT-EXISTS-关键字"><a href="#2-EXISTS-与-NOT-EXISTS-关键字" class="headerlink" title="2) EXISTS 与 NOT EXISTS 关键字"></a>2) EXISTS 与 NOT EXISTS 关键字</h3><ul>
<li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li>
<li>如果在子查询中不存在满足条件的行：<ul>
<li>条件返回 FALSE</li>
<li>继续在子查询中查找</li>
</ul>
</li>
<li>如果在子查询中存在满足条件的行：<ul>
<li>不在子查询中继续查找</li>
<li>条件返回 TRUE</li>
</ul>
</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li>
</ul>
<p>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式一：EXISTS<br>SELECT employee_id, last_name, job_id, department_id<br>FROM employees e1<br>WHERE EXISTS ( SELECT *<br>        FROM employees e2<br>        WHERE e2.manager_id =<br>        e1.employee_id<br>);<br><br># 方式二：自连接<br>SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_id<br>FROM employees e1 JOIN employees e2<br>ON e1.employee_id = e2.manager_id;<br><br># 方式三：IN<br>SELECT employee_id, last_name, job_id, department_id<br>WHERE employee_id IN (<br>        SELECT DISTINCT manager_id<br>        FROM employees<br>);<br></code></pre></td></tr></table></figure>

<p>题目：查询departments表中，不存在于employees表中的部门的department_id和department_name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式一：<br>SELECT d.department_id, d.department_name<br>FROM departments e RIGHT JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`department_id` IS NULL;<br><br># 方式二：<br>SELECT department_id, department_name<br>FROM departments d<br>WHERE NOT EXISTS (<br>	SELECT *<br>    FROM employees e<br>    WHERE d.`department_id` = e.`department_id`<br>);<br></code></pre></td></tr></table></figure>

<h3 id="3-相关更新"><a href="#3-相关更新" class="headerlink" title="3) 相关更新"></a>3) 相关更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UPDATE table1 alias1<br>SET column = (SELECT expression<br>FROM table2 alias2<br>WHERE alias1.column = alias2.column);<br></code></pre></td></tr></table></figure>

<p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p>
<p>题目：在employees中增加一个department_name字段，数据为员工对应的部门名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 1）<br>ALTER TABLE employees<br>ADD(department_name VARCHAR2(14));<br><br># 2）<br>UPDATE employees e<br>SET department_name = (SELECT department_name<br>FROM departments d<br>WHERE e.department_id = d.department_id);<br></code></pre></td></tr></table></figure>

<h3 id="4-相关删除"><a href="#4-相关删除" class="headerlink" title="4) 相关删除"></a>4) 相关删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELETE FROM table1 alias1<br>WHERE column operator (SELECT expression<br>FROM table2 alias2<br>WHERE alias1.column = alias2.column);<br></code></pre></td></tr></table></figure>

<p>使用相关子查询依据一个表中的数据删除另一个表的数据。</p>
<p>题目：删除表employees中，其与emp_history表皆有的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELETE FROM employees e<br>WHERE employee_id in(<br>    SELECT employee_id<br>    FROM emp_history<br>    WHERE employee_id = e.employee_id<br>);<br></code></pre></td></tr></table></figure>

<h2 id="6-思考题"><a href="#6-思考题" class="headerlink" title="6. 思考题"></a>6. 思考题</h2><p>问题：谁的工资比Abel的高？ 解答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式1：自连接<br>SELECT e2.last_name,e2.salary<br>FROM employees e1,employees e2<br>WHERE e1.last_name = &#x27;Abel&#x27;<br>AND e1.`salary` &lt; e2.`salary`;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式2：子查询<br>SELECT last_name,salary<br>FROM employees<br>WHERE salary &gt; (<br>    SELECT salary<br>    FROM employees<br>    WHERE last_name = &#x27;Abel&#x27;<br>);<br></code></pre></td></tr></table></figure>

<p>问题：以上两种方式有好坏之分吗？ </p>
<p>解答：自连接方式好！ </p>
<p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过 程中，对于自连接的处理速度要比子查询快得多。 可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表 进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h2 id="7-课后练习"><a href="#7-课后练习" class="headerlink" title="7. 课后练习"></a>7. 课后练习</h2><ol>
<li>查询和Zlotkey相同部门的员工姓名和工资</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, salary<br>FROM employees<br>WHERE department_id = (<br>	SELECT department_id<br>    FROM employees<br>    WHERE last_name = &#x27;Zlotkey&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>查询工资比公司平均工资高的员工的员工号，姓名和工资。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, salary<br>FROM employees<br>WHERE salary &gt; (<br>	SELECT AVG(salary)<br>    FROM employee<br>);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>选择工资大于所有JOB_ID &#x3D; ‘SA_MAN’ 的员工的工资的员工的last_name, job_id, salary</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, job_id, salary<br>FROM employees<br>WHERE salary &gt; ALL (<br>	SELECT salary<br>    FROM employees<br>    WHERE job_id = &#x27;SA_MAN&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name<br>FROM eployees<br>WHERE department_id IN (<br>    SELECT DISTINCT department_id<br>    FROM employees<br>    WHERE last_name LIKE &#x27;%u%&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>查询在部门的location_id为1700的部门工作的员工的员工号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id<br>FROM employees<br>WHERE department_id IN (<br>	SELECT department_id<br>    FROM departments<br>    WHERE location_id = 1700<br>);<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>查询管理者是King的员工姓名和工资</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, salary<br>FROM employees<br>WHERE manage_id IN (<br>	SELECT employee_id<br>    FROM employees<br>    WHERE last_name = &#x27;King&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>查询工资最低的员工信息 (last_name, salary)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, salary<br>FROM employees<br>WHERE salary = (<br>	SELECT MIN(salary)<br>    FROM employees<br>);<br></code></pre></td></tr></table></figure>

<ol start="8">
<li>查询平均工资最低的部门信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式一<br>SELECT *<br>FROM departments<br>WHERE department_id = (<br>	SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    HAVING AVG(salary) = (<br>    	SELECT MIN(avg_sal)<br>        FROM (<br>        	SELECT AVG(salary) avg_sal<br>            FROM employees<br>            GROUP BY department_id<br>        ) t_dept_avg_sal<br>    )<br>);<br><br># 方式二<br>SELECT *<br>FROM departments<br>WHERE department_id = (<br>	SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    HAVING AVG(salary) &lt;= ALL (<br>        SELECT AVG(salary) avg_sal<br>        FROM employees<br>        GROUP BY department_id<br>    )<br>);<br><br># 方式三: LIMIT<br>SELECT *<br>FROM departments<br>WHERE department_id IN (<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    HAVING AVG(salary) = (<br>    	SELECT AVG(salary) avg_sal<br>        FROM employees<br>        GROUP BY department_id<br>        ORDER BY avg_sal ASC<br>        LIMIT 1<br>    )<br>);<br><br># 方式四<br>SELECT d.*<br>FROM departments d, (<br>	SELECT department_id, AVG(salary) avg_sal<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY avg_sal ASC<br>    LIMIT 0,1<br>) t_dept_avg_sal<br>WHERE d.`department_id` = t_dept_avg_sal.`department_id`;<br></code></pre></td></tr></table></figure>

<ol start="9">
<li>查询平均工资最低的部门信息和该部门的平均工资 (相关子查询)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT d.*, (SELECT AVG(salary) FROM employees WHERE department_id = d.`department_id`) avg_sal<br>FROM departments d, (<br>	SELECT department_id, AVG(salary) avg_sal<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY avg_sal ASC<br>    LIMIT 0,1<br>) t_dept_avg_sal<br>WHERE d.`department_id` = t_dept_avg_sal.`department_id`;<br></code></pre></td></tr></table></figure>

<ol start="10">
<li>查询平均工资最高的job信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM jobs<br>WHERE job_id = (<br>	SELECT job_id<br>    FROM employees<br>    GROUP BY job_id<br>    HAVING AVG(salary) = (<br>    	SELECT MAX(avg_sal)<br>        FROM (<br>        	SELECT AVG(salary) avg_sal<br>            FROM employees<br>            GROUP BY job_id<br>        ) t_job_avg_sal<br>    )<br>);<br></code></pre></td></tr></table></figure>

<ol start="11">
<li>查询平均工资高于公司平均工资的部门有哪些？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT depatment_id<br>FROM employees<br>WHERE department_id IS NOT NULL<br>GROUP BY department_id<br>HAVING AVG(salary) &gt; (<br>	SELECT AVG(salary)<br>    FROM eployees<br>);<br></code></pre></td></tr></table></figure>

<ol start="12">
<li>查询出公司中所有manager的详细信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式1：自连接<br>SELECT DISTINCT *<br>FROM employees emp, employees manager<br>WHERE emp.`manager_id` = manager.`employee_id`;<br><br>SELECT DISTINCT *<br>FROM employees emp JOIN employees manager<br>ON emp.`manager_id` = manager.`employee_id`; <br><br># 方式2：子查询<br>SELECT *<br>FROM employees<br>WHERE employee_id IN (<br>	SELECT manager_id<br>    FROM employees<br>);<br><br># 方式3：EXISTS<br>SELECT *<br>FROM employees manager<br>WHERE EXISTS (<br>	SELECT *<br>    FROM employees emp<br>    WHERE manager.`employee_id` = emp.`manager_id`<br>);<br></code></pre></td></tr></table></figure>

<ol start="13">
<li>各个部门中，最高工资中最低的那个部门的最低工资是多少？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式一：<br>SELECT MIN(salary)<br>FROM employees<br>WHERE department_id = (<br>    SELECT department_id<br>    FROM employees<br>	GROUP BY department_id<br>	HAVING MAX(salary) = (<br>    	SELECT MIN(max_sal)<br>        FROM (<br>        	SELECT MAX(salary) max_sal<br>            FROM employees<br>            GROUP BY department_id<br>        ) t_dept_max_sal<br>    ) <br>);<br><br># 方式二：<br>SELECT MIN(salary)<br>FROM employees<br>WHERE department_id = (<br>    SELECT department_id<br>    FROM employees<br>	GROUP BY department_id<br>	HAVING MAX(salary) &lt;= ALL (<br>        SELECT MAX(salary)<br>        FROM employees<br>        GROUP BY department_id<br>    ) <br>);<br><br># 方式三：<br>SELECT MIN(salary)<br>FROM employees<br>WHERE department_id = (<br>    SELECT department_id<br>    FROM employees<br>	GROUP BY department_id<br>	HAVING MAX(salary) = (<br>        SELECT MAX(salary) max_sal<br>        FROM employees<br>        GROUP BY department_id<br>        ORDER BY max_sal ASC<br>        LIMIT 0,1<br>    ) <br>);<br><br># 方式四：<br>FROM employees e, (<br>	SELECT department_id, MAX(salary) max_sal<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY max_sal ASC<br>    LIMIT 0,1<br>) t_dept_max_sal<br>WHERE e.`department_id` = t_dept_max_sal.`department_id`;<br></code></pre></td></tr></table></figure>

<ol start="14">
<li>查询平均工资最高的部门的manager的详细信息：last_name, department_id, email, salary</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name, department_id, email, salary<br>FROM employees<br>WHERE employee_id IN (<br>	SELECT DISTINCT manager_id<br>    FROM employees<br>    WHERE department_id = (<br>    	SELECT department_id<br>        FROM employees<br>        GROUP BY department_id<br>        HAVING AVG(salary) = (<br>        	SELECT MAX(avg_sal)<br>            FROM (<br>            	SELECT AVG(salary) avg_sal<br>                FROM employees<br>                GROUP BY department_id<br>            ) t_dept_avg_sal<br>        )<br>    )<br>);<br><br>SELECT last_name, department_id, email, salary<br>FROM employees<br>WHERE employee_id IN (<br>    SELECT DISTINCT manager_id<br>    FROM employees e, (<br>        SELECT department_id, AVG(salary) avg_sal<br>        FROM employees<br>        GROUP BY department_id<br>        ORDER BY avg_sal DESC<br>        LIMIT 0,1<br>    ) t_dept_avg_sal<br>    WHERE e.`department_id` = t_dept_avg_sal.`department_id`<br>);<br></code></pre></td></tr></table></figure>

<ol start="15">
<li>查询部门的部门号，其中不包括job_id是”ST_CLERK”的部门号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_id<br>FROM departments<br>WHERE department_id NOT IN (<br>	SELECT DISTINCT department_id<br>    FROM employees<br>    WHERE job_id = `ST_CLERK`<br>);<br><br>SELECT department_id<br>FROM department d<br>WHERE NOT EXISTS (<br>	SELECT *<br>    FROM employees e<br>    WHERE d.`department_id` = e.`department_id`<br>    AND e.`job_id` = &#x27;ST_CLERK&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ol start="16">
<li>选择所有没有管理者的员工的last_name</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT last_name<br>FROM employees emp<br>WHERE NOT EXISTS (<br>	SELECT *<br>    FROM employees mgr<br>    WHERE emp.`manager_id` = mgr.`employee_id`<br>);<br></code></pre></td></tr></table></figure>

<ol start="17">
<li>查询员工号、姓名、雇用时间、工资，其中员工的管理者为 ‘De Haan’</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT employee_id, last_name, hire_date, salary<br>FROM employee<br>WHERE manager_id IN (<br>	SELECT manager_id<br>    FROM employee<br>    WHERE last_name = &#x27;De Haan&#x27;<br>);<br></code></pre></td></tr></table></figure>

<ol start="18">
<li>查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资（相关子查询）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_id, last_name, salary<br>FROM employees e1<br>WHERE salary &gt; (<br>	SELECT AVG(salary)<br>    FROM employees e2<br>    WHERE e2.`department_id` = e1.`department_id`<br>);<br><br>SELECT e.last_name, e.salary, e.department_id<br>FROM employees e, (<br>	SELECT department_id, AVG(salary) avg_sal<br>    FROM employees<br>    GROUP BY department_id<br>) t_dept_avg_sal<br>WHERE e.`department_id` = t_dept_avg_sal.`department_id`<br>AND e.`salary` &gt; t_dept_avg_sal.`avg_sal`;<br></code></pre></td></tr></table></figure>

<ol start="19">
<li>查询每个部门下的部门人数大于5的部门名称（相关子查询）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT department_name<br>FROM departments d<br>WHERE 5 &lt; (<br>	SELECT COUNT(*)<br>    FROM employees e<br>    WHERE d.`department_id` = e.`department_id`<br>);<br></code></pre></td></tr></table></figure>

<ol start="20">
<li>查询每个国家下的部门个数大于2的国家编号（相关子查询）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT country_id<br>FROM locations l<br>WHERE 2 &lt; (<br>	SELECT COUNT(*)<br>    FROM department d<br>    WHERE l.`location_id` = d.`location_id`<br>);<br></code></pre></td></tr></table></figure>

<h1 id="第十章-创建和管理表"><a href="#第十章-创建和管理表" class="headerlink" title="第十章_创建和管理表"></a>第十章_创建和管理表</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-标识符命名规则"><a href="#1-标识符命名规则" class="headerlink" title="1) 标识符命名规则"></a>1) 标识符命名规则</h3><ul>
<li>数据库名、表名不得超过30个字符，变量名限制为29个 </li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符 </li>
<li>数据库名、表名、字段名等对象名中间不要包含空格 </li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 </li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用&#96;（着重号）引起来 </li>
<li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h3 id="2-MySQL中的数据类型"><a href="#2-MySQL中的数据类型" class="headerlink" title="2) MySQL中的数据类型"></a>2) MySQL中的数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>数据变量</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类型</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值：GEOMETRY、POINT、LINESTRING、POLYGON； 集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<p>其中，常用的几类类型介绍如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>从-2^31到2^31-1的整型数据。存储大小为 4个字节</td>
</tr>
<tr>
<td>CHAR(size)</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>FLOAT(M,D)</td>
<td>BIT</td>
</tr>
<tr>
<td>DOUBLE(M,D)</td>
<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>DATE</td>
<td>ENUM</td>
</tr>
<tr>
<td>BLOB</td>
<td>SET</td>
</tr>
<tr>
<td>TEXT</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
</tbody></table>
<h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1) 创建数据库"></a>1) 创建数据库</h3><ul>
<li><p>方式1：创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式2：创建数据库并指定字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名 CHARACTER SET 字符集;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式3：判断数据库是否已经存在，不存在则创建数据库（ 推荐 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS 数据库名;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p>
<blockquote>
<p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删 旧库完成的。</p>
</blockquote>
<h3 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2) 使用数据库"></a>2) 使用数据库</h3><ul>
<li><p>查看当前所有的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW DATABASES; #有一个S，代表多个数据库<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看当前正在使用的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT DATABASE(); #使用的一个 mysql 中的全局函数<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看指定库下所有的表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW TABLES FROM 数据库名<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看数据库的创建信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW CREATE DATABASE 数据库名;<br>或者：<br>SHOW CREATE DATABASE 数据库名\G<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用&#x2F;切换数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">USE 数据库名;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数 据库名.”。</p>
</blockquote>
<h3 id="3-修改数据库"><a href="#3-修改数据库" class="headerlink" title="3) 修改数据库"></a>3) 修改数据库</h3><ul>
<li><p>更改数据库字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式1：删除指定的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP DATABASE 数据库名;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式2：删除指定的数据库（ 推荐 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP DATABASE IF EXISTS 数据库名;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><h3 id="1-创建方式1"><a href="#1-创建方式1" class="headerlink" title="1) 创建方式1"></a>1) 创建方式1</h3><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名(<br>字段1, 数据类型 [约束条件] [默认值],<br>字段2, 数据类型 [约束条件] [默认值],<br>字段3, 数据类型 [约束条件] [默认值],<br>……<br>[表约束条件]<br>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表； 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p>
</blockquote>
<h3 id="2-创建方式2"><a href="#2-创建方式2" class="headerlink" title="2) 创建方式2"></a>2) 创建方式2</h3><ul>
<li>使用 AS subquery 选项，将创建表和插入数据结合起来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名<br>	[(column, column, ...)]<br>AS subquery;<br></code></pre></td></tr></table></figure>

<ul>
<li>指定的列和子查询中的列要一一对应</li>
<li>通过列名和默认值定义列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE dept80<br>AS<br>SELECT employee_id, last_name, salary*12 ANNSAL, hire_date<br>FROM employees<br>WHERE department_id = 80;<br></code></pre></td></tr></table></figure>

<h3 id="3-查看数据表结构"><a href="#3-查看数据表结构" class="headerlink" title="3) 查看数据表结构"></a>3) 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用 DESCRIBE&#x2F;DESC 语句查看数据 表结构，也支持使用 SHOW CREATE TABLE 语句查看数据表结构。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW CREATE TABLE 表名\G<br></code></pre></td></tr></table></figure>

<p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。</p>
<p>使用 ALTER TABLE 语句可以实现：</p>
<ul>
<li>向已有的表中添加列</li>
<li>修改现有表中的列</li>
<li>删除现有表中的列</li>
<li>重命名现有表中的列</li>
</ul>
<h3 id="1-追加一个列"><a href="#1-追加一个列" class="headerlink" title="1) 追加一个列"></a>1) 追加一个列</h3><p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;<br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE dept80<br>ADD job_id varchar(15);<br></code></pre></td></tr></table></figure>

<h3 id="2-修改一个列"><a href="#2-修改一个列" class="headerlink" title="2) 修改一个列"></a>2) 修改一个列</h3><ul>
<li>可以修改列的数据类型，长度、默认值和位置 </li>
<li>修改字段数据类型、长度、默认值、位置的语法格式如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;<br></code></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE dept80<br>MODIFY salary double(9,2) default 1000;<br></code></pre></td></tr></table></figure>

<ul>
<li>对默认值的修改只影响今后对表的修改</li>
<li>此外，还可以通过此种方式修改列的约束。</li>
</ul>
<h3 id="3-重命名一个列"><a href="#3-重命名一个列" class="headerlink" title="3) 重命名一个列"></a>3) 重命名一个列</h3><p>使用 CHANGE old_column new_column dataType子句重命名列。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;<br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE dept80<br>CHANGE department_name dept_name varchar(15);<br></code></pre></td></tr></table></figure>

<h3 id="4-删除一个列"><a href="#4-删除一个列" class="headerlink" title="4) 删除一个列"></a>4) 删除一个列</h3><p>删除表中某个字段的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP 【COLUMN】字段名<br></code></pre></td></tr></table></figure>

<h3 id="5-更改表名"><a href="#5-更改表名" class="headerlink" title="5) 更改表名"></a>5) 更改表名</h3><ul>
<li>方式一：使用RENAME</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">RENAME TABLE emp<br>TO myemp;<br></code></pre></td></tr></table></figure>

<ul>
<li>方式二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER table dept<br>RENAME [TO] detail_dept; -- [TO]可以省略<br></code></pre></td></tr></table></figure>

<ul>
<li>必须是对象的拥有者</li>
</ul>
<h2 id="5-删除表"><a href="#5-删除表" class="headerlink" title="5. 删除表"></a>5. 删除表</h2><ul>
<li>在MySQL中，当一张数据表 没有与其他任何数据表形成关联关系 时，可以将当前数据表直接删除。 </li>
<li>数据和结构都被删除 </li>
<li>所有正在运行的相关事务被提交 </li>
<li>所有相关索引被删除 </li>
<li>语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];<br></code></pre></td></tr></table></figure>

<p>IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存 在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP TABLE dept80;<br></code></pre></td></tr></table></figure>

<ul>
<li>DROP TABLE 语句不能回滚</li>
</ul>
<h2 id="6-清空表"><a href="#6-清空表" class="headerlink" title="6. 清空表"></a>6. 清空表</h2><ul>
<li>TRUNCATE TABLE语句：<ul>
<li>删除表中所有的数据</li>
<li>释放表的存储空间</li>
</ul>
</li>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">TRUNCATE TABLE detail_dept;<br></code></pre></td></tr></table></figure>

<ul>
<li>TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚</li>
</ul>
<blockquote>
<p>阿里开发规范： 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
</blockquote>
<h2 id="7-内容扩展"><a href="#7-内容扩展" class="headerlink" title="7. 内容扩展"></a>7. 内容扩展</h2><h3 id="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展1：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"></a>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</h3><ul>
<li><p>【 强制 】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出 现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<ul>
<li>正例：aliyun_admin，rdc_config，level3_name</li>
<li>反例：AliyunAdmin，rdcConfig，level_3_name</li>
</ul>
</li>
<li><p>【 强制 】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li><p>【 强制 】表必备三字段：id, gmt_create, gmt_modified。</p>
<ul>
<li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被 动式更新</li>
</ul>
</li>
<li><p>【 推荐 】表的命名最好是遵循 “业务名称_表的作用”。</p>
<ul>
<li>正例：alipay_task 、 force_project、 trade_config</li>
</ul>
</li>
<li><p>【 推荐 】库名与应用名称尽量一致。</p>
</li>
<li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>
<ul>
<li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li>
</ul>
</li>
</ul>
<h3 id="扩展2：操作注意要求"><a href="#扩展2：操作注意要求" class="headerlink" title="扩展2：操作注意要求"></a>扩展2：操作注意要求</h3><ul>
<li>表删除 操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信 息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行 备份 ，这样当操作失误时可 以对数据进行恢复，以免造成无法挽回的后果。</li>
<li>同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进 行完整的 备份 ，因为数据库的改变是 无法撤销 的，如果添加了一个不需要的字段，可以将其删除；相 同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</li>
</ul>
<h3 id="扩展3：MySQL8新特性—DDL的原子化"><a href="#扩展3：MySQL8新特性—DDL的原子化" class="headerlink" title="扩展3：MySQL8新特性—DDL的原子化"></a>扩展3：MySQL8新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即 DDL操作要么成功要么回滚 。DDL操作回滚日志 写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到） 中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p>
<h1 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章_数据处理之增删改"></a>第11章_数据处理之增删改</h1><h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-方式1：VALUES的方式添加"><a href="#1-方式1：VALUES的方式添加" class="headerlink" title="1) 方式1：VALUES的方式添加"></a>1) 方式1：VALUES的方式添加</h3><p>使用这种语法一次只能向表中插入一条数据。</p>
<p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名<br>VALUES (value1,value2,....);<br></code></pre></td></tr></table></figure>

<p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO departments<br>VALUES (70, &#x27;Pub&#x27;, 100, 1700);<br></code></pre></td></tr></table></figure>

<p><strong>情况2: 指定字段名插入数据</strong></p>
<p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的 默认值。 在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与 column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。 </p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO departments(department_id, department_name)<br>VALUES (80, &#x27;IT&#x27;);<br></code></pre></td></tr></table></figure>

<p><strong>情况3：同时插入多条记录</strong></p>
<p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔 开，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO table_name<br>VALUES<br>(value1 [,value2, …, valuen]),<br>(value1 [,value2, …, valuen]),<br>……<br>(value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO table_name(column1 [, column2, …, columnn])<br>VALUES<br>(value1 [,value2, …, valuen]),<br>(value1 [,value2, …, valuen]),<br>……<br>(value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure>

<p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含 义如下：</p>
<ul>
<li>Records：表明插入的记录条数。 </li>
<li>Duplicates：表明插入时被忽略的记录，原因可能是这 些记录包含了重复的主键值。 </li>
<li>Warnings：表明有问题的数据值，例如发生数据类型转换。</li>
</ul>
<blockquote>
<p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句 在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句 快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p>
</blockquote>
<h3 id="2-方式2：将查询结果插入到表中"><a href="#2-方式2：将查询结果插入到表中" class="headerlink" title="2) 方式2：将查询结果插入到表中"></a>2) 方式2：将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSET INTO 目标表名<br>(tar_column1 [, tar_column2, ..., tar_columnn])<br>SELECT<br>(src_column1 [, src_column2, …, src_columnn])<br>FROM 源表名<br>[WHERE condition]<br></code></pre></td></tr></table></figure>

<ul>
<li>在 INSERT 语句中加入子查询。 </li>
<li>不必书写 VALUES 子句。 </li>
<li>子查询中的值列表应与 INSERT 子句中的列名对应。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO emp2<br>SELECT *<br>FROM employees<br>WHERE department_id = 90;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO sales_reps(id, name, salary, commission_pct)<br>SELECT employee_id, last_name, salary, commission_pct<br>FROM employees<br>WHERE job_id LIKE &#x27;%REP%&#x27;;<br></code></pre></td></tr></table></figure>

<h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><ul>
<li>使用 UPDATE 语句更新数据。语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UPDATE table_name<br>SET column1=value1, column2=value2, ..., column=valuen<br>[WHERE condition]<br></code></pre></td></tr></table></figure>

<ul>
<li><p>可以一次更新多条数据。</p>
</li>
<li><p>如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT &#x3D; FALSE;</p>
</li>
<li><p>使用 WHERE 子句指定需要更新的数据。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UPDATE employees<br>SET department_id = 70<br>WHERE employee_id = 113;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果省略 WHERE 子句，则表中的所有数据都将被更新。</li>
</ul>
<h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name [WHERE &lt;condition&gt;];<br></code></pre></td></tr></table></figure>

<p>table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句， DELETE语句将删除表中的所有记录。</p>
<h2 id="4-MySQL8新特性：计算列"><a href="#4-MySQL8新特性：计算列" class="headerlink" title="4. MySQL8新特性：计算列"></a>4. MySQL8新特性：计算列</h2><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列 不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p>
<p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p>
<p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的 值。 首先创建测试表tb1，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE tb1(<br>id INT,<br>a INT,<br>b INT,<br>c INT GENERATED ALWAYS AS (a + b) VIRTUAL<br>);<br></code></pre></td></tr></table></figure>

<h1 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章_MySQL数据类型精讲"></a>第12章_MySQL数据类型精讲</h1><h2 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a>1. MySQL中的数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类型</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； 集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<p>常见数据类型的属性，如下：</p>
<table>
<thead>
<tr>
<th>MySQL关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>BIT</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>UNSIGNED</td>
<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>CHARACTER SET name</td>
<td>ENUM</td>
</tr>
</tbody></table>
<h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h2><h3 id="1-类型介绍"><a href="#1-类型介绍" class="headerlink" title="1) 类型介绍"></a>1) 类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。 </p>
<p>它们的区别如下表所示：</p>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>字节</th>
<th>有符号数取值范围</th>
<th>无符号数取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>-128~127</td>
<td>0~255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768~32767</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608~8388607</td>
<td>0~16777215</td>
</tr>
<tr>
<td>INT、INTEGER</td>
<td>4</td>
<td>-2147483648~2147483647</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808~9223372036854775807</td>
<td>0~18446744073709551615</td>
</tr>
</tbody></table>
<h3 id="2-可选属性"><a href="#2-可选属性" class="headerlink" title="2) 可选属性"></a>2) 可选属性</h3><p>整数类型的可选属性有三个：</p>
<ul>
<li>M</li>
</ul>
<p>M : 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合“ ZEROFILL ”使用，表示用“0”填满宽度，否则指定显示宽度无效。 如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？ </p>
<p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 显示宽度与类型可以存储的 值范围无关 。从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。 整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认 的宽度值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_int1 ( x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT );<br></code></pre></td></tr></table></figure>

<p>查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; desc test_int1;<br>+-------+--------------+------+-----+---------+-------+<br>| Field | Type | Null | Key | Default | Extra |<br>+-------+--------------+------+-----+---------+-------+<br>| x | tinyint(4) | YES | | NULL | |<br>| y | smallint(6) | YES | | NULL | |<br>| z | mediumint(9) | YES | | NULL | |<br>| m | int(11) | YES | | NULL | |<br>| n | bigint(20) | YES | | NULL | |<br>+-------+--------------+------+-----+---------+-------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>TINYINT有符号数和无符号数的取值范围分别为-128~127和0~255，由于负号占了一个数字位，因此 TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。</p>
<ul>
<li>UNSIGNED</li>
</ul>
<p>UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设 置为无符号类型。 int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p>
<ul>
<li>ZEROFILL</li>
</ul>
<p>ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指 定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。 </p>
<p>原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都 是占用 4 bytes 的存储空间。也就是说，int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。如果整 数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p>
<h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3) 适用场景"></a>3) 适用场景</h3><p>TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。 </p>
<p>SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。 </p>
<p>MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。 </p>
<p>INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。 </p>
<p>BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证 券公司衍生产品持仓等。</p>
<h3 id="4-如何选择？"><a href="#4-如何选择？" class="headerlink" title="4) 如何选择？"></a>4) 如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑 存储空间 和 可靠性 的平衡问题：一方 面，用占用字节数少 的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一 旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。 </p>
<p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每 天都有旧商品下架，新商品上架，这样不断迭代，日积月累。 </p>
<p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。 </p>
<p>你要注意的是，在实际工作中，系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因 此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p>
<h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a>3. 浮点类型</h2><h3 id="1-类型介绍-1"><a href="#1-类型介绍-1" class="headerlink" title="1) 类型介绍"></a>1) 类型介绍</h3><p>浮点数和定点数类型的特点是可以 处理小数 ，你可以把整数看成小数的一个特例。因此，浮点数和定点 数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p>
<ul>
<li><p>FLOAT 表示单精度浮点数； </p>
</li>
<li><p>DOUBLE 表示双精度浮点数；</p>
</li>
<li><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET sql_mode = “REAL_AS_FLOAT”;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>问题：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于 有符号数取值范围大于等于零的部分呢？</strong></p>
<p>MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮 点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于 零的部分。</p>
<h3 id="2-数据精度说明"><a href="#2-数据精度说明" class="headerlink" title="2) 数据精度说明"></a>2) 数据精度说明</h3><p>对于浮点类型，在MySQL中单精度值使用 4 个字节，双精度值使用 8 个字节。</p>
<ul>
<li><p>MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里，M称为 精度 ，D称为 标度 。(M,D)中 M&#x3D;整数位+小数 位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D;255，0&lt;&#x3D;D&lt;&#x3D;30。 </p>
<p>例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</p>
</li>
<li><p>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示。</p>
</li>
<li><p>说明：浮点类型，也可以加 UNSIGNED ，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围。</p>
</li>
<li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p>
<ul>
<li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li>
<li>如果存储时，小数点部分若超出范围，就分以下情况：<ul>
<li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li>
<li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。</li>
</ul>
</li>
</ul>
</li>
<li><p>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可 能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p>
</li>
</ul>
<h3 id="3-精度误差说明"><a href="#3-精度误差说明" class="headerlink" title="3) 精度误差说明"></a>3) 精度误差说明</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我 们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 &#x3D; 1.1。而使用sum之后查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_double2(<br>f1 DOUBLE<br>);<br>INSERT INTO test_double2<br>VALUES(0.47),(0.44),(0.19);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT SUM(f1)<br>-&gt; FROM test_double2;<br>+--------------------+<br>| SUM(f1) |<br>+--------------------+<br>| 1.0999999999999999 |<br>+--------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型 改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p>
<p>那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。</p>
<p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如 果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。</p>
<p>在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“&#x3D;”来 判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数 类型： DECIMAL 。</p>
<h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h2><h3 id="1-类型介绍-2"><a href="#1-类型介绍-2" class="headerlink" title="1) 类型介绍"></a>1) 类型介绍</h3><ul>
<li>MySQL中的定点数类型只有 DECIMAL 一种类型。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>有符号数取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>DECIMAL(M,D),DEC,NUMERIC</td>
<td>M+2字节</td>
<td>有效范围由M和D决定</td>
</tr>
</tbody></table>
<p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;&#x3D;M&lt;&#x3D;65， 0&lt;&#x3D;D&lt;&#x3D;30，D</p>
<ul>
<li>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是 说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可 以更大一些。</li>
<li>定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。</li>
<li>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的 精度范围时，则MySQL同样会进行四舍五入处理。</li>
<li>浮点数 vs 定点数<ul>
<li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用 于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动 力学等）</li>
<li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉 及金额计算的场景）</li>
</ul>
</li>
</ul>
<h3 id="2-开发中的经验"><a href="#2-开发中的经验" class="headerlink" title="2) 开发中的经验"></a>2) 开发中的经验</h3><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型 外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能 差。 ” ——来自某项目经理</p>
<h2 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a>5. 位类型：BIT</h2><p>BIT类型中存储的是二进制值，类似010110。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>M</td>
<td>1 &lt;&#x3D; M &lt;&#x3D; 64</td>
<td>约为(M + 7)&#x2F;8个字节</td>
</tr>
</tbody></table>
<p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的 位数，位数最小值为1，最大值为64。</p>
<h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6. 日期与时间类型"></a>6. 日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的 时间标签，从而进行数据查询、统计和处理。</p>
<p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间 类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p>
<ul>
<li>YEAR 类型通常用来表示年 </li>
<li>DATE 类型通常用来表示年、月、日 </li>
<li>TIME 类型通常用来表示时、分、秒 </li>
<li>DATETIME 类型通常用来表示年、月、日、时、分、秒 </li>
<li>TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>字节</th>
<th>日期格式</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
<td>1</td>
<td>YYYY或YY</td>
<td>1901</td>
<td>2155</td>
</tr>
<tr>
<td>TIME</td>
<td>时间</td>
<td>3</td>
<td>HH:MM:SS</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>日期</td>
<td>3</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01</td>
<td>9999-12-03</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期时间</td>
<td>8</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>日期时间</td>
<td>4</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:00 UTC</td>
<td>2038-01-19 03:14:07UTC</td>
</tr>
</tbody></table>
<p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据 实际需要灵活选取。</p>
<p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表 示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p>
<h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a>7. 文本字符串类型</h2><p>MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、 LONGTEXT 、 ENUM 、 SET 等类型。</p>
<h2 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8. ENUM类型"></a>8. ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。 其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p>
<table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>ENUM</td>
<td>L</td>
<td>1 &lt;&#x3D; L &lt;&#x3D; 65535</td>
<td>1或2个字节</td>
</tr>
</tbody></table>
<ul>
<li>当ENUM类型包含1～255个成员时，需要1个字节的存储空间； </li>
<li>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。 </li>
<li>ENUM类型的成员个数的上限为65535个。</li>
</ul>
<h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p>
<table>
<thead>
<tr>
<th>成员个数范围（L表示实际成员个数）</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>1 &lt;&#x3D; L &lt;&#x3D; 8</td>
<td>1个字节</td>
</tr>
<tr>
<td>9 &lt;&#x3D; L &lt;&#x3D; 16</td>
<td>2个字节</td>
</tr>
<tr>
<td>17 &lt;&#x3D; L &lt;&#x3D; 24</td>
<td>3个字节</td>
</tr>
<tr>
<td>25 &lt;&#x3D; L &lt;&#x3D; 32</td>
<td>4个字节</td>
</tr>
<tr>
<td>33 &lt;&#x3D; L &lt;&#x3D; 64</td>
<td>8个字节</td>
</tr>
</tbody></table>
<p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次 选择多个成员，这一点与ENUM类型不同。</p>
<h2 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a>13. 小结及选择建议</h2><p>在定义数据类型时，如果确定是 整数 ，就用 INT ； 如果是 小数 ，一定用定点数类型 DECIMAL(M,D) ； 如果是日期与时间，就用 DATETIME 。 这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性 好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p>
<p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p>
<ul>
<li><p>任何字段如果为非负数，必须是 UNSIGNED </p>
</li>
<li><p>【 强制 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 </p>
<p>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。 </p>
</li>
<li><p>【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</p>
</li>
<li><p>【 强制 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
</li>
</ul>
<h1 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章_约束"></a>第13章_约束</h1><h2 id="1-约束的分类"><a href="#1-约束的分类" class="headerlink" title="1. 约束的分类"></a>1. 约束的分类</h2><ul>
<li>根据约束数据列的限制，约束可分为：<ul>
<li>单列约束：每个约束只约束一列</li>
<li>多列约束：每个约束可约束多列数据</li>
</ul>
</li>
<li>根据约束的作用范围，约束可分为：<ul>
<li>列级约束：只能作用在一个列上，跟在列的定义后面</li>
<li>表级约束：可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
<li>根据约束起的作用，约束可分为：<ul>
<li>NOT NULL 非空约束，规定某个字段不能为空 </li>
<li>UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 </li>
<li>PRIMARY KEY 主键(非空且唯一)约束 </li>
<li>FOREIGN KEY 外键约束 </li>
<li>CHECK 检查约束 </li>
<li>DEFAULT 默认值约束</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果 </p>
</blockquote>
<ul>
<li>如何添加&#x2F; 删除约束？</li>
</ul>
<p>CREATE TABLE时添加约束</p>
<p>ALTER TABLE时增加约束、删除约束</p>
<ul>
<li>查看某个表已有的约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#information_schema数据库名（系统库）<br>#table_constraints表名称（专门存储各个表的约束）<br>SELECT * FROM information_schema.table_constraints<br>WHERE table_name = &#x27;表名称&#x27;;<br></code></pre></td></tr></table></figure>

<h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>限定某个字段&#x2F; 某列的值不允许为空</p>
<h3 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>NOT NULL</p>
<h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3) 特点"></a>3) 特点</h3><ul>
<li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型 </li>
<li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空 </li>
<li>一个表可以有很多列都分别限定了非空 </li>
<li>空字符串’’不等于NULL，0也不等于NULL</li>
</ul>
<h3 id="4-添加非空约束"><a href="#4-添加非空约束" class="headerlink" title="4) 添加非空约束"></a>4) 添加非空约束</h3><p><strong>1. 建表时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名称(<br>字段名 数据类型,<br>字段名 数据类型 NOT NULL,<br>字段名 数据类型 NOT NULL<br>);<br></code></pre></td></tr></table></figure>

<p><strong>2. 建表后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 not null;<br></code></pre></td></tr></table></figure>

<h3 id="5-删除非空约束"><a href="#5-删除非空约束" class="headerlink" title="5) 删除非空约束"></a>5) 删除非空约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空<br>或<br>alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空<br></code></pre></td></tr></table></figure>

<h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>用来限制某个字段&#x2F;某列的值不能重复。</p>
<h3 id="2-关键字-1"><a href="#2-关键字-1" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>UNIQUE</p>
<h3 id="3-特点-1"><a href="#3-特点-1" class="headerlink" title="3) 特点"></a>3) 特点</h3><ul>
<li>同一个表可以有多个唯一约束。</li>
<li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 </li>
<li>唯一性约束允许列值为空。 </li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 </li>
<li>MySQL会给唯一约束的列上默认创建一个唯一索引。</li>
</ul>
<h3 id="4-添加唯一约束"><a href="#4-添加唯一约束" class="headerlink" title="4) 添加唯一约束"></a>4) 添加唯一约束</h3><p><strong>1. 建表时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名 数据类型,<br>字段名 数据类型 unique,<br>字段名 数据类型 unique key,<br>字段名 数据类型<br>);<br><br>create table 表名称(<br>字段名 数据类型,<br>字段名 数据类型,<br>字段名 数据类型,<br>[constraint 约束名] unique key(字段名)<br>);<br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE USER(<br>id INT NOT NULL,<br>NAME VARCHAR(25),<br>PASSWORD VARCHAR(16),<br>-- 使用表级约束语法<br>CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)<br>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>表示用户名和密码组合不能重复</p>
</blockquote>
<p><strong>2. 建表后指定唯一键约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯<br>一的<br>#方式1：<br>alter table 表名称 add unique key(字段列表);<br>#方式2：<br>alter table 表名称 modify 字段名 字段类型 unique;<br></code></pre></td></tr></table></figure>

<h3 id="5-关于复合唯一约束"><a href="#5-关于复合唯一约束" class="headerlink" title="5) 关于复合唯一约束"></a>5) 关于复合唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名 数据类型,<br>字段名 数据类型,<br>字段名 数据类型,<br>unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多<br>个字段的组合是唯一的<br>);<br></code></pre></td></tr></table></figure>

<h3 id="6-删除唯一约束"><a href="#6-删除唯一约束" class="headerlink" title="6) 删除唯一约束"></a>6) 删除唯一约束</h3><ul>
<li>添加唯一性约束的列上也会自动创建唯一索引。 </li>
<li>删除唯一约束只能通过删除唯一索引的方式删除。 </li>
<li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 </li>
<li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；</li>
<li>如果是组合列，那么默认和() 中排在第一个的列名相同。也可以自定义唯一性约束名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE USER<br>DROP INDEX uk_name_pwd;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：可以通过 show index from 表名称;        #查看表的索引</p>
</blockquote>
<h2 id="4-PRIMARY-KEY-约束"><a href="#4-PRIMARY-KEY-约束" class="headerlink" title="4. PRIMARY KEY 约束"></a>4. PRIMARY KEY 约束</h2><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>用来唯一标识表中的一行记录。</p>
<h3 id="2-关键字-2"><a href="#2-关键字-2" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>primary key</p>
<h3 id="3-特点-2"><a href="#3-特点-2" class="headerlink" title="3) 特点"></a>3) 特点</h3><p>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</p>
<ul>
<li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 </li>
<li>主键约束对应着表中的一列或者多列（复合主键） </li>
<li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 </li>
<li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。 </li>
<li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高。如果删除主键约束了，主键约束对应的索引就自动删除了。 </li>
<li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li>
</ul>
<h3 id="4-添加主键约束"><a href="#4-添加主键约束" class="headerlink" title="4) 添加主键约束"></a>4) 添加主键约束</h3><p><strong>1. 建表时指定主键约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名 数据类型 primary key, #列级模式<br>字段名 数据类型,<br>字段名 数据类型<br>);<br><br>create table 表名称(<br>字段名 数据类型,<br>字段名 数据类型,<br>字段名 数据类型,<br>[constraint 约束名] primary key(字段名) #表级模式<br>);<br></code></pre></td></tr></table></figure>

<p><strong>2. 建表后增加主键约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键<br></code></pre></td></tr></table></figure>

<h3 id="5-关于复合主键"><a href="#5-关于复合主键" class="headerlink" title="5) 关于复合主键"></a>5) 关于复合主键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名 数据类型,<br>字段名 数据类型,<br>字段名 数据类型,<br>primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段<br>);<br></code></pre></td></tr></table></figure>

<h3 id="6-删除主键约束"><a href="#6-删除主键约束" class="headerlink" title="6) 删除主键约束"></a>6) 删除主键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table 表名称 drop primary key<br></code></pre></td></tr></table></figure>

<blockquote>
<p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
</blockquote>
<h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><h3 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>某个字段的值自增</p>
<h3 id="2-关键字-3"><a href="#2-关键字-3" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>auto_increment</p>
<h3 id="3-特点-3"><a href="#3-特点-3" class="headerlink" title="3) 特点"></a>3) 特点</h3><p>（1）一个表最多只能有一个自增长列 </p>
<p>（2）当需要产生唯一标识符或顺序值时，可设置自增长 </p>
<p>（3）自增长列约束的列必须是键列（主键列，唯一键列） </p>
<p>（4）自增约束的列的数据类型必须是整数类型 </p>
<p>（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p>
<h3 id="4-如何指定自增约束"><a href="#4-如何指定自增约束" class="headerlink" title="4) 如何指定自增约束"></a>4) 如何指定自增约束</h3><p><strong>1. 建表时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名 数据类型 primary key auto_increment,<br>字段名 数据类型 unique key not null,<br>字段名 数据类型 unique key,<br>字段名 数据类型 not null default 默认值,<br>);<br>create table 表名称(<br>字段名 数据类型 default 默认值 ,<br>字段名 数据类型 unique key auto_increment,<br>字段名 数据类型 not null default 默认值,<br>primary key(字段名)<br>);<br></code></pre></td></tr></table></figure>

<p><strong>2. 建表后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 auto_increment;<br></code></pre></td></tr></table></figure>

<h3 id="5-删除自增约束"><a href="#5-删除自增约束" class="headerlink" title="5) 删除自增约束"></a>5) 删除自增约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束<br>alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除<br></code></pre></td></tr></table></figure>

<h3 id="6-MySQL-8-0新特性—自增变量的持久化"><a href="#6-MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="6) MySQL 8.0新特性—自增变量的持久化"></a>6) MySQL 8.0新特性—自增变量的持久化</h3><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如 下： 创建的数据表中包含自增主键的id字段，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE test1(<br>id INT PRIMARY KEY AUTO_INCREMENT<br>);<br></code></pre></td></tr></table></figure>

<p>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典 内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。</p>
<p>在MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志 中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p>
<h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><h3 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>限定某个表的某个字段的引用完整性。</p>
<h3 id="2-关键字-4"><a href="#2-关键字-4" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>FOREIGN KEY</p>
<h3 id="3-主表和从表-父表和子表"><a href="#3-主表和从表-父表和子表" class="headerlink" title="3) 主表和从表&#x2F;父表和子表"></a>3) 主表和从表&#x2F;父表和子表</h3><p>主表（父表）：被引用的表，被参考的表 </p>
<p>从表（子表）：引用别人的表，参考别人的表</p>
<h3 id="4-特点"><a href="#4-特点" class="headerlink" title="4) 特点"></a>4) 特点</h3><p>（1）从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列为什么？因为被依赖&#x2F;被参考的值必须是唯一的 </p>
<p>（2）在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。 </p>
<p>（3）创建(CREATE)表时就指定外键约束的话，<strong>先创建主表</strong>，再创建从表 </p>
<p>（4）删表时，<strong>先删从表</strong>（或先删除外键约束），再删除主表 </p>
<p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 </p>
<p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束 </p>
<p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。 例如：都是表示部门编号，都是int类型。</p>
<p>（8）当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高） </p>
<p>（9）删除外键约束后，必须手动删除对应的索引</p>
<h3 id="5-添加外键约束"><a href="#5-添加外键约束" class="headerlink" title="5) 添加外键约束"></a>5) 添加外键约束</h3><p><strong>1. 建表时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 主表名称(<br>字段1 数据类型 primary key,<br>字段2 数据类型<br>);<br><br>create table 从表名称(<br>字段1 数据类型 primary key,<br>字段2 数据类型,<br>[CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)<br>);<br>#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样<br>#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样<br>-- FOREIGN KEY: 在表级指定子表中的列<br>-- REFERENCES: 标示在父表中的列<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table dept( #主表<br>did int primary key, #部门编号<br>dname varchar(50) #部门名称<br>);<br>create table emp(#从表<br>eid int primary key, #员工编号<br>ename varchar(5), #员工姓名<br>deptid int, #员工所在的部门<br>foreign key (deptid) references dept(did) #在从表中指定外键约束<br>#emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号<br>);<br>说明：<br>（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。<br>（2）删除表时，先删除从表emp，再删除主表dept<br></code></pre></td></tr></table></figure>

<p><strong>2. 建表后</strong></p>
<p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不 过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那 么，就要用修改表的方式来补充定义。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];<br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE emp1<br>ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);<br></code></pre></td></tr></table></figure>

<h3 id="6-约束等级"><a href="#6-约束等级" class="headerlink" title="6) 约束等级"></a>6) 约束等级</h3><ul>
<li><code>Cascade方式 </code>：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录 </li>
<li><code>Set null方式</code> ：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null </li>
<li><code>No action方式</code> ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作 </li>
<li><code>Restrict方式</code> ：同no action， 都是立即检查外键约束 </li>
<li><code>Set default方式</code> （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别x</li>
</ul>
<p>如果没有指定等级，就相当于Restrict方式。 对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。</p>
<h3 id="7-删除外键约束"><a href="#7-删除外键约束" class="headerlink" title="7) 删除外键约束"></a>7) 删除外键约束</h3><p>流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">(1)第一步先查看约束名和删除外键约束<br>SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;  #查看某个表的约束名<br>ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;<br><br>（2）第二步查看索引名和删除索引。（注意，只能手动删除）<br>SHOW INDEX FROM 表名称; #查看某个表的索引名<br>ALTER TABLE 从表名 DROP INDEX 索引名;<br></code></pre></td></tr></table></figure>

<h3 id="8-开发场景"><a href="#8-开发场景" class="headerlink" title="8) 开发场景"></a>8) 开发场景</h3><p><strong>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否 一定要建外键约束？</strong></p>
<p>答：不是的</p>
<p><strong>问题2：建和不建外键约束有什么区别？</strong></p>
<p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限 制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。 </p>
<p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 引用完整 性 ，只能依靠程序员的自觉 ，或者是 在Java程序中进行限定 。例如：在员工表中，可以添加一个员工的 信息，它的部门指定为一个完全不存在的部门。</p>
<p><strong>问题3：那么建和不建外键约束和查询有没有关系？</strong></p>
<p>答：没有</p>
<blockquote>
<p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不 用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
</blockquote>
<h3 id="9-阿里开发规范"><a href="#9-阿里开发规范" class="headerlink" title="9)  阿里开发规范"></a>9)  阿里开发规范</h3><p>【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。 </p>
<p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响 数据库的 插入速度 。</p>
<h2 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a>7. CHECK 约束</h2><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p>
<h3 id="2-关键字-5"><a href="#2-关键字-5" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>CHECK</p>
<h3 id="3-说明"><a href="#3-说明" class="headerlink" title="3) 说明"></a>3) 说明</h3><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p>
<p>但是<strong>MySQL 8.0中可以使用check约束了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table employee(<br>eid int primary key,<br>ename varchar(5),<br>gender char check (&#x27;男&#x27; or &#x27;女&#x27;)<br>);<br></code></pre></td></tr></table></figure>

<h2 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a>8. DEFAULT约束</h2><h3 id="1-作用-6"><a href="#1-作用-6" class="headerlink" title="1) 作用"></a>1) 作用</h3><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p>
<h3 id="2-关键字-6"><a href="#2-关键字-6" class="headerlink" title="2) 关键字"></a>2) 关键字</h3><p>DEFAULT</p>
<h3 id="3-添加默认值"><a href="#3-添加默认值" class="headerlink" title="3) 添加默认值"></a>3) 添加默认值</h3><p><strong>1. 建表时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>字段名 数据类型 primary key,<br>字段名 数据类型 unique key not null,<br>字段名 数据类型 unique key,<br>字段名 数据类型 not null default 默认值,<br>);<br></code></pre></td></tr></table></figure>

<p><strong>2. 建表后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 default 默认值;<br>#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了<br>#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了<br>alter table 表名称 modify 字段名 数据类型 default 默认值 not null;<br></code></pre></td></tr></table></figure>

<p><strong>删除默认值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型; #删除默认值约束，也不保留非空约束<br>alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束<br></code></pre></td></tr></table></figure>

<h2 id="9-面试"><a href="#9-面试" class="headerlink" title="9. 面试"></a>9. 面试</h2><p><strong>面试1、为什么建表时，加 not null default ‘’ 或 default 0</strong></p>
<p>答：不想让表中出现null值。</p>
<p><strong>面试2、为什么不想要 null 的值</strong></p>
<p>答:</p>
<p>（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通 常返回null。 </p>
<p>（2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p>
<p><strong>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong></p>
<p>在MySQL中，默认AUTO_INCREMENT的初始 值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第 一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一 条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要 设置字段自动增加属性。</p>
<p><strong>面试4、并不是每个表都可以任意选择存储引擎？</strong></p>
<p>外键约束（FOREIGN KEY）不能跨引擎使用。</p>
<p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来 保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不 能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>
<h1 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章_视图"></a>第14章_视图</h1><h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>表(TABLE)</td>
<td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td>
</tr>
<tr>
<td>数据字典</td>
<td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护， 程序员通常不应该修改，只可查看</td>
</tr>
<tr>
<td>约束 (CONSTRAINT)</td>
<td>执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr>
<td>视图(VIEW)</td>
<td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td>
</tr>
<tr>
<td>索引(INDEX)</td>
<td>用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td>存储过程 (PROCEDURE)</td>
<td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调 用环境</td>
</tr>
<tr>
<td>存储函数 (FUNCTION)</td>
<td>用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td>触发器 (TRIGGER)</td>
<td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td>
</tr>
</tbody></table>
<h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><ul>
<li>视图是一种 虚拟表 ，本身是 不具有数据 的，占用很少的内存空间，它是 SQL 中的一个重要概念。 </li>
<li>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/cjL1B3wTmOUkRGx.png" alt="image-20220608173721188"></p>
<ul>
<li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和 修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li>
<li>视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句 <ul>
<li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删 除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li>
</ul>
</li>
<li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视 图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我 们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li>
</ul>
<h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><ul>
<li>在 CREATE VIEW 语句中嵌入子查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE [OR REPLACE]<br>[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]<br>VIEW 视图名称 [(字段列表)]<br>AS 查询语句<br>[WITH [CASCADED|LOCAL] CHECK OPTION]<br></code></pre></td></tr></table></figure>

<ul>
<li>精简版</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE VIEW 视图名称<br>AS 查询语句<br></code></pre></td></tr></table></figure>

<h3 id="1-创建单表视图"><a href="#1-创建单表视图" class="headerlink" title="1) 创建单表视图"></a>1) 创建单表视图</h3><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 方式一：<br>CREATE VIEW empvu80<br>AS<br>SELECT employee_id, last_name, salary<br>FROM employees<br>WHERE department_id = 80;<br><br># 方式二：<br>CREATE VIEW empsalary8000(emp_id, NAME, monthly_sal) # 小括号内字段个数与SELECT中字段个数相同<br>AS<br>SELECT employee_id, last_name, salary<br>FROM employees<br>WHERE salary &gt; 8000;<br></code></pre></td></tr></table></figure>

<p>查询视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM salvu80;<br></code></pre></td></tr></table></figure>

<h3 id="2-创建多表联合视图"><a href="#2-创建多表联合视图" class="headerlink" title="2) 创建多表联合视图"></a>2) 创建多表联合视图</h3><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE VIEW empview<br>AS<br>SELECT employee_id emp_id,last_name NAME,department_name<br>FROM employees e,departments d<br>WHERE e.department_id = d.department_id;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE VIEW dept_sum_vu<br>(name, minsal, maxsal, avgsal)<br>AS<br>SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)<br>FROM employees e, departments d<br>WHERE e.department_id = d.department_id<br>GROUP BY d.department_name;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用视图对数据进行格式化</li>
</ul>
<p>常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE VIEW emp_depart<br>AS<br>SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept<br>FROM employees e JOIN departments d<br>WHERE e.department_id = d.department_id;<br></code></pre></td></tr></table></figure>

<h3 id="3-基于视图创建视图"><a href="#3-基于视图创建视图" class="headerlink" title="3) 基于视图创建视图"></a>3) 基于视图创建视图</h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p>
<p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE VIEW emp_dept_ysalary<br>AS<br>SELECT emp_dept.ename,dname,year_salary<br>FROM emp_dept INNER JOIN emp_year_salary<br>ON emp_dept.ename = emp_year_salary.ename;<br></code></pre></td></tr></table></figure>

<h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><p>语法1：查看数据库的表对象、视图对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure>

<p>语法2：查看视图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DESC / DESCRIBE 视图名称;<br></code></pre></td></tr></table></figure>

<p>语法3：查看视图的属性信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）<br>SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G<br></code></pre></td></tr></table></figure>

<p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。 语法4：查看视图的详细定义信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW 视图名称;<br></code></pre></td></tr></table></figure>

<h2 id="5-更新视图的数据"><a href="#5-更新视图的数据" class="headerlink" title="5. 更新视图的数据"></a>5. 更新视图的数据</h2><h3 id="1-一般情况"><a href="#1-一般情况" class="headerlink" title="1) 一般情况"></a>1) 一般情况</h3><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的 数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p>
<p>举例：UPDATE操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UPDATE emp_tel SET tel = &#x27;13789091234&#x27; WHERE ename = &#x27;孙洪亮&#x27;;<br></code></pre></td></tr></table></figure>

<p>举例：DELETE操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELETE FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="2-不可更新的视图"><a href="#2-不可更新的视图" class="headerlink" title="2) 不可更新的视图"></a>2) 不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作； </li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； </li>
<li>在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； </li>
<li>在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值； </li>
<li>在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE； </li>
<li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE； </li>
<li>视图定义基于一个 不可更新视图 ； 常量视图。</li>
</ul>
<blockquote>
<p>虽然可以更新视图数据，但总的来说，视图作为虚拟表 ，主要用于方便查询 ，不建议更新视图的数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</p>
</blockquote>
<h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><h3 id="1-修改视图"><a href="#1-修改视图" class="headerlink" title="1) 修改视图"></a>1) 修改视图</h3><p>方式1：使用CREATE OR REPLACE VIEW 子句修改视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW empvu80<br>(id_number, name, sal, department_id)<br>AS<br>SELECT employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id<br>FROM employees<br>WHERE department_id = 80;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p>
</blockquote>
<p>方式2：ALTER VIEW</p>
<p>修改视图的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER VIEW 视图名称<br>AS<br>查询语句<br></code></pre></td></tr></table></figure>

<h3 id="2-删除视图"><a href="#2-删除视图" class="headerlink" title="2) 删除视图"></a>2) 删除视图</h3><ul>
<li>删除视图只是删除视图的定义，并不会删除基表的数据。 </li>
<li>删除视图的语法是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP VIEW IF EXISTS 视图名称;<br></code></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP VIEW empvu80;<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这 样的视图c需要手动删除或修改，否则影响使用。</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1) 优点"></a>1) 优点</h3><p><strong>1. 操作简单</strong></p>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
<p><strong>2. 减少数据冗余</strong></p>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语 句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
<p><strong>3. 数据安全</strong></p>
<p>MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用 户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p>
<p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，用户不需要查询数据表，可以直接通过视图获取数据表中的信息。这在一定程度上保障了数据表中数据的安全性。</p>
<p><strong>4. 适应灵活多变的需求</strong></p>
<p>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较 大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
<p><strong>5. 能够分解复杂的查询逻辑</strong></p>
<p> 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图 获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
<h3 id="2-不足"><a href="#2-不足" class="headerlink" title="2) 不足"></a>2) 不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。 </p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。 </p>
<p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<h1 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章_存储过程与函数"></a>第15章_存储过程与函数</h1><p>MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程 序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p>
<h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1) 理解"></a>1) 理解</h3><p><strong>含义：</strong>存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译的 SQL 语句 的封装。</p>
<p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处：</strong></p>
<ul>
<li>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力。</li>
<li>2、减少操作过程中的失误，提高效率。</li>
<li>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）。</li>
<li>4、减少了 SQL 语句暴露在 网上的风险，也提高了数据查询的安全性。</li>
</ul>
<p><strong>和视图、函数的对比：</strong></p>
<p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p>
<p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 没有返回值 的。</p>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2) 分类"></a>2) 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<p>1、没有参数（无参数无返回） </p>
<p>2、仅仅带 IN 类型（有参数无返回） </p>
<p>3、仅仅带 OUT 类型（无参数有返回） </p>
<p>4、既带 IN 又带 OUT（有参数有返回） </p>
<p>5、带 INOUT（有参数有返回）</p>
<p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><h3 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1) 语法分析"></a>1) 语法分析</h3><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)<br>[characteristics ...]<br>BEGIN<br>存储过程体<br>END<br></code></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>1、参数前面的符号的意思</p>
<ul>
<li><p>IN ：当前参数为输入参数，也就是表示入参；</p>
<p>存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数。</p>
</li>
<li><p>OUT ：当前参数为输出参数，也就是表示出参；</p>
<p>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</p>
</li>
<li><p>INOUT ：当前参数既可以为输入参数，也可以为输出参数。</p>
</li>
</ul>
<p>2、形参类型可以是 MySQL数据库中的任意类型。</p>
<p>3、characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">LANGUAGE SQL<br>| [NOT] DETERMINISTIC<br>| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;<br>| SQL SECURITY &#123; DEFINER | INVOKER &#125;<br>| COMMENT &#x27;string&#x27;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p>
</li>
<li><p>[NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定 的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定 的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
</li>
<li><p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使 用SQL语句的限制。</p>
<ul>
<li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li>
<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句； </li>
<li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句； </li>
<li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。 </li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
</li>
<li><p>SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
<ul>
<li>DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li>
<li>INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li>
</ul>
</li>
<li><p>COMMENT ‘string’ ：注释信息，可以用来描述存储过程。</p>
</li>
</ul>
<p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。<br>2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进<br>行变量的声明。<br>3. SET：赋值语句，用于对变量进行赋值。<br>4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。<br></code></pre></td></tr></table></figure>

<p>5、需要设置新的结束标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER 新的结束标记<br></code></pre></td></tr></table></figure>

<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用 DELIMITER改变存储过程的结束符。</p>
<p>比如：“DELIMITER &#x2F;&#x2F;”语句的作用是将MySQL的结束符设置为&#x2F;&#x2F;，并以“END &#x2F;&#x2F;”结束存储过程。存储过程定 义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。</p>
<p>当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。 </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER $<br>CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)<br>[characteristics ...]<br>BEGIN<br>sql语句1;<br>sql语句2;<br>END $<br></code></pre></td></tr></table></figure>

<h3 id="2-代码举例"><a href="#2-代码举例" class="headerlink" title="2)  代码举例"></a>2)  代码举例</h3><p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER $<br>CREATE PROCEDURE select_all_data()<br>BEGIN<br>SELECT * FROM emps;<br>END $<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE avg_employee_salary ()<br>BEGIN<br>SELECT AVG(salary) AS avg_salary FROM emps;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><h3 id="1-调用格式"><a href="#1-调用格式" class="headerlink" title="1) 调用格式"></a>1) 调用格式</h3><p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CALL 存储过程名(实参列表)<br></code></pre></td></tr></table></figure>

<p><strong>格式：</strong></p>
<p>1、调用in模式的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CALL sp1(&#x27;值&#x27;);<br></code></pre></td></tr></table></figure>

<p>2、调用out模式的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET @name;<br>CALL sp1(@name);<br>SELECT @name;<br></code></pre></td></tr></table></figure>

<p>3、调用inout模式的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET @name=值;<br>CALL sp1(@name);<br>SELECT @name;<br></code></pre></td></tr></table></figure>

<h3 id="2-代码举例-1"><a href="#2-代码举例-1" class="headerlink" title="2) 代码举例"></a>2) 代码举例</h3><p><strong>举例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)<br>BEGIN<br>SELECT COUNT(*) INTO num FROM fruits<br>WHERE s_id = sid;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CALL CountProc (101, @num);<br></code></pre></td></tr></table></figure>

<p>查看返回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT @num;<br></code></pre></td></tr></table></figure>

<p><strong>举例2：</strong>创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE `add_num`(IN n INT)<br>BEGIN<br>DECLARE i INT;<br>DECLARE sum INT;<br>SET i = 1;<br>SET sum = 0;<br>WHILE i &lt;= n DO<br>SET sum = sum + i;<br>SET i = i +1;<br>END WHILE;<br>SELECT sum;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>直接使用 CALL add_num(50); 即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和。</p>
<h3 id="3-如何调试"><a href="#3-如何调试" class="headerlink" title="3) 如何调试"></a>3) 如何调试</h3><p>在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因 此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试 成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样 逐步推进 ，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独 调试。</p>
<h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><h3 id="1-语法分析-1"><a href="#1-语法分析-1" class="headerlink" title="1) 语法分析"></a>1) 语法分析</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION 函数名(参数名 参数类型,...)<br>RETURNS 返回值类型<br>[characteristics ...]<br>BEGIN<br>函数体 #函数体中肯定有 RETURN 语句<br>END<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。 </p>
<p>2、RETURNS type 语句表示函数返回数据的类型； RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函 数体必须包含一个 RETURN value 语句。 </p>
<p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。 </p>
<p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略 BEGIN…END。</p>
<h3 id="2-调用存储函数"><a href="#2-调用存储函数" class="headerlink" title="2) 调用存储函数"></a>2) 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL 的 开发者定义 的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 函数名(实参列表)<br></code></pre></td></tr></table></figure>

<h3 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3) 代码举例"></a>3) 代码举例</h3><p><strong>举例1：</strong></p>
<p>创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE FUNCTION email_by_name()<br>RETURNS VARCHAR(25)<br>DETERMINISTIC<br>CONTAINS SQL<br>BEGIN<br>RETURN (SELECT email FROM employees WHERE last_name = &#x27;Abel&#x27;);<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT email_by_name();<br></code></pre></td></tr></table></figure>

<p><strong>举例2：</strong></p>
<p>创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型 为字符串型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE FUNCTION email_by_id(emp_id INT)<br>RETURNS VARCHAR(25)<br>DETERMINISTIC<br>CONTAINS SQL<br>BEGIN<br>RETURN (SELECT email FROM employees WHERE employee_id = emp_id);<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET @emp_id = 102;<br>SELECT email_by_id(@emp_id);<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>若在创建存储函数中报错“ you might want to use the less safe log_bin_trust_function_creators variable ”，有两种处理方法：</p>
<ul>
<li><p>方式1：</p>
<p>加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</p>
</li>
<li><p>方式2：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL log_bin_trust_function_creators = 1;<br></code></pre></td></tr></table></figure>

<h3 id="4-对比存储函数与存储过程"><a href="#4-对比存储函数与存储过程" class="headerlink" title="4) 对比存储函数与存储过程"></a>4) 对比存储函数与存储过程</h3><table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>存储过程</td>
<td>PROCEDURE</td>
<td>CALL 存储过程()</td>
<td>理解为有0个或多个</td>
<td>一般用于更新</td>
</tr>
<tr>
<td>存储函数</td>
<td>FUNCTION</td>
<td>SELECT 函数 ()</td>
<td>只能是一个</td>
<td>一般用于查询结果为一个值并返回时</td>
</tr>
</tbody></table>
<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够 执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>
<h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><h3 id="1-查看"><a href="#1-查看" class="headerlink" title="1) 查看"></a>1) 查看</h3><p> 创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？</p>
<p>MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查 看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。</p>
<ol>
<li>使用SHOW CREATE语句查看存储过程和函数的创建信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>使用SHOW STATUS语句查看存储过程和函数的状态信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>从information_schema.Routines表中查看存储过程和函数的信息</li>
</ol>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.Routines<br>WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];<br></code></pre></td></tr></table></figure>

<p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来 指明查询的是存储过程还是函数。</p>
<h3 id="2-修改"><a href="#2-修改" class="headerlink" title="2) 修改"></a>2) 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]<br></code></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;<br>| SQL SECURITY &#123; DEFINER | INVOKER &#125;<br>| COMMENT &#x27;string&#x27;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。 </p>
</li>
<li><p>NO SQL ，表示子程序中不包含SQL语句。 </p>
</li>
<li><p>READS SQL DATA ，表示子程序中包含读数据的语句。 </p>
</li>
<li><p>MODIFIES SQL DATA ，表示子程序中包含写数据的语句。 </p>
</li>
<li><p>SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行。 </p>
<ul>
<li>DEFINER ，表示只有定义者自己才能够执行。 </li>
<li>INVOKER ，表示调用者可以执行。</li>
</ul>
</li>
<li><p>COMMENT ‘string’ ，表示注释信息。</p>
</li>
</ul>
<blockquote>
<p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两 个语句的结构是一样的，语句中的所有参数也是一样的。</p>
</blockquote>
<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3) 删除"></a>3) 删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名<br></code></pre></td></tr></table></figure>

<h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><h3 id="1-优点-1"><a href="#1-优点-1" class="headerlink" title="1) 优点"></a>1) 优点</h3><p>1、存储过程可以一次编译多次使用。存储过程只在创建时进行编译，之后的使用都不需要重新编译， 这就提升了 SQL 的执行效率。</p>
<p>2、可以减少开发工作量。将代码 封装 成模块，实际上是编程的核心思想之一，这样可以把复杂的问题 拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清 晰。 </p>
<p>3、存储过程的安全性强。我们在设定存储过程的时候可以 设置对用户的使用权限 ，这样就和视图一样具 有较强的安全性。 </p>
<p>4、可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减 少了网络传输量。 </p>
<p>5、良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接 多次数据库才能完成的操作，现在变成了一次存储过程，只需要 连接一次即可 。</p>
<h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2) 缺点"></a>2) 缺点</h3><blockquote>
<p>阿里开发规范 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<p>1、可移植性差。存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过 程，在换成其他数据库时都需要重新编写。 </p>
<p>2、调试困难。只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容 易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。 </p>
<p>3、存储过程的版本管理很困难。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发 软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。 </p>
<p>4、它不适合高并发的场景。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就不适用了。</p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3) 小结"></a>3) 小结</h3><p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说， 不论怎样，掌握存储过程都是必备的技能之一。</p>
<h1 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章_变量、流程控制与游标"></a>第16章_变量、流程控制与游标</h1><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终 的结果数据。 </p>
<p>在 MySQL 数据库中，变量分为 系统变量 以及 用户自定义变量 。</p>
<h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1) 系统变量"></a>1) 系统变量</h3><p><strong>系统变量分类</strong></p>
<p>变量由系统定义，不是用户定义，属于 服务器 层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特 征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数 值。大家可以通过网址 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-systemvariables.html">https://dev.mysql.com/doc/refman/8.0/en/server-systemvariables.html</a> 查看MySQL文档的系统变量。</p>
<p>系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：</p>
<img src="https://s2.loli.net/2024/02/24/2uVyGJHZDWlQEs3.png" alt="image-20220613135809104" style="zoom:80%;" />

<ul>
<li>全局系统变量针对于所有会话（连接）有效，但 不能跨重启</li>
<li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。 </li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
<p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系 统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
<p><strong>查看系统变量</strong></p>
<ul>
<li>查看所有或部分系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br>#查看所有会话变量<br>SHOW SESSION VARIABLES;<br>或<br>SHOW VARIABLES;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#查看满足条件的部分系统变量。<br>SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;<br>#查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;;<br></code></pre></td></tr></table></figure>

<p><strong>查看指定系统变量</strong></p>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在， 则标记全局系统变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#查看指定的系统变量的值<br>SELECT @@global.变量名;<br>#查看指定的会话变量的值<br>SELECT @@session.变量名;<br>#或者<br>SELECT @@变量名;<br></code></pre></td></tr></table></figure>

<p><strong>修改系统变量的值</strong></p>
<p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、 特征。具体方法：</p>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务） </p>
<p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#为某个系统变量赋值<br>#方式1：<br>SET @@global.变量名=变量值;<br>#方式2：<br>SET GLOBAL 变量名=变量值;<br>#为某个会话变量赋值<br>#方式1：<br>SET @@session.变量名=变量值;<br>#方式2：<br>SET SESSION 变量名=变量值;<br></code></pre></td></tr></table></figure>

<h3 id="2-用户变量"><a href="#2-用户变量" class="headerlink" title="2) 用户变量"></a>2) 用户变量</h3><p><strong>用户变量分类</strong></p>
<p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以一个“@” 开头。根据作用范围不同，又分为 会话用户变量 和 局部变量 。 </p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。 </li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。</li>
</ul>
<p><strong>会话用户变量</strong></p>
<ul>
<li>变量的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式1：“=”或“:=”<br>SET @用户变量 = 值;<br>SET @用户变量 := 值;<br>#方式2：“:=” 或 INTO关键字<br>SELECT @用户变量 := 表达式 [FROM 等子句];<br>SELECT 表达式 INTO @用户变量 [FROM 等子句];<br></code></pre></td></tr></table></figure>

<ul>
<li>查看用户变量的值 (查看、比较、运算等)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT @用户变量<br></code></pre></td></tr></table></figure>

<p><strong>局部变量</strong></p>
<p>定义：可以使用 DECLARE 语句定义一个局部变量 </p>
<p>作用域：仅仅在定义它的 BEGIN … END 中有效 </p>
<p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">BEGIN<br>#声明局部变量<br>DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];<br>DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];<br>#为局部变量赋值<br>SET 变量名1 = 值;<br>SELECT 值 INTO 变量名2 [FROM 子句];<br>#查看局部变量的值<br>SELECT 变量1,变量2,变量3;<br>END<br></code></pre></td></tr></table></figure>

<ol>
<li>定义变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>变量赋值</li>
</ol>
<p>方式1：一般用于赋简单的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET 变量名=值;<br>SET 变量名:=值;<br></code></pre></td></tr></table></figure>

<p>方式2：一般用于赋表中的字段值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段名或表达式 INTO 变量名 FROM 表;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>使用变量 (查看、比较、运算等)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 局部变量名;<br></code></pre></td></tr></table></figure>

<p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE set_value()<br>BEGIN<br>DECLARE emp_name VARCHAR(25);<br>DECLARE sal DOUBLE(10,2);<br>SELECT last_name, salary INTO emp_name,sal<br>FROM employees<br>WHERE employee_id = 102;<br>SELECT emp_name, sal;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式1：使用用户变量<br>SET @m=1;<br>SET @n=1;<br>SET @sum=@m+@n;<br>SELECT @sum;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方式2：使用局部变量<br>DELIMITER //<br>CREATE PROCEDURE add_value()<br>BEGIN<br>#局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 3;<br>DECLARE SUM INT;<br>SET SUM = m+n;<br>SELECT SUM;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p><strong>对比会话用户变量与局部变量</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>会话用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<h2 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a>2. 定义条件与处理程序</h2><p>定义条件 是事先定义程序执行过程中可能遇到的问题， 处理程序 定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p>
<p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1) 案例分析"></a>1) 案例分析</h3><p>案例分析：创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE UpdateDataNoCondition()<br>BEGIN<br>SET @x = 1;<br>UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;<br>SET @x = 2;<br>UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;<br>SET @x = 3;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CALL UpdateDataNoCondition();<br>ERROR 1048 (23000): Column &#x27;email&#x27; cannot be null<br>mysql&gt; SELECT @x;<br>+------+<br>| @x |<br>+------+<br>| 1 |<br>+------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件 和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑， 不再向下继续执行。</p>
<h3 id="2-定义条件"><a href="#2-定义条件" class="headerlink" title="2) 定义条件"></a>2) 定义条件</h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的 错误条件 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。</p>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）<br></code></pre></td></tr></table></figure>

<p>错误码的说明：</p>
<ul>
<li>MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。<ul>
<li>MySQL_error_code是数值类型错误代码。 </li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
</li>
</ul>
<p>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。 </p>
<p>例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</p>
<p>举例1：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#使用MySQL_error_code<br>DECLARE Field_Not_Be_NULL CONDITION FOR 1048;<br>#使用sqlstate_value<br>DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="3-定义处理程序"><a href="#3-定义处理程序" class="headerlink" title="3) 定义处理程序"></a>3) 定义处理程序</h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句 的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句<br></code></pre></td></tr></table></figure>

<ul>
<li><p>处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。</p>
<ul>
<li>CONTINUE ：表示遇到错误不处理，继续执行。</li>
<li>EXIT ：表示遇到错误马上退出。</li>
<li>UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li><p>错误类型（即条件）可以有如下取值：</p>
<ul>
<li>SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码； </li>
<li>MySQL_error_code ：匹配数值类型错误代码； </li>
<li>错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。 </li>
<li>SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码； </li>
<li>NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码； </li>
<li>SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
</li>
<li><p>处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是 像“ SET 变量 &#x3D; 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。</p>
</li>
</ul>
<p>定义处理程序的几种方式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#方法1：捕获sqlstate_value<br>DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br>#方法2：捕获mysql_error_value<br>DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br>#方法3：先定义条件，再调用<br>DECLARE no_such_table CONDITION FOR 1146;<br>DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br>#方法4：使用SQLWARNING<br>DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;<br>#方法5：使用NOT FOUND<br>DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;<br>#方法6：使用SQLEXCEPTION<br>DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="4-案例解决"><a href="#4-案例解决" class="headerlink" title="4) 案例解决"></a>4) 案例解决</h3><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行 CONTINUE操作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE UpdateDataNoCondition()<br>BEGIN<br>    #定义处理程序<br>    DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;<br>    SET @x = 1;<br>    UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;<br>    SET @x = 2;<br>    UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;<br>    SET @x = 3;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h2 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a>3. 流程控制</h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控 制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p>
<ul>
<li>顺序结构 ：程序从上往下依次执行 </li>
<li>分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行 </li>
<li>循环结构 ：程序满足一定条件下，重复执行一组语句</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li>条件判断语句 ：IF 语句和 CASE 语句 </li>
<li>循环语句 ：LOOP、WHILE 和 REPEAT 语句 </li>
<li>跳转语句 ：ITERATE 和 LEAVE 语句</li>
</ul>
<h3 id="1-分支结构之-IF"><a href="#1-分支结构之-IF" class="headerlink" title="1) 分支结构之 IF"></a>1) 分支结构之 IF</h3><ul>
<li>IF 语句的语法结构是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">IF 表达式1 THEN 操作1<br>[ELSEIF 表达式2 THEN 操作2]……<br>[ELSE 操作N]<br>END IF<br></code></pre></td></tr></table></figure>

<p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p>
<ul>
<li><p>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</p>
</li>
<li><p>举例1：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">IF val IS NULL<br>	THEN SELECT &#x27;val is null&#x27;;<br>ELSE SELECT &#x27;val is not null&#x27;;<br>END IF;<br></code></pre></td></tr></table></figure>

<ul>
<li>举例2：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)<br>BEGIN<br>    DECLARE emp_salary DOUBLE;<br>    DECLARE hire_year DOUBLE;<br>    SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;<br>    SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year<br>    FROM employees WHERE employee_id = emp_id;<br>    IF emp_salary &lt; 8000 AND hire_year &gt; 5<br>    THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;<br>    END IF;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h3 id="2-分支结构之-CASE"><a href="#2-分支结构之-CASE" class="headerlink" title="2) 分支结构之 CASE"></a>2) 分支结构之 CASE</h3><ul>
<li>CASE 语句的语法结构1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#情况一：类似于switch<br>CASE 表达式<br>WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)<br>WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)<br>...<br>ELSE 结果n或语句n(如果是语句，需要加分号)<br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）<br></code></pre></td></tr></table></figure>

<ul>
<li>CASE 语句的语法结构2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#情况二：类似于多重if<br>CASE<br>WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)<br>WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)<br>...<br>ELSE 结果n或语句n(如果是语句，需要加分号)<br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）<br></code></pre></td></tr></table></figure>

<ul>
<li>举例1：使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CASE val<br>    WHEN 1 THEN SELECT &#x27;val is 1&#x27;;<br>    WHEN 2 THEN SELECT &#x27;val is 2&#x27;;<br>    ELSE SELECT &#x27;val is not 1 or 2&#x27;;<br>END CASE;<br></code></pre></td></tr></table></figure>

<ul>
<li>举例2：声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例 为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)<br>BEGIN<br>    DECLARE emp_sal DOUBLE;<br>    DECLARE bonus DECIMAL(3,2);<br>    SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;<br>    SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;<br>    CASE<br>    WHEN emp_sal&lt;9000<br>    	THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;<br>    WHEN emp_sal&lt;10000 AND bonus IS NULL<br>    	THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;<br>    ELSE<br>    	UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;<br>    END CASE;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<ul>
<li>举例3：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的 入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年， 薪资涨300；如果是4年，薪资涨400；其他的涨薪500。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)<br>BEGIN<br>    DECLARE emp_sal DOUBLE;<br>    DECLARE hire_year DOUBLE;<br>    SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;<br>    SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees<br>    WHERE employee_id = emp_id;<br>    CASE hire_year<br>        WHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;<br>        WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;<br>        WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;<br>        WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;<br>        WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;<br>        ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;<br>    END CASE;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h3 id="3-循环结构之LOOP"><a href="#3-循环结构之LOOP" class="headerlink" title="3) 循环结构之LOOP"></a>3) 循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子 句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">[loop_label:] LOOP<br>循环执行的语句<br>END LOOP [loop_label]<br></code></pre></td></tr></table></figure>

<p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p>
<p>举例1：使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE id INT DEFAULT 0;<br>add_loop:LOOP<br>    SET id = id +1;<br>    IF id &gt;= 10 THEN LEAVE add_loop;<br>    END IF;<br>END LOOP add_loop;<br></code></pre></td></tr></table></figure>

<p>举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程 “update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为 原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE update_salary_loop(OUT num INT)<br>BEGIN<br>	DECLARE avg_salary DOUBLE;<br>	DECLARE loop_count INT DEFAULT 0;<br>	SELECT AVG(salary) INTO avg_salary FROM employees;<br>	label_loop:LOOP<br>        IF avg_salary &gt;= 12000 THEN LEAVE label_loop;<br>        END IF;<br>        UPDATE employees SET salary = salary * 1.1;<br>        SET loop_count = loop_count + 1;<br>        SELECT AVG(salary) INTO avg_salary FROM employees;<br>    END LOOP label_loop;<br>    SET num = loop_count;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h3 id="4-循环结构之WHILE"><a href="#4-循环结构之WHILE" class="headerlink" title="4) 循环结构之WHILE"></a>4) 循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">[while_label:] WHILE 循环条件 DO<br>循环体<br>END WHILE [while_label];<br></code></pre></td></tr></table></figure>

<p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直 至循环条件为假，退出循环。</p>
<ul>
<li>举例1：WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE test_while()<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    WHILE i &lt; 10 DO<br>    	SET i = i + 1;<br>    END WHILE;<br>    SELECT i;<br>END //<br>DELIMITER ;<br>#调用<br>CALL test_while();<br></code></pre></td></tr></table></figure>

<ul>
<li>举例2：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程 “update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降 为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE update_salary_while(OUT num INT)<br>BEGIN<br>    DECLARE avg_sal DOUBLE ;<br>    DECLARE while_count INT DEFAULT 0;<br>    SELECT AVG(salary) INTO avg_sal FROM employees;<br>    WHILE avg_sal &gt; 5000 DO<br>        UPDATE employees SET salary = salary * 0.9;<br>        SET while_count = while_count + 1;<br>        SELECT AVG(salary) INTO avg_sal FROM employees;<br>    END WHILE;<br>    SET num = while_count;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h3 id="5-循环结构之REPEAT"><a href="#5-循环结构之REPEAT" class="headerlink" title="5) 循环结构之REPEAT"></a>5) 循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">[repeat_label:] REPEAT<br>循环体的语句<br>UNTIL 结束循环的条件表达式<br>END REPEAT [repeat_label]<br></code></pre></td></tr></table></figure>

<p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至 expr_condition为真。</p>
<p>举例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE test_repeat()<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    REPEAT<br>    	SET i = i + 1;<br>    UNTIL i &gt;= 10<br>    END REPEAT;<br>    SELECT i;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程 “update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨 为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE update_salary_repeat(OUT num INT)<br>BEGIN<br>    DECLARE avg_sal DOUBLE ;<br>    DECLARE repeat_count INT DEFAULT 0;<br>    SELECT AVG(salary) INTO avg_sal FROM employees;<br>    REPEAT<br>    	UPDATE employees SET salary = salary * 1.15;<br>    	SET repeat_count = repeat_count + 1;<br>    	SELECT AVG(salary) INTO avg_sal FROM employees;<br>    UNTIL avg_sal &gt;= 13000<br>    END REPEAT;<br>    SET num = repeat_count;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<ol>
<li><p>这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。 </p>
</li>
<li><p>LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 </p>
</li>
<li><p>REPEAT：先执行后判断，无条件至少执行一次</p>
</li>
</ol>
<h3 id="6-跳转语句之LEAVE语句"><a href="#6-跳转语句之LEAVE语句" class="headerlink" title="6) 跳转语句之LEAVE语句"></a>6) 跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
<p>基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">LEAVE 标记名<br></code></pre></td></tr></table></figure>

<p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p>
<p>举例1：创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在 BEGIN…END中使用IF语句判断num参数的值。</p>
<p>如果num&lt;&#x3D;0，则使用LEAVE语句退出BEGIN…END； 如果num&#x3D;1，则查询“employees”表的平均薪资； 如果num&#x3D;2，则查询“employees”表的最低薪资； 如果num&gt;2，则查询“employees”表的最高薪资。</p>
<p>IF语句结束后查询“employees”表的总人数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE leave_begin(IN num INT)<br>    begin_label: BEGIN<br>        IF num&lt;=0<br>        	THEN LEAVE begin_label;<br>        ELSEIF num=1<br>        	THEN SELECT AVG(salary) FROM employees;<br>        ELSEIF num=2<br>        	THEN SELECT MIN(salary) FROM employees;<br>        ELSE<br>        	SELECT MAX(salary) FROM employees;<br>        END IF;<br>        SELECT COUNT(*) FROM employees;<br>    END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>举例2： 当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明 OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE leave_while(OUT num INT)<br>BEGIN<br>    DECLARE avg_sal DOUBLE;#记录平均工资<br>    DECLARE while_count INT DEFAULT 0; #记录循环次数<br>    SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件<br>    while_label:WHILE TRUE DO #② 循环条件<br>    #③ 循环体<br>    IF avg_sal &lt;= 10000 THEN<br>    LEAVE while_label;<br>    END IF;<br>    UPDATE employees SET salary = salary * 0.9;<br>    SET while_count = while_count + 1;<br>    #④ 迭代条件<br>    SELECT AVG(salary) INTO avg_sal FROM employees;<br>    END WHILE;<br>    #赋值<br>    SET num = while_count;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h3 id="7-跳转语句之ITERATE语句"><a href="#7-跳转语句之ITERATE语句" class="headerlink" title="7) 跳转语句之ITERATE语句"></a>7) 跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ITERATE label<br></code></pre></td></tr></table></figure>

<p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p>
<p>举例： 定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p>
<ul>
<li>如果num &lt; 10，则继续执行循环；</li>
<li>如果num &gt; 15，则退出循环结构；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE test_iterate()<br>BEGIN<br>    DECLARE num INT DEFAULT 0;<br>    my_loop:LOOP<br>    	SET num = num + 1;<br>        IF num &lt; 10<br>        	THEN ITERATE my_loop;<br>        ELSEIF num &gt; 15<br>        	THEN LEAVE my_loop;<br>        END IF;<br>        SELECT &#x27;MySQL&#x27;;<br>    END LOOP my_loop;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<h2 id="4-游标"><a href="#4-游标" class="headerlink" title="4. 游标"></a>4. 游标</h2><h3 id="1-什么是游标（或光标）"><a href="#1-什么是游标（或光标）" class="headerlink" title="1)  什么是游标（或光标）"></a>1)  什么是游标（或光标）</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一 条记录 ，并对记录的数据进行处理。</p>
<p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</p>
<p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了 指针的作用 ，我们可以通过操作游标来对数据行进行操作。</p>
<p>MySQL中游标可以在存储过程和函数中使用。 </p>
<h3 id="2-使用游标步骤"><a href="#2-使用游标步骤" class="headerlink" title="2) 使用游标步骤"></a>2) 使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。 </p>
<p>如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p><strong>第一步，声明游标</strong></p>
<p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE cursor_name CURSOR FOR select_statement;<br></code></pre></td></tr></table></figure>

<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE cursor_name CURSOR IS select_statement;<br></code></pre></td></tr></table></figure>

<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DECLARE cur_emp CURSOR FOR<br>SELECT employee_id,salary FROM employees;<br></code></pre></td></tr></table></figure>

<p><strong>第二步，打开游标</strong></p>
<p>打开游标的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">OPEN cursor_name<br></code></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">OPEN cur_emp;<br></code></pre></td></tr></table></figure>

<p><strong>第三步，使用游标（从游标中取得数据）</strong></p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">FETCH cursor_name INTO var_name [, var_name] ...<br></code></pre></td></tr></table></figure>

<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p>注意：var_name必须在声明游标之前就定义好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">FETCH cur_emp INTO emp_id, emp_sal ;<br></code></pre></td></tr></table></figure>

<p>注意：<strong>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时 候，MySQL 会提示错误。</p>
<p><strong>第四步，关闭游标</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CLOSE cursor_name<br></code></pre></td></tr></table></figure>

<p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会 占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标 的操作，会释放游标占用的系统资源。</p>
<p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CLOSE cur_emp;<br></code></pre></td></tr></table></figure>

<h3 id="3-举例"><a href="#3-举例" class="headerlink" title="3) 举例"></a>3) 举例</h3><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明 OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE, OUT total_count INT)<br>BEGIN<br>	DECLARE sum_salary DOUBLE DEFAULT 0; # 记录累加的总工资<br>	DECLARE cursor_salary DOUBLE DEFAULT 0; # 记录某一个工资值<br>	DECLARE emp_count INT DEFAULT 0; # 记录循环个数<br>	# 定义游标<br>	DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;<br>	# 打开游标<br>	OPEN emp_cursor;<br>	<br>	REPEAT<br>		# 使用游标(从游标中获取数据)<br>		FETCH emp_cursor INTO cursor_salary;<br>		SET sum_salary = sum_salary + cursor_salary;<br>		SET emp_count = emp_count + 1;<br>		UNTIL sum_salary &gt;= limit_total_salary<br>	END REPEAT;<br>	set total_count = emp_count;<br>	# 关闭游标<br>	CLOSE emp_cursor;<br>END //<br>DELIMITER;<br></code></pre></td></tr></table></figure>

<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4) 小结"></a>4) 小结</h3><p>游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。 </p>
<p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大 的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足，这是因为游标是在内存中进行的处理。 </p>
<p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p>
<h2 id="补充：MySQL-8-0的新特性—全局变量的持久化"><a href="#补充：MySQL-8-0的新特性—全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性—全局变量的持久化"></a>补充：MySQL 8.0的新特性—全局变量的持久化</h2><p>在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可 以通过设置系统变量max_execution_time来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL MAX_EXECUTION_TIME=2000;<br></code></pre></td></tr></table></figure>

<p>使用SET GLOBAL语句设置的变量值只会 临时生效 。 数据库重启 后，服务器又会从MySQL配置文件中读取 变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令。例如，设置服务器的最大连接数为1000：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET PERSIST global max_connections = 1000;<br></code></pre></td></tr></table></figure>

<p>MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p>
<h1 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章_触发器"></a>第17章_触发器</h1><p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分 别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时 在库存表中添加一条库存记录。 </p>
<p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操 作成为一个 原子操作 ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。 </p>
<p>这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p>
<h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><p>触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会 自动 激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1) 语法"></a>1) 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER 触发器名称<br>&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名<br>FOR EACH ROW<br>触发器执行的语句块<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>表名 ：表示触发器监控的对象。 </li>
<li>BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。 </li>
<li>INSERT|UPDATE|DELETE ：表示触发的事件。<ul>
<li>INSERT 表示插入记录时触发； </li>
<li>UPDATE 表示更新记录时触发； </li>
<li>DELETE 表示删除记录时触发。</li>
</ul>
</li>
<li>触发器执行的语句块 ：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</li>
</ul>
<h3 id="2-代码举例-2"><a href="#2-代码举例-2" class="headerlink" title="2) 代码举例"></a>2) 代码举例</h3><p><strong>举例1：</strong></p>
<ol>
<li>创建数据表：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_trigger (<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>t_note VARCHAR(30)<br>);<br><br>CREATE TABLE test_trigger_log (<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>t_log VARCHAR(30)<br>);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向 test_trigger_log数据表中插入before_insert的日志信息。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE TRIGGER before_insert<br>BEFORE INSERT ON test_trigger<br>FOR EACH ROW<br>BEGIN<br>    INSERT INTO test_trigger_log (t_log)<br>    VALUES(&#x27;before_insert&#x27;);<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>向test_trigger数据表中插入数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 BEFORE INSERT 触发器&#x27;);<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>查看test_trigger_log数据表中的数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_trigger_log;<br>+----+---------------+<br>| id | t_log |<br>+----+---------------+<br>| 1 | before_insert |<br>+----+---------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p><strong>举例2：</strong></p>
<p>定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查 将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错 误，从而使得添加失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE TRIGGER salary_check_trigger<br>BEFORE INSERT ON employees FOR EACH ROW<br>BEGIN<br>    DECLARE mgrsalary DOUBLE;<br>    SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id;<br>    IF NEW.salary &gt; mgrsalary THEN<br>    	SIGNAL SQLSTATE &#x27;HY000&#x27; SET MESSAGE_TEXT = &#x27;薪资高于领导薪资错误&#x27;;<br>    END IF;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。</p>
<h2 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h2><h3 id="1-查看触发器"><a href="#1-查看触发器" class="headerlink" title="1)  查看触发器"></a>1)  查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<p>方式1：查看当前数据库的所有触发器的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS\G<br></code></pre></td></tr></table></figure>

<p>方式2：查看当前数据库中某个触发器的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SHOW CREATE TRIGGER 触发器名<br></code></pre></td></tr></table></figure>

<p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.TRIGGERS;<br></code></pre></td></tr></table></figure>

<h3 id="2-删除触发器"><a href="#2-删除触发器" class="headerlink" title="2) 删除触发器"></a>2) 删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP TRIGGER IF EXISTS 触发器名称;<br></code></pre></td></tr></table></figure>

<h2 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h2><h3 id="1-优点-2"><a href="#1-优点-2" class="headerlink" title="1) 优点"></a>1) 优点</h3><p><strong>1、触发器可以确保数据的完整性。</strong></p>
<p>假设我们用 进货单头表 （demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。</p>
<table>
<thead>
<tr>
<th>listnumber                  (进货单编号)</th>
<th>supplierid                 (进货商编号)</th>
<th>stockid             (参库编号)</th>
<th>quantity            (总计数量)</th>
<th>importvalue           (总计金额)</th>
<th>confirmationdate        （验收日期)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>用进货单明细表 （demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数 量、进货价格和进货金额。</p>
<table>
<thead>
<tr>
<th>listnumber                          (进货单编号)</th>
<th>itemnumber                      (商品编号)</th>
<th>quantity                     (进货数量)</th>
<th>importprice                     (进货价格)</th>
<th>importvalue                   （进货金额)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金 额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。</p>
<p>为了解决这个问题，我们就可以使用触发器，规定每当进货单明细表有数据插入、修改和删除的操作 时，自动触发 2 步操作：</p>
<p>1）重新计算进货单明细表中的数量合计和金额合计；</p>
<p>2）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。</p>
<p>这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与 合计金额的值相同，数据就是一致的，不会互相矛盾。</p>
<p><strong>2、触发器可以帮助我们记录操作日志。</strong></p>
<p>利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</p>
<p><strong>3、触发器还可以用在操作数据前，对数据进行合法性检查。</strong></p>
<p>比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏…… 这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。</p>
<h3 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2) 缺点"></a>2) 缺点</h3><p><strong>1、触发器最大的一个问题就是可读性差。</strong></p>
<p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制 。这对系统维护是非常有挑战的。</p>
<p><strong>2、相关数据的变更，可能会导致触发器出错。</strong></p>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
<h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3) 注意点"></a>3) 注意点</h3><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE&#x2F;DELETE CASCADE&#x2F;SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
<p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee） 有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL， mysql&gt; update demo.membermaster set memberdeposit&#x3D;20 where memberid &#x3D; 2; ERROR 1054 (42S22): Unknown column ‘aa’ in ‘field list’ 但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器 t1。</p>
<h1 id="第18章-MySQL8其他新特性"><a href="#第18章-MySQL8其他新特性" class="headerlink" title="第18章_MySQL8其他新特性"></a>第18章_MySQL8其他新特性</h1><h2 id="1-MySQL8新特性概述"><a href="#1-MySQL8新特性概述" class="headerlink" title="1. MySQL8新特性概述"></a>1. MySQL8新特性概述</h2><p>MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<h3 id="1-MySQL8-0-新增特性"><a href="#1-MySQL8-0-新增特性" class="headerlink" title="1) MySQL8.0 新增特性"></a>1) MySQL8.0 新增特性</h3><ol>
<li><p>更简便的NoSQL支持 NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统 的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。 MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。 </p>
</li>
<li><p>更好的索引 在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了 隐藏索引 和 降序索 引 。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引 可以提高查询的性能。 </p>
</li>
<li><p>更完善的JSON支持 MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加 了聚合函数 JSON_ARRAYAGG() 和 JSON_OBJECTAGG() ，将参数聚合为JSON数组或对象，新增了行内 操作符 -&gt;&gt;，是列路径运算符 -&gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。 </p>
</li>
<li><p>安全和账户管理 MySQL 8中新增了 caching_sha2_password 授权插件、角色、密码历史记录和FIPS 模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。 </p>
</li>
<li><p>InnoDB的变化 InnoDB是MySQL默认的存储引擎 ，是事务型数据库的首选引擎，支持事务安全表 （ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面 做了大量的 改进和优化 ，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的 支持。</p>
</li>
<li><p>数据字典 在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增 了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。 </p>
</li>
<li><p>原子数据定义语句 MySQL 8开始支持原子数据定义语句（Automic DDL），即 原子DDL 。目前，只有 InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎 操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。 使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操 作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL 5.7复制到MySQL 8 版本中的语句，可以添加 IF EXISTS 或 IF NOT EXISTS 语句来避免发生错误。 </p>
</li>
<li><p>资源管理 MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便 线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够 根据不同的工作负载适当地更改这些属性。 目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表 示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有 对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。 资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户 组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的 属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些MySQL的配 置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS 系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统 中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。</p>
</li>
<li><p>字符集支持 MySQL 8中默认的字符集由 latin1 更改为 utf8mb4 ，并首次增加了日语所特定使用的集 合，utf8mb4_ja_0900_as_cs。 </p>
</li>
<li><p>优化器增强 MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必 要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许 优化器对多个列进行排序，并且允许排序顺序不一致。 </p>
</li>
<li><p>公用表表达式 公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递 归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前 使用WITH语句对临时结果集 进行命名。</p>
<p>基础语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">    WITH cte_name (col_name1,col_name2 ...) AS (Subquery)<br>    SELECT * FROM cte_name;<br><br>​		Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用 cte_name进行查询。<br><br>12. 窗口函数 MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分 聚合函数 在MySQL 8中也可以 作为窗口函数来使用。<br><br>![image-20220613202507072](https://s2.loli.net/2024/02/24/kgvKV9FcYX1nIR7.png)<br><br>13. 正则表达式支持 MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作， 这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、 EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和 regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。<br>14. 内部临时表 TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎 。TempTable存储 引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部 临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。 temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。<br>15. 日志记录 在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量 log_error_services来配置，能够实现日志事件的过滤和写入。 WITH cte_name (col_name1,col_name2 ...) AS (Subquery) SELECT * FROM cte_name; <br>16. 备份锁 新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新 备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理 员特权。 <br>17. 增强的MySQL复制 MySQL 8复制支持对 JSON文档 进行部分更新的 二进制日志记录 ，该记录 使用紧凑 的二进制格式 ，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记 录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。<br><br>### 2) MySQL8.0 移除的旧特性<br><br>在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同 的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽 可能使用替代方法。<br><br>1. 查询缓存 查询缓存已被移除 ，删除的项有： （1）语句：FLUSH QUERY CACHE和RESET QUERY CACHE。 （2）系统变量：query_cache_limit、query_cache_min_res_unit、query_cache_size、 query_cache_type、query_cache_wlock_invalidate。 （3）状态变量：Qcache_free_blocks、 Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、 Qcache_queries_in_cache、Qcache_total_blocks。 （4）线程状态：checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。<br>2. 加密相关 删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和 DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项， HAVE_CRYPT CMake选项。 对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使 用AES_ENCRYPT()和AES_DECRYPT()替代。 <br>3. 空间函数相关 在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被 移除，只保留了对应的ST_和MBR函数。 <br>4. \N和NULL 在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化 不会影响使用LOAD DATA INFILE或者SELECT...INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL 仍等同于\N。 <br>5. mysql_install_db 在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着-- initialize或者--initialize-insecure选项的mysqld来代替实现。另外，--bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。 <br>6. 通用分区处理程序 通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存 储引擎需要自有的分区处理程序。 提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在 MySQL 8中只支持InnoDB。 <br>7. 系统和状态变量信息 在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。 GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系 统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、 Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除 的内容都可使用性能模式中对应的内容进行替代。 <br>8. mysql_plugin工具 mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用--plugin-load或- -plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该 工具。<br><br>## 2. 新特性1：窗口函数<br><br>### 1) 使用窗口函数前后对比<br><br>假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：<br><br>```mysql<br>CREATE TABLE sales(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>city VARCHAR(15),<br>county VARCHAR(15),<br>sales_value DECIMAL<br>);<br>INSERT INTO sales(city,county,sales_value)<br>VALUES<br>(&#x27;北京&#x27;,&#x27;海淀&#x27;,10.00),<br>(&#x27;北京&#x27;,&#x27;朝阳&#x27;,20.00),<br>(&#x27;上海&#x27;,&#x27;黄埔&#x27;,30.00),<br>(&#x27;上海&#x27;,&#x27;长宁&#x27;,10.00);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM sales;<br>+----+------+--------+-------------+<br>| id | city | county | sales_value |<br>+----+------+--------+-------------+<br>| 1  | 北京  |  海淀   |      10    |<br>| 2  | 北京  |  朝阳   |      20    |<br>| 3  | 上海  |  黄埔   |      30    |<br>| 4  | 上海  |  长宁   |      10    |<br>+----+------+--------+-------------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>需求：现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</p>
<p>如果用分组和聚合函数，就需要分好几步来计算。</p>
<p>第一步，计算总销售金额，并存入临时表 a：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TEMPORARY TABLE a -- 创建临时表<br>SELECT SUM(sales_value) AS sales_value -- 计算总计金额<br>FROM sales;<br></code></pre></td></tr></table></figure>

<p>查看一下临时表 a ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM a;<br>+-------------+<br>| sales_value |<br>+-------------+<br>| 70 |<br>+-------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>第二步，计算每个城市的销售总额并存入临时表 b：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TEMPORARY TABLE b -- 创建临时表<br>SELECT city, SUM(sales_value) AS sales_value -- 计算城市销售合计<br>FROM sales<br>GROUP BY city;<br></code></pre></td></tr></table></figure>

<p>查看临时表 b ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM b;<br>+------+-------------+<br>| city | sales_value |<br>+------+-------------+<br>| 北京  |     30      |<br>| 上海  |     40      |<br>+------+-------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。我们可以通过下面的连接查询获得需要的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT s.city AS 城市,s.county AS 区,s.sales_value AS 区销售额,<br>-&gt; b.sales_value AS 市销售额,s.sales_value/b.sales_value AS 市比率,<br>-&gt; a.sales_value AS 总销售额,s.sales_value/a.sales_value AS 总比率<br>-&gt; FROM sales s<br>-&gt; JOIN b ON (s.city=b.city) -- 连接市统计结果临时表<br>-&gt; JOIN a -- 连接总计金额临时表<br>-&gt; ORDER BY s.city,s.county;<br>+------+------+----------+----------+--------+----------+--------+<br>| 城市 | 区 | 区销售额 | 市销售额 | 市比率 | 总销售额 | 总比率 |<br>+------+------+----------+----------+--------+----------+--------+<br>| 上海 | 长宁 | 10 | 40 | 0.2500 | 70 | 0.1429 |<br>| 上海 | 黄埔 | 30 | 40 | 0.7500 | 70 | 0.4286 |<br>| 北京 | 朝阳 | 20 | 30 | 0.6667 | 70 | 0.2857 |<br>| 北京 | 海淀 | 10 | 30 | 0.3333 | 70 | 0.1429 |<br>+------+------+----------+----------+--------+----------+--------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。</p>
<p>同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT city AS 城市,county AS 区,sales_value AS 区销售额,<br>-&gt; SUM(sales_value) OVER(PARTITION BY city) AS 市销售额, -- 计算市销售额<br>-&gt; sales_value/SUM(sales_value) OVER(PARTITION BY city) AS 市比率,<br>-&gt; SUM(sales_value) OVER() AS 总销售额, -- 计算总销售额<br>-&gt; sales_value/SUM(sales_value) OVER() AS 总比率<br>-&gt; FROM sales<br>-&gt; ORDER BY city,county;<br>+------+------+----------+----------+--------+----------+--------+<br>| 城市 | 区 | 区销售额 | 市销售额 | 市比率 | 总销售额 | 总比率 |<br>+------+------+----------+----------+--------+----------+--------+<br>| 上海 | 长宁 | 10 | 40 | 0.2500 | 70 | 0.1429 |<br>| 上海 | 黄埔 | 30 | 40 | 0.7500 | 70 | 0.4286 |<br>| 北京 | 朝阳 | 20 | 30 | 0.6667 | 70 | 0.2857 |<br>| 北京 | 海淀 | 10 | 30 | 0.3333 | 70 | 0.1429 |<br>+------+------+----------+-----------+--------+----------+--------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>结果显示，我们得到了与上面那种查询同样的结果。 </p>
<p>使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显 然，在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好。</p>
<h3 id="2-窗口函数分类"><a href="#2-窗口函数分类" class="headerlink" title="2) 窗口函数分类"></a>2) 窗口函数分类</h3><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p>
<p>窗口函数可以分为 静态窗口函数 和 动态窗口函数 。</p>
<ul>
<li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li>
<li>动态窗口函数的窗口大小会随着记录的不同而变化。</li>
</ul>
<p>MySQL官方网站窗口函数的网址为<a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptio">https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptio</a> ns.html#function_row-number。 </p>
<p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：</p>
<p><img src="https://s2.loli.net/2024/02/24/eoZwGW9SLPUzAu2.png" alt="image-20220613210116486"></p>
<h3 id="3-语法结构"><a href="#3-语法结构" class="headerlink" title="3) 语法结构"></a>3) 语法结构</h3><p>窗口函数的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）<br></code></pre></td></tr></table></figure>

<p>或者是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）<br></code></pre></td></tr></table></figure>

<ul>
<li>OVER 关键字指定函数窗口的范围。<ul>
<li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li>
<li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li>
</ul>
</li>
<li>窗口名：为窗口设置一个别名，用来标识窗口。</li>
<li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li>
<li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li>
<li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li>
</ul>
<h3 id="4-分类讲解"><a href="#4-分类讲解" class="headerlink" title="4) 分类讲解"></a>4) 分类讲解</h3><p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE goods(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>category_id INT,<br>category VARCHAR(15),<br>NAME VARCHAR(30),<br>price DECIMAL(10,2),<br>stock INT,<br>upper_time DATETIME<br>);<br></code></pre></td></tr></table></figure>

<p>添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO goods(category_id,category,NAME,price,stock,upper_time)<br>VALUES<br>(1, &#x27;女装/女士精品&#x27;, &#x27;T恤&#x27;, 39.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;连衣裙&#x27;, 79.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;卫衣&#x27;, 89.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;牛仔裤&#x27;, 89.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;百褶裙&#x27;, 29.90, 500, &#x27;2020-11-10 00:00:00&#x27;),<br>(1, &#x27;女装/女士精品&#x27;, &#x27;呢绒外套&#x27;, 399.90, 1200, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;自行车&#x27;, 399.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;山地自行车&#x27;, 1399.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;登山杖&#x27;, 59.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;骑行装备&#x27;, 399.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;运动外套&#x27;, 799.90, 500, &#x27;2020-11-10 00:00:00&#x27;),<br>(2, &#x27;户外运动&#x27;, &#x27;滑板&#x27;, 499.90, 1200, &#x27;2020-11-10 00:00:00&#x27;);<br></code></pre></td></tr></table></figure>

<p>下面针对goods表中的数据来验证每个窗口函数的功能。</p>
<h4 id="1-序号函数"><a href="#1-序号函数" class="headerlink" title="1) 序号函数"></a>1) 序号函数</h4><p><strong>1. ROW_NUMBER()函数</strong></p>
<p>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。</p>
<p>举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS<br>row_num, id, category_id, category, NAME, price, stock<br>FROM goods;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>| row_num | id | category_id |    category   |     NAME   |  price  | stock |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|    1    |  6 |     1       |  女装/女士精品  | 呢绒外套     | 399.90  | 1200  |<br>|    2    |  3 |     1       |  女装/女士精品  | 卫衣        | 89.90   | 1500  |<br>|    3    |  4 |     1       |  女装/女士精品  | 牛仔裤       | 89.90   | 3500  |<br>|    4    |  2 |     1       |  女装/女士精品  | 连衣裙       | 79.90   | 2500  |<br>|    5    |  1 |     1       |  女装/女士精品  | T恤         | 39.90   | 1000  |<br>|    6    |  5 |     1       |  女装/女士精品  | 百褶裙       | 29.90   | 500   |<br>|    1    |  8 |     2       |     户外运动   | 山地自行车    | 1399.90 | 2500  |<br>|    2    | 11 |     2       |     户外运动   | 运动外套      | 799.90  | 500  |<br>|    3    | 12 |     2       |     户外运动   | 滑板         | 499.90  | 1200  |<br>|    4    |  7 |     2       |     户外运动   | 自行车       | 399.90  | 1000  |<br>|    5    | 10 |     2       |     户外运动   | 骑行装备     | 399.90  | 3500  |<br>|    6    |  9 |     2       |     户外运动   | 登山杖       | 59.90   | 1500  |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>举例：查询 goods 数据表中每个商品分类下价格最高的3种商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT *<br>-&gt; FROM (<br>-&gt; SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS<br>row_num,<br>-&gt; id, category_id, category, NAME, price, stock<br>-&gt; FROM goods) t<br>-&gt; WHERE row_num &lt;= 3;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>| row_num | id | category_id |     category  |      NAME  |  price  | stock |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|     1   |  6 |      1      | 女装/女士精品   | 呢绒外套     | 399.90  | 1200  |<br>|     2   |  3 |      1      | 女装/女士精品   | 卫衣        | 89.90   | 1500  |<br>|     3   |  4 |      1      | 女装/女士精品   | 牛仔裤      | 89.90    | 3500 |<br>|     1   |  8 |      2      | 户外运动       | 山地自行车   | 1399.90  | 2500 |<br>|     2   | 11 |      2      | 户外运动       | 运动外套     | 799.90  | 500   |<br>|     3   | 12 |      2      | 户外运动       | 滑板        | 499.90   | 1200 |<br>+---------+----+-------------+---------------+------------+----------+-------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>在名称为“女装&#x2F;女士精品”的商品类别中，有两款商品的价格为89.90元，分别是卫衣和牛仔裤。两款商品 的序号都应该为2，而不是一个为2，另一个为3。此时，可以使用RANK()函数和DENSE_RANK()函数解 决。</p>
<p><strong>2．RANK()函数</strong></p>
<p>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3。 </p>
<p>举例：使用RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,<br>-&gt; id, category_id, category, NAME, price, stock<br>-&gt; FROM goods;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>| row_num | id | category_id | category      | NAME       | price   | stock |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|     1   | 6  |     1       | 女装/女士精品   | 呢绒外套     | 399.90  | 1200  |<br>|     2   | 3  |     1       | 女装/女士精品   | 卫衣        | 89.90   | 1500  |<br>|     2   | 4  |     1       | 女装/女士精品   | 牛仔裤      | 89.90   | 3500   |<br>|     4   | 2  |     1       | 女装/女士精品   | 连衣裙      | 79.90   | 2500   |<br>|     5   | 1  |     1       | 女装/女士精品   | T恤        | 39.90   | 1000   |<br>|     6   | 5  |     1       | 女装/女士精品   | 百褶裙      | 29.90   | 500    |<br>|     1   | 8  |     2       | 户外运动       | 山地自行车   | 1399.90 | 2500   |<br>|     2   | 11 |     2       | 户外运动       | 运动外套     | 799.90  | 500   |<br>|     3   | 12 |     2       | 户外运动       | 滑板        | 499.90  | 1200   |<br>|     4   | 7  |     2       | 户外运动       | 自行车      | 399.90   | 1000  |<br>|     4   | 10 |     2       | 户外运动       | 骑行装备    | 399.90   | 3500  |<br>|     6   | 9  |     2       | 户外运动       | 登山杖      | 59.90   | 1500   |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p><strong>3．DENSE_RANK()函数</strong></p>
<p>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。 举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS<br>row_num,<br>-&gt; id, category_id, category, NAME, price, stock<br>-&gt; FROM goods;<br>+---------+----+-------------+---------------+------------+---------+-------+<br>| row_num | id | category_id | category      | NAME       | price   | stock |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>|    1    | 6  |      1      | 女装/女士精品   |     呢绒外套 | 399.90 | 1200   |<br>|    2    | 3  |      1      | 女装/女士精品   |     卫衣    | 89.90  | 1500   |<br>|    2    | 4  |      1      | 女装/女士精品   |     牛仔裤  | 89.90   | 3500  |<br>|    3    | 2  |      1      | 女装/女士精品   |     连衣裙  | 79.90   | 2500  |<br>|    4    | 1  |      1      | 女装/女士精品   |     T恤    | 39.90   | 1000  |<br>|    5    | 5  |      1      | 女装/女士精品   |     百褶裙  | 29.90   | 500   |<br>|    1    | 8  |      2      | 户外运动       |    山地自行车| 1399.90 | 2500 |<br>|    2    | 11 |      2      | 户外运动       |    运动外套  | 799.90 | 500    |<br>|    3    | 12 |      2      | 户外运动       |    滑板     | 499.90 | 1200   |<br>|    4    | 7  |      2      | 户外运动       |    自行车    | 399.90 | 1000   |<br>|    4    | 10 |      2      | 户外运动       |    骑行装备  | 399.90 | 3500   |<br>|    5    | 9  |      2      | 户外运动       |    登山杖    | 59.90 | 1500   |<br>+---------+----+-------------+---------------+------------+---------+-------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<h4 id="2-分布函数"><a href="#2-分布函数" class="headerlink" title="2) 分布函数"></a>2) 分布函数</h4><p><strong>1．PERCENT_RANK()函数</strong></p>
<p>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">(rank - 1) / (rows - 1)<br></code></pre></td></tr></table></figure>

<p>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</p>
<p>举例：计算 goods 数据表中名称为“女装&#x2F;女士精品”的类别下的商品的PERCENT_RANK值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#写法一：<br>SELECT RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS r,<br>PERCENT_RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS pr,<br>id, category_id, category, NAME, price, stock<br>FROM goods<br>WHERE category_id = 1;<br>#写法二：<br>mysql&gt; SELECT RANK() OVER w AS r,<br>-&gt; PERCENT_RANK() OVER w AS pr,<br>-&gt; id, category_id, category, NAME, price, stock<br>-&gt; FROM goods<br>-&gt; WHERE category_id = 1 WINDOW w AS (PARTITION BY category_id ORDER BY price<br>DESC);<br>+---+-----+----+-------------+---------------+----------+--------+-------+<br>| r | pr  | id | category_id | category      | NAME     | price  | stock |<br>+---+-----+----+-------------+---------------+----------+--------+-------+<br>| 1 | 0   | 6  |          1  | 女装/女士精品   |   呢绒外套 | 399.90 | 1200 |<br>| 2 | 0.2 | 3  |          1  | 女装/女士精品   |   卫衣    | 89.90 | 1500 |<br>| 2 | 0.2 | 4  |          1  | 女装/女士精品   |   牛仔裤  | 89.90 | 3500 |<br>| 4 | 0.6 | 2  |          1  | 女装/女士精品   |   连衣裙  | 79.90 | 2500 |<br>| 5 | 0.8 | 1  |          1  | 女装/女士精品   |   T恤    | 39.90 | 1000 |<br>| 6 | 1   | 5  |          1  | 女装/女士精品   |   百褶裙  | 29.90 | 500 |<br>+---+-----+----+-------------+---------------+----------+--------+-------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p><strong>2．CUME_DIST()函数</strong></p>
<p>CUME_DIST()函数主要用于查询小于或等于某个值的比例。 </p>
<p>举例：查询goods数据表中小于或等于当前价格的比例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT CUME_DIST() OVER(PARTITION BY category_id ORDER BY price ASC) AS cd,<br>-&gt; id, category, NAME, price<br>-&gt; FROM goods;<br>+---------------------+----+---------------+------------+---------+<br>|                cd   | id | category      | NAME       | price   |<br>+---------------------+----+---------------+------------+---------+<br>| 0.16666666666666666 | 5  | 女装/女士精品   | 百褶裙      | 29.90 |<br>| 0.3333333333333333  | 1  | 女装/女士精品   | T恤        | 39.90 |<br>| 0.5                 | 2  | 女装/女士精品   | 连衣裙      | 79.90 |<br>| 0.8333333333333334  | 3  | 女装/女士精品   | 卫衣       | 89.90 |<br>| 0.8333333333333334  | 4  | 女装/女士精品   | 牛仔裤     | 89.90 |<br>| 1                   | 6  | 女装/女士精品   | 呢绒外套    | 399.90 |<br>| 0.16666666666666666 | 9  | 户外运动       | 登山杖      | 59.90 |<br>| 0.5                 | 7  | 户外运动       | 自行车      | 399.90 |<br>| 0.5                 | 10 | 户外运动       | 骑行装备     | 399.90 |<br>| 0.6666666666666666  | 12 | 户外运动       | 滑板        | 499.90 |<br>| 0.8333333333333334  | 11 | 户外运动       | 运动外套     | 799.90 |<br>| 1                   | 8  | 户外运动       | 山地自行车   | 1399.90 |<br>+---------------------+----+---------------+------------+---------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<h4 id="3-前后函数"><a href="#3-前后函数" class="headerlink" title="3) 前后函数"></a>3) 前后函数</h4><p><strong>1．LAG(expr,n)函数</strong></p>
<p>LAG(expr,n)函数返回当前行的前n行的expr的值。 </p>
<p>举例：查询goods数据表中前一个商品价格与当前商品价格的差值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price<br>-&gt; FROM (<br>-&gt; SELECT id, category, NAME, price,LAG(price,1) OVER w AS pre_price<br>-&gt; FROM goods<br>-&gt; WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;<br>+----+---------------+------------+---------+-----------+------------+<br>| id | category | NAME | price | pre_price | diff_price |<br>+----+---------------+------------+---------+-----------+------------+<br>| 5 | 女装/女士精品 | 百褶裙 | 29.90 | NULL | NULL |<br>| 1 | 女装/女士精品 | T恤 | 39.90 | 29.90 | 10.00 |<br>| 2 | 女装/女士精品 | 连衣裙 | 79.90 | 39.90 | 40.00 |<br>| 3 | 女装/女士精品 | 卫衣 | 89.90 | 79.90 | 10.00 |<br>| 4 | 女装/女士精品 | 牛仔裤 | 89.90 | 89.90 | 0.00 |<br>| 6 | 女装/女士精品 | 呢绒外套 | 399.90 | 89.90 | 310.00 |<br>| 9 | 户外运动 | 登山杖 | 59.90 | NULL | NULL |<br>| 7 | 户外运动 | 自行车 | 399.90 | 59.90 | 340.00 |<br>| 10 | 户外运动 | 骑行装备 | 399.90 | 399.90 | 0.00 |<br>| 12 | 户外运动 | 滑板 | 499.90 | 399.90 | 100.00 |<br>| 11 | 户外运动 | 运动外套 | 799.90 | 499.90 | 300.00 |<br>| 8 | 户外运动 | 山地自行车 | 1399.90 | 799.90 | 600.00 |<br>+----+---------------+------------+---------+-----------+------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p><strong>2．LEAD(expr,n)函数</strong></p>
<p>LEAD(expr,n)函数返回当前行的后n行的expr的值。 </p>
<p>举例：查询goods数据表中后一个商品价格与当前商品价格的差值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, behind_price, price,behind_price - price AS<br>diff_price<br>-&gt; FROM(<br>-&gt; SELECT id, category, NAME, price,LEAD(price, 1) OVER w AS behind_price<br>-&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;<br>+----+---------------+------------+--------------+---------+------------+<br>| id | category      | NAME       | behind_price | price   | diff_price |<br>+----+---------------+------------+--------------+---------+------------+<br>| 5  | 女装/女士精品   | 百褶裙       | 39.90       | 29.90 | 10.00 |<br>| 1  | 女装/女士精品   | T恤         | 79.90       | 39.90 | 40.00 |<br>| 2  | 女装/女士精品   | 连衣裙      | 89.90        | 79.90 | 10.00 |<br>| 3  | 女装/女士精品   | 卫衣        | 89.90       | 89.90 | 0.00 |<br>| 4  | 女装/女士精品   | 牛仔裤       | 399.90     | 89.90 | 310.00 |<br>| 6  | 女装/女士精品   | 呢绒外套     | NULL       | 399.90 | NULL |<br>| 9  | 户外运动       | 登山杖       | 399.90    | 59.90 | 340.00 |<br>| 7  | 户外运动       | 自行车       | 399.90    | 399.90 | 0.00 |<br>| 10 | 户外运动       | 骑行装备     | 499.90     | 399.90 | 100.00 |<br>| 12 | 户外运动       | 滑板         | 799.90    | 499.90 | 300.00 |<br>| 11 | 户外运动       | 运动外套     | 1399.90    | 799.90 | 600.00 |<br>| 8  | 户外运动       | 山地自行车   | NULL       | 1399.90 | NULL |<br>+----+---------------+------------+--------------+---------+------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<h4 id="4-首尾函数"><a href="#4-首尾函数" class="headerlink" title="4) 首尾函数"></a>4) 首尾函数</h4><p><strong>1．FIRST_VALUE(expr)函数</strong></p>
<p>FIRST_VALUE(expr)函数返回第一个expr的值。</p>
<p>举例：按照价格排序，查询第1个商品的价格信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price, stock,FIRST_VALUE(price) OVER w AS<br>first_price<br>-&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+---------------+------------+---------+-------+-------------+<br>| id | category      | NAME | price | stock | first_price |<br>+----+---------------+------------+---------+-------+-------------+<br>| 5  | 女装/女士精品   | 百褶裙 | 29.90 | 500 | 29.90 |<br>| 1  | 女装/女士精品   | T恤 | 39.90 | 1000 | 29.90 |<br>| 2  | 女装/女士精品   | 连衣裙 | 79.90 | 2500 | 29.90 |<br>| 3  | 女装/女士精品   | 卫衣 | 89.90 | 1500 | 29.90 |<br>| 4  | 女装/女士精品   | 牛仔裤 | 89.90 | 3500 | 29.90 |<br>| 6  | 女装/女士精品   | 呢绒外套 | 399.90 | 1200 | 29.90 |<br>| 9  | 户外运动       | 登山杖 | 59.90 | 1500 | 59.90 |<br>| 7  | 户外运动       | 自行车 | 399.90 | 1000 | 59.90 |<br>| 10 | 户外运动       | 骑行装备 | 399.90 | 3500 | 59.90 |<br>| 12 | 户外运动       | 滑板 | 499.90 | 1200 | 59.90 |<br>| 11 | 户外运动       | 运动外套 | 799.90 | 500 | 59.90 |<br>| 8  | 户外运动       | 山地自行车 | 1399.90 | 2500 | 59.90 |<br>+----+---------------+------------+---------+-------+-------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p><strong>LAST_VALUE(expr)函数</strong></p>
<p>LAST_VALUE(expr)函数返回最后一个expr的值。 </p>
<p>举例：按照价格排序，查询最后一个商品的价格信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price, stock,LAST_VALUE(price) OVER w AS last_price<br>-&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+---------------+------------+---------+-------+------------+<br>| id | category      | NAME | price | stock | last_price |<br>+----+---------------+------------+---------+-------+------------+<br>| 5  | 女装/女士精品   | 百褶裙 | 29.90 | 500 | 29.90 |<br>| 1  | 女装/女士精品   | T恤 | 39.90 | 1000 | 39.90 |<br>| 2  | 女装/女士精品   | 连衣裙 | 79.90 | 2500 | 79.90 |<br>| 3  | 女装/女士精品   | 卫衣 | 89.90 | 1500 | 89.90 |<br>| 4  | 女装/女士精品   | 牛仔裤 | 89.90 | 3500 | 89.90 |<br>| 6  | 女装/女士精品   | 呢绒外套 | 399.90 | 1200 | 399.90 |<br>| 9  | 户外运动       | 登山杖 | 59.90 | 1500 | 59.90 |<br>| 7  | 户外运动       | 自行车 | 399.90 | 1000 | 399.90 |<br>| 10 | 户外运动       | 骑行装备 | 399.90 | 3500 | 399.90 |<br>| 12 | 户外运动       | 滑板 | 499.90 | 1200 | 499.90 |<br>| 11 | 户外运动       | 运动外套 | 799.90 | 500 | 799.90 |<br>| 8  | 户外运动       | 山地自行车 | 1399.90 | 2500 | 1399.90 |<br>+----+---------------+------------+---------+-------+------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<h4 id="5-其他函数"><a href="#5-其他函数" class="headerlink" title="5) 其他函数"></a>5) 其他函数</h4><p><strong>1．NTH_VALUE(expr,n)函数</strong></p>
<p>NTH_VALUE(expr,n)函数返回第n个expr的值。 举例：查询goods数据表中排名第2和第3的价格信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT id, category, NAME, price,NTH_VALUE(price,2) OVER w AS second_price,<br>-&gt; NTH_VALUE(price,3) OVER w AS third_price<br>-&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+---------------+------------+---------+--------------+-------------+<br>| id | category      | NAME       | price   | second_price | third_price |<br>+----+---------------+------------+---------+--------------+-------------+<br>| 5  | 女装/女士精品   | 百褶裙 | 29.90 | NULL | NULL |<br>| 1  | 女装/女士精品   | T恤 | 39.90 | 39.90 | NULL |<br>| 2  | 女装/女士精品   | 连衣裙 | 79.90 | 39.90 | 79.90 |<br>| 3  | 女装/女士精品   | 卫衣 | 89.90 | 39.90 | 79.90 |<br>| 4  | 女装/女士精品   | 牛仔裤 | 89.90 | 39.90 | 79.90 |<br>| 6  | 女装/女士精品   | 呢绒外套 | 399.90 | 39.90 | 79.90 |<br>| 9  | 户外运动       | 登山杖 | 59.90 | NULL | NULL |<br>| 7  | 户外运动       | 自行车 | 399.90 | 399.90 | 399.90 |<br>| 10 | 户外运动       | 骑行装备 | 399.90 | 399.90 | 399.90 |<br>| 12 | 户外运动       | 滑板 | 499.90 | 399.90 | 399.90 |<br>| 11 | 户外运动       | 运动外套 | 799.90 | 399.90 | 399.90 |<br>| 8  | 户外运动       | 山地自行车 | 1399.90 | 399.90 | 399.90 |<br>+----+---------------+------------+---------+--------------+-------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p><strong>2．NTILE(n)函数</strong></p>
<p>NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号。 </p>
<p>举例：将goods表中的商品按照价格分为3组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT NTILE(3) OVER w AS nt,id, category, NAME, price<br>-&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);<br>+----+----+---------------+------------+---------+<br>| nt | id | category      | NAME       | price |<br>+----+----+---------------+------------+---------+<br>| 1  | 5  | 女装/女士精品   | 百褶裙 | 29.90 |<br>| 1  | 1  | 女装/女士精品   | T恤 | 39.90 |<br>| 2  | 2  | 女装/女士精品   | 连衣裙 | 79.90 |<br>| 2  | 3  | 女装/女士精品   | 卫衣 | 89.90 |<br>| 3  | 4  | 女装/女士精品   | 牛仔裤 | 89.90 |<br>| 3  | 6  | 女装/女士精品   | 呢绒外套 | 399.90 |<br>| 1  | 9  | 户外运动       | 登山杖 | 59.90 |<br>| 1  | 7  | 户外运动       | 自行车 | 399.90 |<br>| 2  | 10 | 户外运动       | 骑行装备 | 399.90 |<br>| 2  | 12 | 户外运动       | 滑板 | 499.90 |<br>| 3  | 11 | 户外运动       | 运动外套 | 799.90 |<br>| 3  | 8  | 户外运动       | 山地自行车 | 1399.90 |<br>+----+----+---------------+------------+---------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5) 小结"></a>5) 小结</h3><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行 数，这对我们在原表数据的基础上进行统计和排序非常有用。</p>
<h2 id="3-新特性2：公用表表达式"><a href="#3-新特性2：公用表表达式" class="headerlink" title="3. 新特性2：公用表表达式"></a>3. 新特性2：公用表表达式</h2><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结 果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的， CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p>
<p>依据语法结构和执行方式的不同，公用表表达式分为 普通公用表表达式 和 递归公用表表达式 2 种。</p>
<h3 id="1-普通公用表表达式"><a href="#1-普通公用表表达式" class="headerlink" title="1) 普通公用表表达式"></a>1) 普通公用表表达式</h3><p>普通公用表表达式的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">WITH CTE名称<br>AS （子查询）<br>SELECT|DELETE|UPDATE 语句;<br></code></pre></td></tr></table></figure>

<p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普 通公用表表达式所引用。</p>
<p>举例：查询员工所在的部门的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM departments<br>-&gt; WHERE department_id IN (<br>-&gt; SELECT DISTINCT department_id<br>-&gt; FROM employees<br>-&gt; );<br>+---------------+------------------+------------+-------------+<br>| department_id | department_name  | manager_id | location_id |<br>+---------------+------------------+------------+-------------+<br>|     10        | Administration   | 200        | 1700        |<br>|     20        | Marketing        | 201        | 1800        |<br>|     30        | Purchasing       | 114        | 1700        |<br>|     40        | Human Resources  | 203        | 2400        |<br>|     50        | Shipping         | 121        | 1500        |<br>|     60        | IT               | 103        | 1400        |<br>|     70        | Public Relations | 204        | 2700        |<br>|     80        | Sales            | 145        | 2500        |<br>|     90        | Executive        | 100        | 1700        |<br>|     100       | Finance          | 108        | 1700        |<br>|     110       | Accounting       | 205        | 1700        |<br>+---------------+------------------+------------+-------------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>这个查询也可以用普通公用表表达式的方式完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; WITH emp_dept_id<br>-&gt; AS (SELECT DISTINCT department_id FROM employees)<br>-&gt; SELECT *<br>-&gt; FROM departments d JOIN emp_dept_id e<br>-&gt; ON d.department_id = e.department_id;<br>+---------------+------------------+------------+-------------+---------------+<br>| department_id | department_name  | manager_id | location_id | department_id |<br>+---------------+------------------+------------+-------------+---------------+<br>|      90       | Executive        | 100        | 1700        | 90            |<br>|      60       | IT               | 103        | 1400        | 60            |<br>|      100      | Finance          | 108        | 1700        | 100           |<br>|      30       | Purchasing       | 114        | 1700        | 30            |<br>|      50       | Shipping         | 121        | 1500        | 50            |<br>|      80       | Sales            | 145        | 2500        | 80            |<br>|      10       | Administration   | 200        | 1700        | 10            |<br>|      20       | Marketing        | 201        | 1800        | 20            |<br>|      40       | Human Resources  | 203        | 2400        | 40            |<br>|      70       | Public Relations | 204        | 2700        | 70            |<br>|      110      | Accounting       | 205        | 1700        | 110           |<br>+---------------+------------------+------------+-------------+---------------+<br>11 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>例子说明，公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询 之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有 一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询 则不能。</p>
<h3 id="2-递归公用表表达式"><a href="#2-递归公用表表达式" class="headerlink" title="2)  递归公用表表达式"></a>2)  递归公用表表达式</h3><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是可以调用自己。它的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE<br>CTE名称 AS （子查询）<br>SELECT|DELETE|UPDATE 语句;<br></code></pre></td></tr></table></figure>

<p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。 这里的种子查询，意思就是获得递归的初始值。这个查询只会运行一次，以创建初始数据集，之后递归 查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p>
<p>案例：针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b 的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下 属。</p>
<p>下面我们尝试用查询语句列出所有具有下下属身份的人员信息。</p>
<p>如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p>
<ul>
<li>第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表； </li>
<li>第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表； </li>
<li>第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。 </li>
<li>第四步，找出所有以下下属为管理者的人，得到一个结果集。</li>
</ul>
<p>如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续 进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。 而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。</p>
<p>如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。</p>
<ul>
<li>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一 代管理者。</li>
<li>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次 的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</li>
<li>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是 下下属了。这样就得到了我们需要的结果集。</li>
</ul>
<p>这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表 保存中间结果，比刚刚的方法简单多了。</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE cte<br>AS<br>(<br>SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100<br>-- 种子查询，找到第一代领导<br>UNION ALL<br>SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte<br>ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人<br>)<br>SELECT employee_id,last_name FROM cte WHERE n &gt;= 3;<br></code></pre></td></tr></table></figure>

<p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的 限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p>
<h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3) 小结"></a>3) 小结</h3><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根 节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/03/03/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><p>操作系统(Operating System，0S) 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ol>
<li><p>作为<em><strong>系统资源的管理者</strong></em></p>
<ul>
<li><p>提供的功能：处理机管理	存储器管理	文件管理	设备管理</p>
</li>
<li><p>目标：	安全，高效</p>
</li>
</ul>
</li>
<li><p>作为<em><strong>用户和计算机硬件之间的接口</strong></em></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">提供的功能:<br>	<span class="hljs-number">1.</span>命令接口：联机命令接口	(交互式命令接口) <br>				<span class="hljs-comment">//类似于cmd 用户说一句，系统做一句</span><br>			  脱机命令接口 (批处理命令接口) <br>        		<span class="hljs-comment">//shell脚本  用户说一句，系统做一堆</span><br>	<span class="hljs-number">2.</span>程序接口<br>        允许用户通过程序<span class="hljs-string">&#x27;间接&#x27;</span>使用，由一组<span class="hljs-string">&#x27;系统调用&#x27;</span>组成<br>        (程序接口 = 系统调用)系统调用也被成为广义指令<br>        <br>	<span class="hljs-number">3.</span>GUI（图形用户界面） ios 安卓图形操作界面<br><br>目标：方便用户使用<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p>作为<em><strong>最接近硬件的层次</strong></em></p>
<p>OS实现了对计算机资源的抽象</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">需要提供的功能和目标: <span class="hljs-string">&#x27;实现对硬件机器的拓展&#x27;</span><br><br>没有任何软件支持的计算机成为裸机。<br>    在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器<br><br><span class="hljs-comment">//这个过程体现了封装的思想</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/M7cxHwq4eBn1EiY.png" alt="image-20220831183846049"></p>
<h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>指两个或多个事件在同一时间间隔内发生。<br>这些事件<strong>宏观上是同时发生的</strong>，但<strong>微观上是交替发生</strong>的。</p>
<p>常考易混概念——并行，指两个或多个事件在同一时刻同时发生。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">并行  ——  在一天内干两件事，但是<span class="hljs-string">&#x27;同一时刻干两件事&#x27;</span><br>并发  ——  在一天内干两件事, 但是 <span class="hljs-string">&#x27;两件事交替完成，微小时刻只干一件事&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>操作系统的并发性</strong> ——指计算机系统中同时存在着多个运行着的程序。</p>
<p> 一个单核处理机(CPU) 同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行</p>
<p>​	<strong>操作系统和程序并发是一 起诞生的</strong></p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p>有两种资源共享方式：</p>
<ol>
<li><p><strong>互斥共享方式</strong></p>
<p>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p>
<p>eg. 摄像头</p>
</li>
<li><p><strong>同时共享方式</strong></p>
<p>系统中的某些资源,允许一个时间段内由多个进程“同时”对它们进行访问</p>
<p>​	（所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p>
<p>eg.QQ微信 发送不同文件</p>
</li>
</ol>
<p><strong>并发和共享的关系</strong></p>
<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。</p>
<p><strong>共享性</strong>   是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟是指把一个物理上的实体变为若千个逻辑上的对应物。<br>物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。</p>
<p>虚拟技术中的<strong>时分复用技术</strong>。<br>微观上处理机在各个微小的时间段内交替着为各个进程服务</p>
<p>​	eg. 4G内存同时运行了 需求大于4G的程序</p>
<p><strong>虚拟技术</strong></p>
<ol>
<li><p>空分复用技术（虚拟存储器技术）</p>
</li>
<li><p>时分复用技术（虚拟处理器）</p>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性</p>
</li>
</ol>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p> 异步是指，在多道程序环境下，允许多个程序并发执行，但由于<strong>资源有限</strong>，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p>
<p><img src="https://s2.loli.net/2024/02/24/41pGYwKmgMELHRs.png" alt="image-20220831190620967"></p>
<h2 id="OS的发展与分类"><a href="#OS的发展与分类" class="headerlink" title="OS的发展与分类"></a>OS的发展与分类</h2><ol>
<li><p>手工操作阶段</p>
<p>​	主要缺点，用户独占全机，人机速度矛盾导致资源利用率极低</p>
</li>
<li><p>批处理系统</p>
<p>单道批处理系统</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">主要优点:<br>	缓解了一定程度的人机速度矛盾，资源利用率有所提升<br>主要缺点:<br>	内存中仅能有-道程序运行，只有该程序运行结束之后才能调入下一道程序。<span class="hljs-string">&#x27;CPU有大量的时间是在空闲等待I/0完成&#x27;</span>。资源利用率依然很低。<br></code></pre></td></tr></table></figure>

<p>多道批处理系统</p>
<p>多道程序设计:指在主存中同时存放多道用户作业，使它们都处于执行的开始点和结束点之间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">操作系统正式诞生<br>主要优点:<br>	多道程序并发执行，共享计算机资源。<span class="hljs-string">&#x27;资源利用率大幅提升&#x27;</span>，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。<br>主要缺点:<br>	用户响应时间长，<span class="hljs-string">&#x27;没有人机交互功能&#x27;</span>(用户提交自己的作业之后就只能等待计算机处理完成,中间不能控制自己的作业执行)<br></code></pre></td></tr></table></figure>

<p>资源利用率大幅提升 &#x2F;&#x2F; 类似于流水线</p>
<p><img src="https://s2.loli.net/2024/02/24/Jetxk3LmBnDXS9P.png" alt="image-20220831220045996"></p>
</li>
<li><p>分时操作系统</p>
<p>分时操作系统:计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可通过终端与计算机进行交互。</p>
<p>规律的发出中断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">主要优点:<br>	用户请求可以被即时响应，<span class="hljs-string">&#x27;解决了人机交互问题&#x27;</span>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br><br>主要缺点:<br>	<span class="hljs-string">&#x27;不能优先处理一些紧急任务&#x27;</span>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务- -个时间片，不区分任务的紧急性。<br></code></pre></td></tr></table></figure>
</li>
<li><p>实时操作系统:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">主要优点:<br>	能够优先响应--些紧急任务，某些紧急任务不需时间片排队。<br><br>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在<span class="hljs-string">&#x27;严格的时限内处理完事件&#x27;</span>。实时操作系统的主要特点是<span class="hljs-string">&#x27;及时性和可靠性&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/zvWmZpHqC6eGjIT.png" alt="image-20220831220855841"></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/24/JLaf5zikQIGO42j.png" alt="image-20220831221103041"></p>
<ol start="4">
<li><p>分布式操作系统</p>
<p>个人计算机 前端， 计算过程放在数据中心，中间通过网络链接</p>
<ul>
<li>松、紧耦合系统</li>
</ul>
</li>
<li><p>云计算</p>
</li>
</ol>
<h2 id="OS的运行机制和体系结构"><a href="#OS的运行机制和体系结构" class="headerlink" title="OS的运行机制和体系结构"></a>OS的运行机制和体系结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><strong>指令</strong></p>
<ul>
<li><p>特权指令：如内存清零指令，不允许用户程序使用</p>
</li>
<li><p>非特权指令：普通运算指令</p>
</li>
</ul>
<p>CUP 通过<strong>两种处理器状态</strong>判断是否可以指向特权指令</p>
<ul>
<li>用户态（目态）此时CPU只能指向非特权指令</li>
<li>核心态（管态）特权指令，非特权指令都可以执行</li>
</ul>
<p>用程序状态字寄存器 (PSW)  中的某标志位来标识当前处理器处于什么状态。<br>如0为用户态，1为核心态</p>
<p><strong>程序</strong>是否可以使用特权指令 又分为<strong>两种程序</strong></p>
<ul>
<li>内核程序——操作系统的内核程序是系统的管理者，1既可以执行特权指令，也可以执行非特权指令，运行在核心态。</li>
<li>应用程序——为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</li>
</ul>
<h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>内核是计算机.上配置的底层软件，是操作系统最基本、最核心的部分。.</p>
<p>实现操作系统内核功能的那些程序就是内核程序。</p>
<p><img src="https://s2.loli.net/2024/02/24/t6NSRp1jGvoKYa4.png" alt="image-20220831222605559"></p>
<p><img src="https://s2.loli.net/2024/02/24/tqBFAbUYlSjd8VL.png" alt="image-20220831224923309"></p>
<p>操作系统结构</p>
<p>简单操作系统：MS-DOS（1081-1994） 不分模块的单体内核</p>
<h2 id="OS的启动"><a href="#OS的启动" class="headerlink" title="OS的启动"></a>OS的启动</h2><p><img src="https://s2.loli.net/2024/02/24/1CgPSO7G9RnKzEr.png" alt="image-20220903165255905">**</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">DISK：存放OS</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">BIOS：基本I/O处理系统</span><br><span class="hljs-keyword"></span>	功能 ：<br>		<span class="hljs-number">1</span>. 检查计算机外设 <br>		<span class="hljs-number">2</span>. 加载相应的软件<br>		<br><span class="hljs-keyword">Bootloader </span>:加载OS<br>	功能 ： 将OS从硬盘放入内存里<br><br> 开机第一步 <span class="hljs-keyword">BIOS </span>从 CS:IP = <span class="hljs-number">0xf000</span>:fff0 这个内存地址 加电<br> 		cs 段寄存器  IP 指令指针寄存器<br> 	 完成一系列操作<br> 	 	<span class="hljs-number">1</span>. POST 加电自检 寻找显卡 和 <span class="hljs-keyword">BIOS</span><br><span class="hljs-keyword"></span> 	 	<br><span class="hljs-keyword">B1OS</span><br><span class="hljs-keyword"></span>	●将<span class="hljs-keyword">Bootloader从磁盘的引号扇区( </span><span class="hljs-number">512</span>字节)加载到<span class="hljs-number">0x7c00</span><br>	●跳转到CSIP = <span class="hljs-number">0000</span>:<span class="hljs-number">7</span>c00<br>●<span class="hljs-keyword">Bootloader</span><br><span class="hljs-keyword"></span>	●将操作系统的代码和数据从硬盘加救到内存中<br>	●跳转到操作系统的起始地址<br></code></pre></td></tr></table></figure>



<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>定义</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">◆系统调用<span class="hljs-comment">(来源于应用程序)</span><br>	●应用程序主动向操作系统发出服务请求<br>◆异常<span class="hljs-comment">(来源于不良的应用程序)</span><br>	●非法指令或者其他坏的处理状态<span class="hljs-comment">(如:内存出错)</span><br>◆中断<span class="hljs-comment">(来源于外设)</span><br>	●来自不同的硬件设备的计时器和网络的中断<br></code></pre></td></tr></table></figure>

<p>为什么应用程序不能直接访问外设</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在计算机运行中,内核是被信任的第三方（安全）<br><span class="hljs-bullet">2.</span> 只有内核可以执行特权指令<br><span class="hljs-bullet">3.</span> 为了方便应用程序(OS 直接提供接口，方便软件设计)<br></code></pre></td></tr></table></figure>

<ul>
<li>来源</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">中断:外设</span><br><span class="hljs-section">异常:应用程序意想不到的行为</span><br><span class="hljs-section">系统调用:应用程序请求操作提供服务</span><br></code></pre></td></tr></table></figure>

<ul>
<li>处理时间</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">中断 ： 异步<br>异常：同步<br>系统调用：异步或同步<br><br>同步，即在得到反馈之前不会做别的事情。<br>异步，即无所谓反馈是不是即时的，继续做别的事情。<br>外设通过中断通知给OS之后，不需要等待反馈，所以是异步。<br></code></pre></td></tr></table></figure>

<ul>
<li>响应</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">中断:持续，对用户应用程序是透明的</span><br><span class="hljs-section">异常:杀死或者重新执行意想不到的应用程序指令</span><br><span class="hljs-section">系统调用:等待和持续</span><br></code></pre></td></tr></table></figure>

<ul>
<li>程序访问主要是通过高层次的API接口而不是直接进行系统调用</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">●Win32 API用于Windows<br>●POSIX API用于POSIX- <span class="hljs-keyword">based </span>systems(包括UNIX，LINUX , Mac OS X的所有版本) <br>●<span class="hljs-keyword">Java </span>API用于<span class="hljs-keyword">JAVA </span>虚拟机(<span class="hljs-keyword">JVM)</span><br></code></pre></td></tr></table></figure>



<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>本质: <strong>发生中断</strong>就意味着需要操作系统介入，开展管理工作</p>
<ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ol>
<p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配I&#x2F;O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使<strong>CPU从用户态切换为核心态</strong>，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p>
<p><strong>中断时CUP 由用户态 —&gt;核心态的唯一途径</strong>（执行特权指令，改变程序状态字PSW</p>
<h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p>中断分为</p>
<ul>
<li>内中断（也被成为”异常“）</li>
<li>外中断</li>
</ul>
<p>中断的两种分类方式</p>
<ol>
<li><p><img src="https://s2.loli.net/2024/02/24/OIvQXCZgyFMlSPU.png" alt="image-20220901164641183"></p>
</li>
<li><p><img src="https://s2.loli.net/2024/02/24/p4iDwescTNux7YW.png" alt="image-20220901164819790"></p>
</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>中断。这是外部设备完成了预定<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作或在<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作中出错所引起的中断。<br><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>程序中断。这是由程序中的错误引起的中断。<br><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>硬件故障中断，或称机器检验中断。<br><span class="hljs-punctuation">(</span><span class="hljs-number">4</span><span class="hljs-punctuation">)</span>外中断。外中断来自外部信号，这些信号可能来自其它机器。外中断还包括时钟中断，键盘中断。<br><span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span>访管中断。由机器中的访管指令引起的中断。<br></code></pre></td></tr></table></figure>



<h3 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h3><ol>
<li><p>每条指令执行结束后，CPU检查是否有外部中断信号</p>
</li>
<li><p>若有外部中断信号,则需要保护被中断进程的CPU环境</p>
</li>
<li><p>根据中断信号类型转入相应的中断处理程序</p>
</li>
<li><p>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</p>
</li>
</ol>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>“系统调用”是操作系统提供给应用程序(程序员&#x2F;编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出<strong>系统调用请求来获得操作系统的服务</strong>。</p>
<p>eg. 用户想使用 某个资源 会向操作系统发出请求，操作系统会对个个请求进行关系（防止争抢资源）</p>
<p>作用：</p>
<p>应用程序通过系统调用请求操作系统的服务。</p>
<p>系统中的各种共享资源都由操作系统统–掌管，因此在用户程序中，凡是与资源有关的操作( 如存储分配、I&#x2F;O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</p>
<p>这样可以<strong>保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<p>总结：</p>
<ol>
<li>操作系统提供给应用程序使用的接口</li>
<li>应用程序通过系统调用来请求获得操作系统的服务</li>
<li>系统调用会使处理器从用户态进入核心态</li>
</ol>
<h3 id="系统调用的分类"><a href="#系统调用的分类" class="headerlink" title="系统调用的分类"></a>系统调用的分类</h3><p>按功能分类</p>
<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p>操作系统：向上提供系统调用</p>
<p>编程语言：向上提供库函数，有时会讲系统调用封装成库函数，用来隐藏系统调用的细节，使上层调用系统函数更加方便</p>
<p>普通程序：可以使用库函数完成系统调用（eg. 创建文件）</p>
<ol>
<li>系统调用是操作系统向.上层提供的接口</li>
<li>有的库函数是对系统调用的进一步封装</li>
<li>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用</li>
</ol>
<h3 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a>系统调用背后的过程</h3><p><img src="https://s2.loli.net/2024/02/24/Yv7sQpiKtcyEPrq.png" alt="image-20220901171356690"></p>
<p><strong>具体流程</strong></p>
<ol>
<li>传递系统调用参数</li>
<li>执行陷入指令（用户态）</li>
<li>执行系统调用相应服务程序（核心态）</li>
<li>返回用户程序</li>
</ol>
<p>注意：</p>
<ol>
<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个<strong>内中断</strong>，从而CPU进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>陷入指令是唯一一 个 <strong>只能在用户态执行，而不可在核心态执行</strong>的指令</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="用户与操作系统的接口"><a href="#用户与操作系统的接口" class="headerlink" title="用户与操作系统的接口"></a>用户与操作系统的接口</h1><h2 id="作业控制接口"><a href="#作业控制接口" class="headerlink" title="作业控制接口"></a>作业控制接口</h2><ul>
<li>作业：用户一 次请求计算机系统为它完成任务所进行的工作总和;</li>
<li>作业步：处理作业的各个独立的子任务;如:编译、链接、执行等;</li>
<li>作业流：若干个作业输入到磁盘上形成的作业序列。</li>
</ul>
<h3 id="作业控制命令与键盘操作命令"><a href="#作业控制命令与键盘操作命令" class="headerlink" title="作业控制命令与键盘操作命令"></a>作业控制命令与键盘操作命令</h3><ol>
<li>脱机用户接口<ul>
<li>脱机用户接口:由一组作业控制命令或称作业控制语言组成。</li>
<li>脱机控制方式:把对作业进行控制的意图，连同程序和数据及发生故障后的处理措施- - 起输入系统中，由系统根据该意图来控制作业的执行。</li>
</ul>
</li>
<li>联机用户接口<br>联机用户接口：由一组操作系统命令组成，采用人机对话的方式来控制作业的运行。</li>
</ol>
<h2 id="程序级接口"><a href="#程序级接口" class="headerlink" title="程序级接口"></a>程序级接口</h2><h3 id="管态与算态"><a href="#管态与算态" class="headerlink" title="管态与算态"></a>管态与算态</h3><p>计算机系统中存在两类程序:</p>
<ol>
<li>系统程序:享有一些用户程序不能享有的特权,工作在管态(管理程序状态)，也称为核心态。</li>
<li>用户程序:用户程序工作在算态(算题状态)，也称为用户态。</li>
</ol>
<h3 id="特权指令与访管指令"><a href="#特权指令与访管指令" class="headerlink" title="特权指令与访管指令"></a>特权指令与访管指令</h3><ul>
<li>特权指令：是一类只能在管态下执行而不能在算态下执行的特殊的机器指令。</li>
</ul>
<p><strong>常见的特权指令有以下几种</strong></p>
<ol>
<li><p>有关使用外设的指令。如启动外设指令，测试外设工作状态以及控制外设动作的指令等。</p>
</li>
<li><p>有关访问程序状态的指令。改变程序状态字寄存器的内容，就等于改变了处理机状态。</p>
</li>
<li><p>存取特殊寄存器的指令。一般计算机都有一些硬件寄存器，如中断寄存器、时钟计时器、上下地址寄存器等。</p>
</li>
<li><p>其它指令。</p>
</li>
</ol>
<p><strong>访管指令实现的过程</strong></p>
<ol>
<li>引起访管中断。</li>
<li>保存原来的PSW到内存固定单元，建立新的PSW，并事先已预置了“管态”，处理机进入管态。</li>
<li>在管态下，由中断处理程序完成用户程序所请求的服务，并可使用特权指令。</li>
<li>中断处理程序工作完成后，恢复原来的PSW到程序状态字寄存器，返回到用户程序，处理机从管态回到了算态。</li>
</ol>
<h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是通过访管指令或软中断方式中断现行程序，而转去<br>执行相应的子程序，以完成特定的系统功能。</p>
<p>主要功能：操作系统提供系统调用接口，让用户通过这些接口使用系统提供的各种功能。</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(如程序代码存放位置)</p>
<p>程序段、数据段、PCB三部分组成了进程实体(进程映像)。一般情况下， 我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。</p>
<p><strong>注意: PCB是进程存在的唯一标志!</strong></p>
<p>定义</p>
<ol>
<li>进程是程序的一次<strong>执行过程</strong>。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时<strong>所发生的活动</strong>。</li>
<li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<p>引入进程实体的概念后，可把进程定义为:</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p>————进程实体是静态的，进程是动态的</p>
<p><img src="https://s2.loli.net/2024/02/24/itZTKU7CSv38hFn.png" alt="image-20220915092722838"></p>
<p>PCB 只要和 进程管理相关的数据都是存放再PCB中的</p>
<h4 id="进程的组成方式"><a href="#进程的组成方式" class="headerlink" title="进程的组成方式"></a>进程的组成方式</h4><p><img src="https://s2.loli.net/2024/02/24/MlKYHaX5F8dUWxh.png" alt="image-20220915093054877"></p>
<p><strong>链接方式</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/bTGJO6nC1Mtareo.png" alt="image-20220915093234159"></p>
<p><strong>索引方式</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/8kmUIOqdQY6WMvl.png" alt="image-20220915093313715"></p>
<h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><ol>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单倥</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供”进程同步机制”来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB. 结构上看，进程由程序段、数据段、PCB组成</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/24/Wj2CcxEMPUFfhXD.png" alt="image-20220915093605753"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/3I2sPZRfzjJB1HW.png" alt="image-20220915093657805"></p>
<h3 id="进程状态与状态转换"><a href="#进程状态与状态转换" class="headerlink" title="进程状态与状态转换"></a>进程状态与状态转换</h3><h4 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h4><p><strong>运行态</strong></p>
<p>占有CPU ，并在CPU上运行 </p>
<p><strong>就绪态</strong></p>
<p>已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</p>
<p><strong>阻塞态(Waiting&#x2F;Blocked， 又称:等待态)</strong></p>
<p>因等 待某一事件而 暂时不能运行</p>
<p>创建态(New， 又称:新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB</p>
<p>终止态(Terminated, 又称:结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</p>
<h4 id="进程转换"><a href="#进程转换" class="headerlink" title="进程转换"></a>进程转换</h4><p><img src="https://s2.loli.net/2024/02/24/DTJF98uqGCafQWO.png" alt="image-20220915102035266"></p>
<p><strong>不能由阻塞态转换为运行态，也不能由就绪态转换为阻塞态</strong> </p>
<p><img src="https://s2.loli.net/2024/02/24/VZjdv3BD7umJXLp.png" alt="image-20220915102151425"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>简化理解:反正进程控制就是要实现进程状态转换</p>
<p><img src="https://s2.loli.net/2024/02/24/PbwUNDspXhuJgzB.png" alt="image-20220915222507768"></p>
<h4 id="进程控制原语"><a href="#进程控制原语" class="headerlink" title="进程控制原语"></a>进程控制原语</h4><p>原语实现进程控制，原语特点是执行期间<strong>不允许中断，只能一气合成</strong> </p>
<p><img src="https://s2.loli.net/2024/02/24/bG8XsiT5wpFmIjL.png" alt="image-20220915222943096"></p>
<p><img src="https://s2.loli.net/2024/02/24/PmW3ZKOakQGphtl.png" alt="image-20220915223512376"></p>
<h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5><p><img src="https://s2.loli.net/2024/02/24/kfEjHTCDsRGbmZL.png" alt="image-20220915223521874"></p>
<h5 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h5><p><img src="https://s2.loli.net/2024/02/24/mD9sdLpGEXYRfqv.png" alt="image-20220915223548623"></p>
<h5 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h5><p><img src="https://s2.loli.net/2024/02/24/r3HDctf78mAsCyk.png" alt="image-20220915223713853"></p>
<h5 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h5><p><img src="https://s2.loli.net/2024/02/24/PQaxNpJrcKOARF6.png" alt="image-20220915223734463"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/EZ51uAMVIKCPxjF.png" alt="image-20220915223817886"></p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>顾名思义，进程通信就是指进程之间的信息交换。</p>
<p><strong>各进程拥有的内存空间地址相互独立</strong></p>
<p><strong>为保证安全，进程不能直接访问另一个进程的地址空间</strong></p>
<h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>操作系统为两个进程分配一个<strong>共享空间</strong>，进程之间通过这个空间到达相互访问</p>
<p><strong>注意：两个进程对共享空间的访问必须是互斥的</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/Oiuev2R85HXr4a7.png" alt="image-20221024205047033"></p>
<p><strong>基于数据结构的共享</strong>:比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p>
<p><strong>基于存储区的共享</strong>:在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p><img src="https://s2.loli.net/2024/02/24/m9idape1cgqQ7bA.png" alt="image-20220915225133613"></p>
<ol>
<li><p>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
</li>
<li><p>各进程要<strong>互斥</strong>地访问管道。</p>
</li>
<li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</p>
</li>
<li><p>如果<strong>没写满，就不允许读。如果没读空，就不允许写</strong>。</p>
</li>
<li><p>数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个</strong>，否则可能会有读错数据的情况。</p>
</li>
</ol>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以格式化的消息(Message) 为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换。</p>
<p><img src="https://s2.loli.net/2024/02/24/1wsDtPiuCc8Zobx.png" alt="image-20220915225320513"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/JZ4FKLSz9xQATHd.png" alt="image-20220915225409695"></p>
<h3 id="线程、多线程模型"><a href="#线程、多线程模型" class="headerlink" title="线程、多线程模型"></a>线程、多线程模型</h3><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度</p>
<p>引入线程后，线程成为了程序执行流的最小单位</p>
<p><strong>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/uCVa9vjLBezdr5U.png" alt="image-20220918235835362"></p>
<p><img src="https://s2.loli.net/2024/02/24/jMbSaCtskdnAiKD.png" alt="image-20220919000022337"></p>
<h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><p> <strong>用户级线程</strong></p>
<p>用户级线程由应用程序通过线程库实现。<br>    所有的<strong>线程管理工作</strong>都由应用程序负责(包括线程切换)<br>    用户级线程中，线程切换可以在<strong>用户态下</strong>即可完成，无需操作系统干预。</p>
<p>可以这样理解，<strong>用户级线程”就是“从用户视角看能看到的线程</strong></p>
<p><strong>内核级线程</strong></p>
<p>内核级线程的管理工作由<strong>操作系统内核</strong>完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在<strong>核心态</strong>下才能完成。</p>
<p>可以这样理解，<strong>内核级线程”就是‘“从操.作系统内核视角看能看到的线程</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/tLxfiDkbKruyNlH.png" alt="image-20220919000950136"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位&#x27;</span><br></code></pre></td></tr></table></figure>





<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p><strong>多对一</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/ZrgaNYu6oUewycE.png" alt="image-20220919001252087"></p>
<p><strong>一对一</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/3dM8AaCeDXvhsHb.png" alt="image-20220919001409332"></p>
<p><strong>多对多</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/9jY6DRgyriuXT4P.png" alt="image-20220919001508667"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/o4SuOKF9CUi6sfx.png" alt="image-20220919001641428"></p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理，这些任务的顺序，这就是“调度”研究的问题。</p>
<p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定 的算法选择-一个进程并将处理机分配给它运行，以实现进程并发执行。</p>
<h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><h4 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h4><p><strong>高级调度(作业调度)<strong>。按一定的原则从外存上处于后备队列的作业中挑选-一个(或多个)作业，给他们分配内存等必要资源，并</strong>建立相应的进程(建立PCB)<strong>，以使它(们)获得</strong>竞争处理机的权利</strong>。</p>
<p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB</strong>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">外存 到 内存 （面向作业）	发生频率低<br></code></pre></td></tr></table></figure>



<h4 id="中层调度（内存调度）"><a href="#中层调度（内存调度）" class="headerlink" title="中层调度（内存调度）"></a>中层调度（内存调度）</h4><p>这么做的目的是为了提高内存利用率和系统吞吐量。<br>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。值得注意的是，PCB并不会一起调到外存，而是<strong>会常驻内存</strong>。<br>PCB中 会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的<strong>挂起队列</strong>中。</p>
<p><strong>中级调度(内存调度)<strong>，就是要决定将哪个处于</strong>挂起状态</strong>的进程重新调入内存。<br>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">中级调度（内存调度） ：挂起态与运行态 之间相互调度<br><br>外存 到 内存 （面向进程） 发生频率中等<br></code></pre></td></tr></table></figure>



<h4 id="挂起状态与7状态模型"><a href="#挂起状态与7状态模型" class="headerlink" title="挂起状态与7状态模型"></a>挂起状态与7状态模型</h4><p><img src="https://s2.loli.net/2024/02/24/JDIALOzXHmlW6kd.png" alt="image-20220922142509605"></p>
<h4 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h4><p>低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程， 将处理机分配给它。</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm">内存 到 <span class="hljs-meta">CPU</span> 频率最高<br></code></pre></td></tr></table></figure>

<p>进程调度的频率很高，一般几十毫秒一次。</p>
<p><img src="https://s2.loli.net/2024/02/24/dwTNFvAqJnoUbSu.png" alt="image-20220922142912434"></p>
<p><img src="https://s2.loli.net/2024/02/24/aibY3AwUVveI4dJ.png" alt="image-20220922143122629"></p>
<h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p><img src="https://s2.loli.net/2024/02/24/5L6uyUIlWZt8CrF.png" alt="image-20220922145413365"></p>
<p>临界区的概念</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">每个进程中访问临界资源的那段程序称为临界区（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。<br></code></pre></td></tr></table></figure>

<p>进程在操作<strong>系统内核程序临界区</strong>中不能进行调度与切换</p>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p>当前处理机是否可以被剥夺资源分为：</p>
<ol>
<li><strong>非剥夺调度方式，又称非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
<li><strong>剥夺调度方式，又称抢占方式</strong>。当一个进程正在处理机上执行时，如果有-一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
</ol>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p><img src="https://s2.loli.net/2024/02/24/ifjRUTbYoFKH29m.png" alt=" "></p>
<p><img src="https://s2.loli.net/2024/02/24/wfBzMndcFkPNab1.png" alt="image-20220922160000693"></p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>评价指标</p>
<ul>
<li><p>CPU利用率:指CPU“忙碌”的时间占总时间的比例。</p>
<p>​	利用率&#x3D;忙碌的时间&#x2F;总时间	</p>
</li>
<li><p>周转时间：是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。</p>
<p>它包括四个部分:作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就继队列上等待进程调度(低级调度)的时间、进程在CPU.上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p><strong>周转时间&#x3D;作业完成时间-作业提交时间</strong></p>
<p><strong>平均周转时间</strong>&#x3D;各作业周转时间之和 &#x2F; 作业数</p>
<p><img src="https://s2.loli.net/2024/02/24/3oa5wBFJz7vDS9Q.png" alt="image-20221002214937923"></p>
</li>
<li><p>等待时间，指进程&#x2F;作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业调入内存后，建立对应的进程。这个进程会被CPU服务、会被1&#x2F;O设备服务，当然也会有等待被服务的时候</p>
<ul>
<li>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I&#x2F;0完成的期间其实进程也是在被服务的，所以不计入等待时间。</li>
<li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间</strong>，<strong>还要加上作业在外存后备队列中等待的时间</strong>。</li>
</ul>
</li>
<li><p><strong>响应时间</strong>，指从用户提交请求到<strong>首次产生响应所用的时间</strong>。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/YRb3QzGVq6Dc1Kk.png" alt="image-20221002215547954"></p>
<h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><p>先来先服务调度算法:按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。</p>
<p><img src="https://s2.loli.net/2024/02/24/sj42QZMSA6lpbcU.png" alt="image-20221104164815471"></p>
<p>总结</p>
<p><img src="https://s2.loli.net/2024/02/24/7zcWRnpHPk2CDbY.png" alt="image-20221104165106610"></p>
<h3 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h3><p><strong>非抢占式的</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/N581HjhFbtKISpP.png" alt="image-20221104165423485"></p>
<p><strong>抢占式的</strong></p>
<p>最短剩余时间优先算法</p>
<p><img src="https://s2.loli.net/2024/02/24/2h1H93TCN5IKXQj.png" alt="image-20221104165739210"></p>
<p><img src="https://s2.loli.net/2024/02/24/sdE8QoGDtPfFgSk.png" alt="image-20221104170239340"></p>
<h3 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h3><p><img src="https://s2.loli.net/2024/02/24/AQJx8FntCHl6kTy.png" alt="image-20221104170628838"></p>
<p><img src="https://s2.loli.net/2024/02/24/hGNl7uHFqSLpJQs.png" alt="image-20221104170733149"></p>
<p><img src="https://s2.loli.net/2024/02/24/m7LIKjdrQX8w6kb.png" alt="image-20221104170750402"></p>
<p><img src="https://s2.loli.net/2024/02/24/HKLRfBtQspMoiF8.png" alt="image-20221104170818695"></p>
<h3 id="时间片轮转法RR"><a href="#时间片轮转法RR" class="headerlink" title="时间片轮转法RR"></a>时间片轮转法RR</h3><p><img src="https://s2.loli.net/2024/02/24/6n8Wzg5odty1pS7.png" alt="image-20221104212722251"></p>
<p><img src="https://s2.loli.net/2024/02/24/iU1M9JOpD2RKXof.png" alt="image-20221104212839003"></p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>非抢占式的优先级调度算法:每次调度时选择当前已到达且<br>优先级最高的进程。当前进程主动放弃处理机时发生调度。</p>
<p><img src="https://s2.loli.net/2024/02/24/SE3IixrDByfhZAl.png" alt="image-20221104213108006"></p>
<p>抢占式的优先级调度算法:每次调度时选择<strong>当前已到达且优先级最高</strong>的进程。当前进程主动放弃处理机时发生调度。另外，当<strong>就绪队列发生改变时也需要检查是会发生抢占</strong>。</p>
<p><img src="https://s2.loli.net/2024/02/24/WS5IB9w4QTVhg7c.png" alt="image-20221104213231445"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">就绪队列未必只有一一个，可以按照不同优先级来组织。<br>另外，也可以把优先级高的进程排在更靠近队头的位置<br><br>根据优先级是否可以动态改变，可将优先级分为<span class="hljs-string">&#x27;静态优先级&#x27;</span>和<span class="hljs-string">&#x27;动态优先级&#x27;</span>两种。<br><br>静态优先级:创建进程时确定，之后一直不变。<br>动态优先级:创建进程时有-个初始值，之后会根据情况动态地调整优先级。<br><br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ZS8BVWLeFTridtQ.png" alt="image-20221104213929145"></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span>/<span class="hljs-number">0</span>设备和CPU可以并行工作。如果优先让I/<span class="hljs-number">0</span>繁忙型进程优先运行的话，则越有可能让I/<span class="hljs-number">0</span>设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/wYEqZjW8zLFJVns.png" alt="image-20221104214041222"></p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><img src="https://s2.loli.net/2024/02/24/wdlKr9NJAiQbntk.png" alt="image-20221104214505934"></p>
<p><img src="https://s2.loli.net/2024/02/24/UvZC8Xn3ftVGuld.png" alt="image-20221104214706096"></p>
<p><img src="https://s2.loli.net/2024/02/24/7jNZkUJcVgom63y.png" alt="image-20221104214721694"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">注:比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于<span class="hljs-string">&#x27;交互式系统&#x27;</span>。( 比如UNIX使用的就是多级反馈队列调度算法)<br></code></pre></td></tr></table></figure>

<h2 id="进程同步-进程互斥"><a href="#进程同步-进程互斥" class="headerlink" title="进程同步 进程互斥"></a>进程同步 进程互斥</h2><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在身些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相合作。</p>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>逻辑上分为</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">do</span> &#123;<br>	entry sectlon;	 	<span class="hljs-regexp">//</span>进叭区<br>	critical section ;	<span class="hljs-regexp">//</span>临界区<br>	<span class="hljs-keyword">exit</span> section ;		<span class="hljs-regexp">//</span>退出区<br>	remainder section ;	<span class="hljs-regexp">//</span>剩余区<br>&#125; <span class="hljs-keyword">while</span> (true)<br><br></code></pre></td></tr></table></figure>

<p>遵循原则</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许-一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿) ;</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想:两个进程在<strong>访问完临界区后</strong>会把使用临界区8的权限转交给另-一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/QJzXensVx72Zvcd.png" alt="image-20221105092441895"></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">如果开始 <span class="hljs-built_in">P0</span>不访问临界区，即使临界区空闲 <span class="hljs-built_in">P1</span>也无法访问、<br>只能 <span class="hljs-built_in">p0</span> -&gt;<span class="hljs-built_in">P1</span> -&gt; <span class="hljs-built_in">P0</span> 交替访问<br></code></pre></td></tr></table></figure>

<h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p><img src="https://s2.loli.net/2024/02/24/QPR62BkgOcsr8T5.png" alt="image-20221105093828908"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">检查 和上锁 不是一起合成的 可能会 发生 同时访问临界区的情况<br></code></pre></td></tr></table></figure>

<h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p><img src="https://s2.loli.net/2024/02/24/6py9aoAjtzFL7cS.png" alt="image-20221105094850259"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">双标志位后检查法，两个进程都争着进入临界区则会都无法进入<br></code></pre></td></tr></table></figure>



<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p><img src="https://s2.loli.net/2024/02/24/v8d2n7KCEDmQLHb.png" alt="image-20221106153724899"></p>
<p>Peterson算法用软件方法解决了进程互斥问题，遵循了<strong>空闲让进、忙则等待、有限等待三个原则</strong>，但是<strong>依然未遵循让权等待</strong>的原则。</p>
<p><img src="https://s2.loli.net/2024/02/24/QFOUx6mYTAV2is7.png" alt="image-20221106153934110"></p>
<h3 id="进程互斥的硬件解决方法"><a href="#进程互斥的硬件解决方法" class="headerlink" title="进程互斥的硬件解决方法"></a>进程互斥的硬件解决方法</h3><h4 id="中断屏蔽的方法"><a href="#中断屏蔽的方法" class="headerlink" title="中断屏蔽的方法"></a>中断屏蔽的方法</h4><p><img src="https://s2.loli.net/2024/02/24/Z5hqLud8goEHAcl.png" alt="image-20221106154827671"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>锁 用于形成进程互斥</p>
<p><img src="https://s2.loli.net/2024/02/24/TLQbvxkOzwnlfeJ.png" alt="image-20221110105733141"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">特性:<br><span class="hljs-code">	需忙等，进程时间片用完才下处理机，违反“让权等待”</span><br><span class="hljs-code">	优点:等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</span><br><span class="hljs-code">	常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</span><br><span class="hljs-code">	不太适用于单处理机系统，忙等的过程中不可能解锁</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>

<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><img src="https://s2.loli.net/2024/02/24/7wEM9K1STqcnOes.png" alt="image-20221110110315180"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">信号量：其实就是一个变量<span class="hljs-comment">(可以是一个整数，也可以是更复杂的记录型变量)</span>，可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一-台打印机，就可以设置一一个初值为<span class="hljs-number">1</span>的信号量。<br><br>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法- -气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。<br><br></code></pre></td></tr></table></figure>

<h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h4><p><img src="https://s2.loli.net/2024/02/24/cBdbxwIiWQ9uPTh.png" alt="image-20221110111555646"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">整形信号量存在的问题 ： 不满足“让权等待”原则，会发生“忙等”<br></code></pre></td></tr></table></figure>

<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p><img src="https://s2.loli.net/2024/02/24/5GRYiPZJO7nQzVr.png" alt="image-20221110111958194"></p>
<h4 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p><img src="https://s2.loli.net/2024/02/24/1gNncfBYRFIVqMe.png" alt="image-20221111154449879"></p>
<h4 id="互斥-同步-前驱"><a href="#互斥-同步-前驱" class="headerlink" title="互斥 同步 前驱"></a>互斥 同步 前驱</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">进程互斥：<br>	设置互斥信号量，初值为<span class="hljs-number">1</span>，<br>	临界区之前对信号量执行<span class="hljs-selector-tag">P</span>操作，临界区之后执行V操作<br>	<br>进程同步 <br>	寻找“一前一后”同步关系<br>	设置同步性量，初值为<span class="hljs-number">0</span>；<br>	在“前操作” 在前操作 之后执行V<br>	在“后操作” 之前 执行 <span class="hljs-selector-tag">P</span><br></code></pre></td></tr></table></figure>



<p><img src="https://s2.loli.net/2024/02/24/FWxv8b5YAyCVjz4.png" alt="image-20221111155248536"></p>
<h3 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h3><p><img src="https://s2.loli.net/2024/02/24/HpgtDb81KPwaXmc.png" alt="image-20221111160937110"></p>
<p><img src="https://s2.loli.net/2024/02/24/AyHFnf6aQD9dVjI.png" alt="image-20221111161142893"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">semaphore mutex <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;	//互斥信号量，实现对缓冲区的互斥访问</span><br>semaphore empty <span class="hljs-operator">=</span> n<span class="hljs-comment">;	//同步信号量，表示空闲缓冲区的数量</span><br>semaphore full <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;		//同步信号量，表示产品的数量，也即非空缓冲区的数量</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/sgoLKvZD5EyuR1J.png" alt="image-20221111161441385"></p>
<h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者 - 多消费者"></a>多生产者 - 多消费者</h3><p><img src="https://s2.loli.net/2024/02/24/YcslKom6qLEjT3U.png" alt="image-20221111162322174"></p>
<p><img src="https://s2.loli.net/2024/02/24/W5zMsNUCKqx3jmQ.png" alt="image-20221111163906639"></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>内存可存放数据。程<strong>序执行前需要先放到内存中才能被CPU处理</strong>–缓和CPU与硬盘之间的速度矛盾</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">存储单元 ： 存放数据的最小单元<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/16nYaGftzKX8lcr.png" alt="image-20221130145928135"></p>
<p><img src="https://s2.loli.net/2024/02/24/MNs3D8GyOjbhK96.png" alt="image-20221130150212476"></p>
<h2 id="内存基础知识汇总"><a href="#内存基础知识汇总" class="headerlink" title="内存基础知识汇总"></a>内存基础知识汇总</h2><p><img src="https://s2.loli.net/2024/02/24/LpR2X6fclgxDEVa.png" alt="image-20221130153800230"></p>
<h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><p>操作系统对内存进行什么管理</p>
<p><strong>1.操作系统负责内存空间的分配与回收</strong><br><strong>2.操作系统需要提供某种技术从逻辑.上对内存空间进行扩充</strong><br><strong>3.操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/k4NuSxRomsiwaOr.png" alt="image-20221130154312685"></p>
<p>4.操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm">方法一:在<span class="hljs-meta">CPU</span>中设置- -对上、下限寄存器，存放进程的，上、下限地址。进程的指令要访问某个地址时，<span class="hljs-meta">CPU</span>检查是否越界。<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/rse1qU7B4j3dA6w.png" alt="image-20221130154628152"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">方法二:采用重定位寄存器<span class="hljs-comment">(又称基址寄存器)</span>和界地址寄存器<span class="hljs-comment">(又称限长寄存器)</span>进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/7DT5hrcPWXtNzwR.png" alt="image-20221130160104065"></p>
<p><img src="https://s2.loli.net/2024/02/24/pO8J3YtcaiTx96A.png" alt="image-20221130160300381"></p>
<h2 id="地址转换——覆盖与交换"><a href="#地址转换——覆盖与交换" class="headerlink" title="地址转换——覆盖与交换"></a>地址转换——覆盖与交换</h2><p>选择考察</p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>覆盖技术的思想:将<strong>程序分为多个段</strong>(多个模块)。 常用的段常驻内存，不常用的段在需要时调入内存。</p>
<p>内存中分为一个<strong>“固定区”和若干个“覆盖区”</strong>。<br>需要常驻内存的段放在“固定区”中，调入后就不再调出( 除非运行结束)</p>
<p>不常用的段放在“覆盖区”,需要用到时调入内存，用不到时调出内存</p>
<p><img src="https://s2.loli.net/2024/02/24/ng7OFqKCrtzL5u9.png" alt="image-20221130161149092"></p>
<p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。</p>
<p>缺点:<strong>对用户不透明</strong>，增加了用户编程负担。</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换(对换)技术的设计思想: 内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存(进程在内存与磁盘间动态调度)</p>
<p><img src="https://s2.loli.net/2024/02/24/ROg2WZmkjhTaGbf.png" alt="image-20221130161937349"></p>
<p><strong>三个问题</strong></p>
<p>1.应该在外存(磁盘)的什么位置保存被换出的进程?<br>2.什么时候应该交换?<br>3.应该换出哪些进程?</p>
<p><img src="https://s2.loli.net/2024/02/24/6GULa5m9fY32B4P.png" alt="image-20221130162428114"></p>
<p><img src="https://s2.loli.net/2024/02/24/uSDaLHksYXA2v7R.png" alt="image-20221130162527352"></p>
<h2 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h2><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>连续分配:指为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p><img src="https://s2.loli.net/2024/02/24/WXHGJOwYA8rv5Dg.png" alt="image-20221130164518034"></p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><strong>分区大小相等</strong>:缺乏灵活性,但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong></p>
<p><strong>分区大小不等</strong>:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分<br>(比如:划分多个小分区、适量中等分区、少量大分区) </p>
<p><img src="https://s2.loli.net/2024/02/24/gOadCw5k3sjtvVy.png" alt="image-20221130165350698"></p>
<p>问题 <strong>OS如何管理分区呢</strong></p>
<p>操作系统需要建立一个数据结——<strong>分区说明表</strong>，来实现各个分区的分配与回<br>收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<br>**大小、起始地址、状态(**是否已分配)。 </p>
<p><img src="https://s2.loli.net/2024/02/24/2vl8rKaP4D3nzk1.png" alt="image-20221130165551159"></p>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配又称为<strong>可变分区分配</strong>。</p>
<p>这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据<strong>进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。</p>
<p>因此系统分区的大小和数目是可变的。 (eg: 假设某计算机内存大小为64MB， 系统区8MB，用户区共56 M…)</p>
<p><strong>问题：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.系统要用什么样的数据结构记录内存的使用情况?<br>2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?<br>3.如何进行分区的分配与回收操作?<br></code></pre></td></tr></table></figure>

<h4 id="采用数据结构"><a href="#采用数据结构" class="headerlink" title="采用数据结构"></a>采用数据结构</h4><p>空闲分区表  或  空闲分区链</p>
<p><img src="https://s2.loli.net/2024/02/24/a7hGBTZ9JsKluqv.png" alt="image-20221130170609765"></p>
<h4 id="如何选择分区"><a href="#如何选择分区" class="headerlink" title="如何选择分区"></a>如何选择分区</h4><p>动态分区算法</p>
<h4 id="如何分配与回收"><a href="#如何分配与回收" class="headerlink" title="如何分配与回收"></a>如何分配与回收</h4><ol>
<li><p>采用 空闲分区表  分配之后有剩余修改空闲分区表大小 ，无剩余之后删除</p>
</li>
<li><p>回收</p>
<p>​	情况—:回收区的后面有一个相邻的空闲分区 合二为一</p>
<p>​	情况二:回收区的前面有一个相邻的空闲分区 合二为一</p>
<p>​	情况三:回收区的前、后各有一个相邻的空闲分区	讲三个空闲分区合起来	情况四:回收区的前、后都没有相邻的空闲分区  新增一个分区</p>
</li>
</ol>
<h4 id="内外部碎片"><a href="#内外部碎片" class="headerlink" title="内外部碎片"></a>内外部碎片</h4><p>动态分区分配<strong>没有内部碎片，但是有外部碎片</strong>。<br><strong>内部碎片</strong>，分配给某进程的内存区域中，如果有些部分没有用上。<br><strong>外部碎片</strong>，是指内存中的某些空闲分区由于太小而难以利用。</p>
<p><img src="https://s2.loli.net/2024/02/24/sJf1D8NErmwua2g.png" alt="image-20221130171602433"></p>
<p>可以通过<strong>紧凑(拼凑，Compaction) 技术</strong>来解决外部碎片。</p>
<p><img src="https://s2.loli.net/2024/02/24/y3Iz6hxKqfVAQkr.png" alt="image-20221130171714345"></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2024/02/24/qsiTzCkKtGebIu8.png" alt="image-20221130171822700"></p>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><p>动态分区分配算法:在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p>
<p><img src="https://s2.loli.net/2024/02/24/n2B6pCNqOsE3xhR.png" alt="image-20221130172017556"></p>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想:每次都从低地址开始查找，找到第一一个能满足大小的空闲分区。<br>如何实现:<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。</p>
<p><img src="https://s2.loli.net/2024/02/24/1wgFRy3kYANotMn.png" alt="image-20221130172450938"></p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。</p>
<p>因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</p>
<p><strong>如何实现</strong>:<strong>空闲分区按容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲 分区。</p>
<p><img src="https://s2.loli.net/2024/02/24/4RBlQSwEyW9hGYK.png" alt="image-20221130172842021"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">缺点 ： 产生很多外部碎片<br></code></pre></td></tr></table></figure>

<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p><strong>最大适应算法</strong>(Largest Fit)<br>算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:<strong>空闲分区按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的<strong>第一个空闲分区</strong>。</p>
<p><img src="https://s2.loli.net/2024/02/24/TMyI21FgHb4ZDeh.png" alt="image-20221130173929487"></p>
<p>缺点:每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致<strong>较大的连续空闲区被迅速用完</strong>。如果之后有“大进程”到达，就没有内存分区可用了。</p>
<h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><p>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决.上述问题。</p>
<p>如何实现:<strong>空闲分区以地址递增的顺序排列</strong>(可排成-一个循环链表)。每次分配内存时<strong>从上次查找结束的位置开始查找****空闲分区链</strong>( 或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">临近 和 首次 不需要对链表重新 排列所以开销较小<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ASprILqb9eXtcTy.png" alt="image-20221130174420265"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">临近 <br>优点 ： 开销小<br>缺点 ： 无大分区可用<br></code></pre></td></tr></table></figure>



<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/Da4OBqZCinTJyGm.png" alt="image-20221130174439678"></p>
<h2 id="非连续分配的管理方法"><a href="#非连续分配的管理方法" class="headerlink" title="非连续分配的管理方法"></a>非连续分配的管理方法</h2><h2 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="页框"><a href="#页框" class="headerlink" title="页框"></a><strong>页框</strong></h4><p>将内存空间分为一个个<strong>大小相等的分区</strong>( 比如:每个分区4KB)，<strong>每个分区就是一个“页框”</strong></p>
<p>(**页框&#x3D; 页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面)**。</p>
<p>每个页框有一个编号，即“页框号”<br>(页框号&#x3D;页帧号&#x3D;内存块号&#x3D;物理块号&#x3D;物理页号)，<br>页框号从0开始。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a><strong>页</strong></h4><p>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，<br>    每个部分称为一个“<strong>页”或“页面”</strong>、<br>每个页面也有一个编号,即“页号”，页号也是从0开始。</p>
<p><strong>操作系统以页框为单位为各个进程分配内存空间</strong>。<br>进程的每个页面分别放入一个页框中。<br><strong>进程的页面与内存的页框有一一对应的关系</strong></p>
<p>各个页面不必连续存放，可以放到不相邻的各个页框中。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 .<br>注:页表通常存在PCB (进程控制块)中</p>
<p><img src="https://s2.loli.net/2024/02/24/SDRkjoGtYz1wnvc.png" alt="image-20221219224331039"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-number">1</span>.每个页表项多大<span class="hljs-string">?占</span>几个字节?<br><span class="hljs-number">2</span>.如何通过页表实现逻辑地址到物理地址的转换?<br></code></pre></td></tr></table></figure>

<p>块号占多少内存计算</p>
<p><img src="https://s2.loli.net/2024/02/24/OsqTVPiMutf1Zaw.png" alt="image-20221219225205773"></p>
<p>页号 不占存储空间<br>页表项是连续存放的，页号是隐含的，不占存储空间（类比数组）</p>
<p><img src="https://s2.loli.net/2024/02/24/oTgmOLFhYafWAdJ.png" alt="image-20221219225504874"></p>
<p><em><em>由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要3</em>(n+1)B</em>*</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">注意:页表记录的只是内存块号，而不是内存块的起始地址!<br><span class="hljs-code">	J号内存块的起始地址=J*内存块大小</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>





<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">2.如何通过页表实现逻辑地址到物理地址的转换?<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/gnfEsWv2aSAKrJ7.png" alt="image-20221219230030729"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">如何确定一个逻辑地址对应的页号 与 页内偏移量<br></code></pre></td></tr></table></figure>

<p><strong>页号&#x3D;逻辑地址&#x2F;页面长度(取除法的整数部分)</strong><br><strong>页内偏移量&#x3D;逻辑地址%页面长度(取除法的余数部分)</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/UlXzN35snGCkr4K.png" alt="image-20221219230404416"></p>
<p>结论:如果每个页面大小为2KB，用二进制数表示逻辑地址，则末尾K位即为页内<br>偏移量，其余部分就是页号</p>
<p><img src="https://s2.loli.net/2024/02/24/dYBkA3PbyOXnSDG.png" alt="image-20221219231002684"></p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/mihbWpKo5yeQPEf.png" alt="image-20221219231100546"></p>
<h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><p>基本地址变换机构(<strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong>)</p>
<p><img src="https://s2.loli.net/2024/02/24/V6ATChRfoINaOmW.png" alt="image-20230305113912543"></p>
<p><img src="https://s2.loli.net/2024/02/24/QgJzX9lxv8osFwZ.png" alt="image-20230305115047616"></p>
<h3 id="快表地址变换机构"><a href="#快表地址变换机构" class="headerlink" title="快表地址变换机构"></a>快表地址变换机构</h3><p>未看</p>
<h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><img src="https://s2.loli.net/2024/02/24/NaoEi6OtRpFgwvH.png" alt="image-20230305142516494"></p>
<p><img src="https://s2.loli.net/2024/02/24/P2wU8IaudvKCF6T.png" alt="image-20230305142533378"></p>
<p><img src="https://s2.loli.net/2024/02/24/gsA8n9WxySUBMfL.png" alt="image-20230305145315763"></p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><img src="https://s2.loli.net/2024/02/24/S3hZkHw5vzDA6cO.png" alt="image-20230305145448022"></p>
<p>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被<br>访问的页面，这样可以保证最低的缺页率。</p>
<p>理想情况操作系统无法预知访问页面的顺序所以无法实现</p>
<p><img src="https://s2.loli.net/2024/02/24/Ulf1aonNVFgIsS2.png" alt="image-20230305145745741"></p>
<p><strong>先进先出置换算法(FIFO)</strong> :每次选择淘汰的页面是最早进入内存的页面<br>实现方法:把调入内存的页面根据调入的先后顺序排成-一个队列，需要换出页面时选择队头频面即可。<br>队列的最大长度取决于系统为进程分配了多少个内存块。<br>队列的最大长度取决于操作系统为进程分配多少内存块</p>
<p><img src="https://s2.loli.net/2024/02/24/UTPCR9eAxM1E6zG.png" alt="image-20230305150216474"></p>
<p><strong>最近最久未使用置换算法(LRU，least recently used)</strong> :每次淘汰的页面是最近最久未使用的页面<br>实现方法:赋予每个页面对应的页表项中，用<strong>访间字段记录该页面自上次被访问以来所经历的时间t</strong>。<br>当需要淘汰-一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p><img src="https://s2.loli.net/2024/02/24/Cwel7ZNLzH86YyV.png" alt="image-20230305150416277"></p>
<p>最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用<br>置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。<br>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not<br>Recently Used )</p>
<p><img src="https://s2.loli.net/2024/02/24/Vvol4DNdXWRGjuY.png" alt="image-20230305151238194"></p>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><p><img src="https://s2.loli.net/2024/02/24/Ru49MwDIxAriByg.png" alt="image-20230305164651482"></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2023/03/18/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><h2 id="计算机发展历程"><a href="#计算机发展历程" class="headerlink" title="计算机发展历程"></a>计算机发展历程</h2><p>计算机系统 &#x3D; 硬件 + 软件</p>
<p>硬件发展</p>
<ul>
<li>第一代：电子管时代</li>
<li>第二代：晶体管时代</li>
<li>第三代：中小规模集成电路时代</li>
<li>第四代：大规模、超大规模集成电路时代</li>
</ul>
<p>软件的发展</p>
<p>目前发展趋势</p>
<ul>
<li>更微型、多用途</li>
<li>更巨型、超高速</li>
</ul>
<h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><h3 id="冯诺依曼型计算机特点"><a href="#冯诺依曼型计算机特点" class="headerlink" title="冯诺依曼型计算机特点"></a>冯诺依曼型计算机特点</h3><ul>
<li>1.计算机由运算器，控制器，存储器，输入和输出设备5部分组成</li>
<li>2.指令和数据以同等地位存于存储器，可按地址寻访</li>
<li>3.指令和数据用二进制表示</li>
<li>4.指令由操作码和地址码组成</li>
<li>5.指令在存储器中按执行顺序存放， 由指令计数器(即程序计数器PC)指明要执行的指令所在的储存单元地址，一般按顺序递增，但可按运算结果或外界条件而改变</li>
<li>6.机器<strong>以运算器为中心</strong>，输入输出设备与存储器间的数据传送都通过运算器</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/24/z3954tXTOyf8EGF.png" alt="image-20220901221206217"></p>
<p>eg.对于乘法运算，可以设计一个专门的硬件电路实现乘法运算<br>        也可以用软件的方式，执行多次加法运算来实现~</p>
<h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h3><p>现代计算机：<strong>以存储器为核心</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/iTEdJc3jU5W4lRg.png" alt="image-20220901221856500"></p>
<p>运算器+ 控制器 整合为 CPU 后</p>
<p><img src="https://s2.loli.net/2024/02/24/m8TQr1uV7EwBGv9.png" alt="image-20220901222423074"></p>
<p><strong>主存</strong>——一般指 运行内存</p>
<p><strong>辅存</strong>——一般指 存储内存，属于I&#x2F;O设备</p>
<p>章节总结</p>
<p><img src="https://s2.loli.net/2024/02/24/InDaxd1BjuWGQhU.png" alt="image-20220901222648232"></p>
<h3 id="各硬件组成"><a href="#各硬件组成" class="headerlink" title="各硬件组成"></a>各硬件组成</h3><h4 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h4><p>主存储器 由三个部分组成</p>
<ol>
<li>存储体</li>
<li>MAR  存储<strong>地址寄存器</strong></li>
<li>MDR  存储<strong>数据寄存器</strong></li>
</ol>
<p><strong>CPU读取数据流程</strong></p>
<p>CUP 讲想要获取的数据地址 写入 MAR（地址寄存器）， 主存储器 根据MAR 在存储体中寻找 对应数据， 找到之后讲数据 写入 MDR （数据寄存器）中，CUP 直接在MDR 中获取对应数据</p>
<p><strong>CPU写入数据流程</strong></p>
<p> CUP 将要写入数据 放入MDR中， 将要写入地址 放入MAR 中，并下发写指令，主存储器完成写操作</p>
<h5 id="存储体"><a href="#存储体" class="headerlink" title="存储体"></a>存储体</h5><p>数据在存储体内按地址存储</p>
<p>存储体 被 分为若干个存储单元，每个存储单元存放一串二进制代码，这个二进制代码被称为存储字，存储字包含多少个二进制代码的长度被称为存储字长（8bit 的整数被） 没过存储单元对应一个地址</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">存储单元：每个存储单元存放一-串二进制代码<br><span class="hljs-section">存储字(word):存储单元中二进制代码的组合</span><br><span class="hljs-section">存储字长:存储单元中二进制代码的位数</span><br>存储元：即存储二进制的电子元件，每个存储元可有1bit<br><br>MAR位数反应存储单元的个数<br>MDR位数 = 存储字长<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/EpudmeviFMJyjGQ.png" alt="image-20220902212121705"></p>
<h4 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h4><p>运算器:用于实现算术运算(如:加减乘除)、逻辑运算(如:与或非)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ACC 累加器， 用于存放操作数，或运算结果。<br>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。<br>X：通用的操作数寄存器，用于存放操作数<br><span class="hljs-string">&#x27;ALU：算术逻辑单元&#x27;</span>，通过内部复杂的电路实现算数运算、逻辑运算<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/WIolhsPSEkGuR5g.png" alt="image-20220902212649523"></p>
<h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;CU：控制单元，分析指令，给出控制信号&#x27;</span><br>IR: 指令寄存器，存放当前执行的指令<br>PC: 程序计数器，存放下一-条指令地址，有自动加<span class="hljs-number">1</span>功能<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/dO1xmWnZNSX6pH7.png" alt="image-20220902212931001"></p>
<p>完成一条指令：</p>
<p><img src="https://s2.loli.net/2024/02/24/YDTPK2pS8rgmyRo.png" alt="image-20220902213037787"></p>
<h3 id="计算机的工做过程"><a href="#计算机的工做过程" class="headerlink" title="计算机的工做过程"></a>计算机的工做过程</h3><p><img src="https://s2.loli.net/2024/02/24/upD6rCzRe1P3wEI.png" alt="image-20220902213952724"></p>
<p><img src="https://s2.loli.net/2024/02/24/NgAPfXWKJypRhSO.png" alt="image-20220902214249604"></p>
<p> <img src="https://s2.loli.net/2024/02/24/Q3NkDbI4qV7Leou.png" alt="image-20220902214541273"></p>
<p><img src="https://s2.loli.net/2024/02/24/c9BhSPWKiTGHC5E.png" alt="image-20220902214733385"></p>
<p><img src="https://s2.loli.net/2024/02/24/OxoGUzaQt8jl1bh.png" alt="image-20220902214824161"></p>
<p><strong>总结步骤</strong></p>
<p>前5步 取指令 过程都一样 CU分析指令之后才会又不一样的操作</p>
<p><img src="https://s2.loli.net/2024/02/24/c2Re68LNVSnfiC3.png" alt="image-20220902215019599"></p>
<p>章节总结：</p>
<p><img src="https://s2.loli.net/2024/02/24/2iTSFfd65HbarcZ.png" alt="image-20220902215152438"></p>
<h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><p>5层结构</p>
<p><img src="https://s2.loli.net/2024/02/24/62I3N5E8KB4YPuk.png" alt="image-20220902220001134"></p>
<p>不同级别的语言</p>
<p><img src="https://s2.loli.net/2024/02/24/59wFnr1RIjYKVX2.png" alt="image-20220902220424798"></p>
<p>·	</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2024/02/24/kIBVh4CjJ2vtZLf.png" alt="image-20220902220515048"></p>
<h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><ol>
<li>机器字长 CPU 一次能处理数据的位数 与 CPU中的寄存器位数有关</li>
<li>运算速度 主频 吉普森法 MIPS CPI FLOPS</li>
</ol>
<h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">总容量　<span class="hljs-operator">=</span>　存储单元个数　ｘ　存储字长，bit.	<span class="hljs-number">1</span>Byte <span class="hljs-operator">=</span> <span class="hljs-number">8</span>bit<br>	　　＝存储单元个数x存储字长/<span class="hljs-number">8</span> Byte<br></code></pre></td></tr></table></figure>

<h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">CPU</span>主频: <span class="hljs-meta">CPU</span>内 数字咏冲信号振荡的频率。  <span class="hljs-number">3.</span>6GHZ<br><br><span class="hljs-meta">CPU</span>主频（时钟频率） = <span class="hljs-number">1</span>/<span class="hljs-meta">CPU</span>时钟周期  <br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/dbxJEP9jQBKfZT2.png" alt="image-20220902230652481"></p>
<p><strong>执行一条指令的耗时 &#x3D; CPI x CPU 时钟周期</strong></p>
<p><strong>CPU执行时间(整个程序的耗时）&#x3D; CPU时钟周期数&#x2F;主频 &#x3D; (指令条数*CPI)&#x2F;主频</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">IPS : 每秒执行多少条指令  <span class="hljs-string">&quot;IPS = 主频 / 平均CPI&quot;</span><br>FLOPS ： 每秒执行多少次浮点运算<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/JPuRKi5zcYoGUt7.png" alt="image-20220902231302196"></p>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><ol>
<li><strong>数据通路带宽</strong>——数据总线一次所能并行传送信息的位数(各硬件部件通过数据总线传输数据)</li>
<li><strong>吞吐量</strong>——指系统在单位时间内处理请求的数量。</li>
<li><strong>响应时间</strong>——指从用户向计算机发送一一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。</li>
</ol>
<p><strong>基准程序</strong>是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。</p>
<p>基准程序——跑分软件 </p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2024/02/24/MUvHrB4ySow5tFk.png" alt="image-20220902231949381"></p>
<h3 id="计算机层次结构"><a href="#计算机层次结构" class="headerlink" title="计算机层次结构"></a>计算机层次结构</h3><p><img src="https://s2.loli.net/2024/02/24/imgTbxX9fvSMNcJ.png" alt="image-20220907110019173"></p>
<h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="数值与编码"><a href="#数值与编码" class="headerlink" title="数值与编码"></a>数值与编码</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><img src="https://s2.loli.net/2024/02/24/ySWP5e1L6q9FaRt.png" alt="image-20220904144059774"></p>
<h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>使用2进制 对应 10进制的数</p>
<h4 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a><strong>8421码</strong></h4><p>2进制表示 10进制数</p>
<p><img src="https://s2.loli.net/2024/02/24/e6Jd8kB7c9PpmQC.png" alt="image-20220904145218167"></p>
<p>8421 没一位都有固定权值 <strong>有权码</strong></p>
<h4 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h4><p>在8421的基础上 加 3</p>
<p>8421 + （0011）</p>
<p><img src="https://s2.loli.net/2024/02/24/8Ljty6wI5aDfdSn.png" alt="image-20220904145407858"></p>
<p>余3码 无权码</p>
<h4 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h4><p> <img src="https://s2.loli.net/2024/02/24/ButpbLYs82e3lTc.png" alt="image-20220904145642009"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/EYrRmSbX65KaxWA.png" alt="image-20220904145657021"></p>
<h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><p><img src="https://s2.loli.net/2024/02/24/Txr9bc31p5OVnI4.png" alt="image-20220904152456220"></p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>奇校验码:整个校验码(有效信息位和校验位)中“1” 的个数为奇数。</p>
<p>偶校验码:整个校验码(有效信息位和校验位)中“1”的个数为偶数。</p>
<p><img src="https://s2.loli.net/2024/02/24/xri4tazCRukmbVq.png" alt="image-20220914194120091"></p>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p> 基本思想</p>
<p>海明码设计思路：将信息位分组进行偶校验- -&gt;多个校验位- -&gt;多个校验位标注出错位置</p>
<p><strong>确认校验位 : 2^k &gt;&#x3D;  k + n + 1</strong> </p>
<p><img src="https://s2.loli.net/2024/02/24/EMsTtDz5XSadunP.png" alt="image-20220914203719685"></p>
<p><img src="https://s2.loli.net/2024/02/24/fdAbOVxM5PJIGol.png" alt="image-20220914221322333"></p>
<p>海明码 1bit位 纠错能力， 2bit 检错能力</p>
<p><img src="https://s2.loli.net/2024/02/24/czikOym89MnYsxI.png" alt="image-20220914222547004"></p>
<h3 id="CRC-循环冗余校验码"><a href="#CRC-循环冗余校验码" class="headerlink" title="CRC 循环冗余校验码"></a>CRC 循环冗余校验码</h3><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><p>定点数:小数点的位置固定 			   Eg: 996.007			 	一一常规计数<br>浮点数:小数点的位置不固定			Eg: 9.96007*102		——科学计数法</p>
<h3 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h3><p><strong>无符号数</strong> :整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。</p>
<p>通常只有无符号整数，没有无符号小数</p>
<p><strong>有符号数</strong></p>
<ol>
<li>定点整数</li>
<li>定点小数</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/24/T9I7pafqkL8JbFo.png" alt=" "></p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码：用尾数表示真值的绝对值，符号位“0&#x2F;1” 对应“正&#x2F;负”</p>
<p><img src="https://s2.loli.net/2024/02/24/IAZSUm231VFLkcM.png" alt="image-20220918150046617"></p>
<ul>
<li><p>若机器字长n+1位，<strong>原码整数表示范围 ： -(2^n - 1)  &lt;&#x3D; x &lt;&#x3D; 2^n - 1</strong></p>
</li>
<li><p>真值0有+0和-0两种形式</p>
</li>
<li><p>若机器字长n+1位，**原码小数的表示范围:- (1-2^-n)≤x≤1 - 2^-n **(关于原点对称)</p>
</li>
</ul>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码:</p>
<p>​	若符号位为0，则反码与原码相同<br>​	<strong>若符号位为1，则数值位全部取反</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">x= + <span class="hljs-number">19</span>D	原码 = <span class="hljs-number">0,0010011</span><br>			反码 = <span class="hljs-number">0,0010011</span><br>		<br>x = -<span class="hljs-number">19</span>D 	原码 = <span class="hljs-number">1,0010011</span><br>			反码 = <span class="hljs-number">1,1101100</span><br>			<br>X= +<span class="hljs-number">0</span>.<span class="hljs-number">75</span>D	原码= <span class="hljs-number">0.1100000</span><br>			反码= <span class="hljs-number">0.1100000</span><br><br>x=-<span class="hljs-number">0</span>.<span class="hljs-number">75</span>D	原码= <span class="hljs-number">1.1100000</span><br>			反码= <span class="hljs-number">1.0011111</span><br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/VFmHAzfo6pPNXkR.png" alt="image-20220918151016343"></p>
<p>反码”只是“原码”转变为补码”的一个中间状态，实际中并没什么卵用</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码：</p>
<p>​			正数的补码 &#x3D; 原码</p>
<p>​			<strong>负数的补码 &#x3D; 反码末位+1 (要考虑进位)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">X= +<span class="hljs-number">19</span>D 	<br>			[x]原=<span class="hljs-number">0</span>,<span class="hljs-number">0010011</span><br>			[x]反=<span class="hljs-number">0</span>,<span class="hljs-number">0010011</span><br>			[x]补=<span class="hljs-number">0</span>,<span class="hljs-number">0010011</span><br>X= <span class="hljs-number">-19</span>D<br>            [x]原=<span class="hljs-number">1</span>,<span class="hljs-number">0010011</span><br>            [x]反=<span class="hljs-number">1</span>,<span class="hljs-number">1101100</span>	<span class="hljs-comment">//末位 + 1</span><br>            [x]补=<span class="hljs-number">1</span>,<span class="hljs-number">1101101</span><br><br>X= +<span class="hljs-number">0.75</span>D <br>            [x]原= <span class="hljs-number">0.1100000</span><br>            [x]反= <span class="hljs-number">0.1100000</span><br>            [x]补= <span class="hljs-number">0.1100000</span><br>X= <span class="hljs-number">-0.75</span>D<br>            [x]原= <span class="hljs-number">1.1100000</span><br>            [x]反= <span class="hljs-number">1.0011111</span>	<span class="hljs-comment">//末位 + 1</span><br>            [x]补= <span class="hljs-number">1.0100000</span><br><br></code></pre></td></tr></table></figure>

<p><strong>注意!补码的真值0只有一种表示形式</strong></p>
<p>-0 的反码 11111111 加 1之后 得到10000000 由于只有8bit 所以最高位会丢弃，仍为全0</p>
<p><img src="https://s2.loli.net/2024/02/24/IuNVFHpqn3d1Uzg.png" alt="image-20220918151906030"></p>
<p><strong>多的那个数 是因为 0只有一种表示方法， 所以可以多表示一位</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">						补码		原码			   <br>x=<span class="hljs-number">0.0000</span>[+<span class="hljs-number">0</span>]补=|<span class="hljs-number">-0</span>]补	   <span class="hljs-number">0.0000</span> 	<span class="hljs-number">0.0000</span><br>X=<span class="hljs-number">0.0000</span>				<span class="hljs-number">0.0000</span>	 <span class="hljs-number">1.0000</span><br>x=<span class="hljs-number">-1.0000</span>				<span class="hljs-number">1.0000</span>	 不能表示<br><br></code></pre></td></tr></table></figure>

<p><strong>将负数补码转回原码的 方法相同：尾数取反，末位+1</strong></p>
<p><strong>补码作用</strong>：</p>
<ul>
<li>补码- -让减法操作转变为加法操作，节省硬件成本</li>
<li>使用处码可将减法操作转变为等价的加法，ALU 中无需集成减法器<br>执行加法操作时，符号位一起参与运算</li>
</ul>
<p><strong>模  - a的绝对值&#x3D;a的补数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">已知， [y]补 求 [-y]补<br>[y]补连同符号位在内，每位取反，末位加 <span class="hljs-number">1</span>即得[-y]补<br>	不论正负<br>    eg. [-y]补<span class="hljs-number">0.0011</span>   [-y]补 <span class="hljs-number">1.1101</span><br></code></pre></td></tr></table></figure>



<h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p><strong>补码的基础上将符号位取反。注意:移码只能用于表示整数</strong></p>
<p>补码移码 一一对应</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">X= +<span class="hljs-number">19</span>D<br>            [x]原=<span class="hljs-number">0</span>,<span class="hljs-number">0010011</span><br>            [x]反=<span class="hljs-number">0</span>,<span class="hljs-number">0010011</span><br>            [x]补=<span class="hljs-number">0</span>,<span class="hljs-number">0010011</span><br>            [x]移=<span class="hljs-number">1</span>,<span class="hljs-number">0010011</span><br>x=<span class="hljs-number">-19</span>D<br>            [x]原=<span class="hljs-number">1</span>,<span class="hljs-number">0010011</span><br>            [x]反=<span class="hljs-number">1</span>,<span class="hljs-number">1101100</span><br>            [x]补=<span class="hljs-number">1</span>,<span class="hljs-number">1101101</span><br>            [x]移=<span class="hljs-number">0</span>,<span class="hljs-number">1101101</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ksGACEgqLcSHiRK.png" alt="image-20220918152517103"></p>
<p>移码作用 ： 可以很方便的比较叫大小 <strong>从8位全0 到8位全1递增 -128~127</strong></p>
<h2 id="定点数的表示和运算"><a href="#定点数的表示和运算" class="headerlink" title="定点数的表示和运算"></a>定点数的表示和运算</h2><h3 id="移位运算！！"><a href="#移位运算！！" class="headerlink" title="移位运算！！"></a>移位运算！！</h3><ol>
<li><p>原码的算数移位——符号位保持不变，仅对数值位进行移位。</p>
<ul>
<li><p>右移:高位补O,低位舍弃。若舍弃的位&#x3D;0，则相当于&#x2F;2; 若舍弃的位#0，则会<strong>丢失精度</strong></p>
</li>
<li><p>左移:低位补0，高位舍弃。若舍弃的位&#x3D;0，则相当于X2;若舍弃的位<em>0，则会出现*<em>严重误差</em></em></p>
</li>
</ul>
</li>
<li><p>反码的算数移位——</p>
<p><strong>正数的反码 与原码相同</strong></p>
<p>因此对正数反码的移位运算也和原码相同。<br>右移:高位补0，低位舍弃。<br>左移:低位补0，高位舍弃。<br><strong>负数的反码数值位与原码相反</strong>，</p>
<p>因此负数反码的移位运算规则如下，<br>    右移:高位补1，低位舍弃。<br>    左移:低位补1,  高位舍弃。</p>
</li>
<li><p>补码的算数移位——正数的补码与原码相同,<br>因此对正数补码的移位运算也和原码相同。<br>右移:高位补0，低位舍弃。.<br>左移:低位补0，高位舍弃。</p>
<p><strong>补码的算数移位——负数补码&#x3D;反码末位+1</strong><br>导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第- 一个0为止。<br><strong>规律——负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码</strong></p>
<p><strong>负数补码</strong>的算数移位规则如下:</p>
<p><strong>右移(同反码) :高位补1，低位舍弃</strong><br><strong>左移(同原码) :低位补0，高位舍弃</strong></p>
</li>
</ol>
<p>左移相当于X2;右移相当于+2<br>由于位数有限，因此有时候无法用算数移位精确地等效乘除法</p>
<h3 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h3><p>逻辑右移:高位补0，低位舍弃。<br>逻辑左移:低位补0，高位舍弃。</p>
<p><strong>可以把逻辑移位看作是对“无符号数”的算数移位</strong></p>
<h3 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h3><p><img src="https://s2.loli.net/2024/02/24/mwMqbshoIPNcOEv.png" alt="image-20220920165740783"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2024/02/24/g7HtAuYG4Wf2BV9.png" alt="image-20220920165912529"></p>
<h3 id="加减运算！！"><a href="#加减运算！！" class="headerlink" title="加减运算！！"></a>加减运算！！</h3><p>原码的加法运算:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">正+正		-》绝对值做加法，结果为正<br>负+负		-》绝对值做加法，结果为负<br>正+负		-》绝对值大的减绝对值小的，符号同绝对值大的数<br>负+正		-》绝对值大的减绝对值小的，符号同绝对值大的数<br></code></pre></td></tr></table></figure>

<p>原码的减法运算，<strong>“ 减数”符号取反，转变为加法</strong>: .</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">正-负	→ 正+正<br>负-正 → 负+负<br>正-正 → 正+负<br>负-负 → 负+正<br></code></pre></td></tr></table></figure>

<h4 id="补码的加减法"><a href="#补码的加减法" class="headerlink" title="补码的加减法"></a>补码的加减法</h4><p><strong>[A+B]补&#x3D; [A]补+ [B]补</strong></p>
<p>负数补→原:</p>
<p>​	①数值位取反+1;<br>​	②负数补码中，<strong>最右边的1及其右边同原码</strong>，<strong>最右边的1的左边同反码</strong><br>​		及最右边1及右边不变， 左边数据位全部取反</p>
<p><strong>[A-B]补&#x3D; [A]补+ [-B]补</strong></p>
<h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><p>只有“正数+正数”才会<strong>上溢</strong>——正+正&#x3D;负<br>只有“负数+负数”才会<strong>下溢</strong>——负+负&#x3D;						正</p>
<p><strong>方法一:采用一位符号位，</strong></p>
<p>设A的符号为As，B的符号为Bs,运算结果的符号为Ss,则溢出逻辑表达式</p>
<p><img src="https://s2.loli.net/2024/02/24/soInYyDEqM7J9X5.png" alt="image-20220920171858734"><br>若V&#x3D;0, 表示无溢出;<br>若V&#x3D;1,表示有溢出。</p>
<p><img src="https://s2.loli.net/2024/02/24/lBRA97ucpCnG5sb.png" alt="image-20220920172427404"> </p>
<p><strong>方法二</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/nMQAD4xScOy6vaE.png" alt="image-20220920172725177"></p>
<p><strong>方法三!!!</strong></p>
<p><img src="https://s2.loli.net/2024/02/24/7MzZ43ne8ckNDBu.png" alt="image-20220920172949068"></p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2024/02/24/9iqnl4LIyj1otDs.png" alt="image-20220920173347498"></p>
<h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><h4 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h4><p><img src="https://s2.loli.net/2024/02/24/Vo3QvZt4NuJUwSm.png" alt="image-20220920204056891"></p>
<p>符号位确定：</p>
<p><img src="https://s2.loli.net/2024/02/24/Eo6mIZkwtciVOAM.png" alt="image-20220920205022240"></p>
<p>数值位确定： </p>
<p>被乘数 存到 x 通用寄存器， 乘数存到MQ乘商寄存器中，ACC开始初始为）</p>
<p><strong>错位相加，ACC与MQ统一右移</strong>，MQ最低位已经参与运算直接丢弃</p>
<p><img src="https://s2.loli.net/2024/02/24/LCdpPDF4QzABUcY.png" alt="image-20220920205723411"></p>
<p>最后修改符号位</p>
<p><img src="https://s2.loli.net/2024/02/24/eF7fjRbh59nUgAv.png" alt="image-20220920210801009"></p>
<h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p><img src="https://s2.loli.net/2024/02/24/INGKZF2t6sdCuA3.png" alt="image-20220920212002827"></p>
<p><img src="D:\笔记\照片\image-20220920212400846.png" alt="image-20220920212400846"></p>
<p><img src="D:\笔记\照片\image-20220920213643796.png" alt="image-20220920213643796"></p>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>除法的思想</p>
<p><img src="D:\笔记\照片\image-20220922211322713.png" alt="image-20220922211322713"></p>
<h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><p><strong>ACC 中存储被除数的值，ALU中存储除数的值</strong>，MQ中存储商</p>
<p><img src="D:\笔记\照片\image-20220922213248144.png" alt="image-20220922213248144"></p>
<p><strong>11110 符号位 为 负 计算机检查符号位发现出错 会再加上一个除数</strong></p>
<p><img src="D:\笔记\照片\image-20220922213504682.png" alt="image-20220922213504682"></p>
<p><strong>ACC、 MQ整体 “逻辑左移” ACC高位丢弃， MQ低位补0</strong></p>
<p><img src="D:\笔记\照片\image-20220922214047839.png" alt="image-20220922214047839"></p>
<p>恢复余数 + -y绝对值的补</p>
<p><img src="D:\笔记\照片\image-20220922214130440.png" alt="image-20220922214130440"></p>
<p>循环操作</p>
<p><img src="D:\笔记\照片\image-20220922214328151.png" alt="image-20220922214328151"></p>
<p><img src="D:\笔记\照片\image-20220922214428838.png" alt="image-20220922214428838"></p>
<p><strong>余数为 0.0111 * 2^-4 因为ACC被逻辑左移了4次</strong></p>
<h4 id="手算除法"><a href="#手算除法" class="headerlink" title="手算除法"></a>手算除法</h4><p><img src="D:\笔记\照片\image-20220922214912880.png" alt="image-20220922214912880"></p>
<h4 id="不恢复余数除法"><a href="#不恢复余数除法" class="headerlink" title="不恢复余数除法"></a>不恢复余数除法</h4><p><img src="D:\笔记\照片\image-20220922215501173.png" alt="image-20220922215501173"></p>
<p><strong>通过 商 0还是 商 1来 判断是 左移 + 除数 还是左移 - 除数</strong></p>
<p><img src="D:\笔记\照片\image-20220922215704528.png" alt="image-20220922215704528"></p>
<p><strong>余数的正负性与商相同，若余数不对则需要+ [|y|]补</strong></p>
<p>总结</p>
<p><img src="D:\笔记\照片\image-20220922215854596.png" alt="image-20220922215854596"></p>
<h4 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h4><p><img src="D:\笔记\照片\image-20220922233121169.png" alt="image-20220922233121169"></p>
<p>余数和除数<strong>同号</strong>，商1，余数左移一位减去除数;<br>余数和除数<strong>异号</strong>，商0，余数左移一位加上除数。<br>重复n次</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p><img src="D:\笔记\照片\image-20220922233242453.png" alt="image-20220922233242453"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li>无符号数与有符号数<ul>
<li>不改变数据内容，只改变解释方式</li>
</ul>
</li>
<li>不同字节长度整数之间的转换<ol>
<li>大字节-&gt;小字节 	<strong>高位截断，低位保留</strong></li>
<li>小字节-&gt;大字节     高位补0</li>
</ol>
</li>
<li></li>
</ol>
<h3 id="数据的存储与排列"><a href="#数据的存储与排列" class="headerlink" title="数据的存储与排列"></a>数据的存储与排列</h3><h4 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h4><p>​	大端存储 ： 高字节存储在 低地址 ，低字节存储在高地址</p>
<p>​	小段存储  :  高字节存储 在 高地址 ， 低字节存储在低地址</p>
<p><img src="D:\笔记\照片\image-20221006103956167.png" alt="image-20221006103956167"></p>
<h4 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h4><p>一个字 32bit(4个字节)   半字 16bit(2个字节)</p>
<p>半字寻址 逻辑左移 一位</p>
<p>字	逻辑左移 2位</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><img src="D:\笔记\照片\image-20220921105656031.png" alt="image-20220921105656031"></p>
<p><img src="D:\笔记\照片\image-20220923211807540.png" alt="image-20220923211807540"></p>
<p><img src="D:\笔记\照片\image-20220923212057346.png" alt="image-20220923212057346"></p>
<p><strong>在存储空间不变的情况下， 尽可能多保留他的精度 —— 浮点数尾数的规格化</strong></p>
<p><img src="D:\笔记\照片\image-20220923212602494.png" alt="image-20220923212602494"></p>
<h3 id="浮点数数规格化"><a href="#浮点数数规格化" class="headerlink" title="浮点数数规格化"></a>浮点数数规格化</h3><p><img src="D:\笔记\照片\image-20220923212948425.png" alt="x2"></p>
<h3 id="规格化特点"><a href="#规格化特点" class="headerlink" title="规格化特点"></a>规格化特点</h3><p><img src="D:\笔记\照片\image-20220923214031040.png" alt="image-20220923214031040"></p>
<p><img src="D:\笔记\照片\image-20220923214818294.png" alt="image-20220923214818294"></p>
<h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><p>移码的定义:移码 &#x3D; 真值+偏置值</p>
<p>​	此处8位移码的偏置值&#x3D;128D&#x3D;1000 0000B， 即2^n-1</p>
<p>偏置值一般取2^n-1，此时移码&#x3D;补码符号位取反</p>
<p>IEEE 754定义下的移码</p>
<p><img src="D:\笔记\照片\image-20220927154559391.png" alt="image-20220927154559391"></p>
<p>IEEE 表示浮点数</p>
<p><img src="D:\笔记\照片\image-20220927162245250.png" alt="image-20220927162245250"></p>
<p><img src="D:\笔记\照片\image-20220927162513522.png" alt="image-20220927162513522"></p>
<p><img src="D:\笔记\照片\image-20220927162757309.png" alt="image-20220927162757309"></p>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">0.</span> 转换格式<br><span class="hljs-bullet">1.</span> 对阶 小阶像大阶靠近<br><span class="hljs-bullet">2.</span> 尾数加减<br><span class="hljs-bullet">3.</span> 规格化<br><span class="hljs-bullet">4.</span> 舍入	可以有不同的舍入规则<br><span class="hljs-bullet">5.</span> 判溢出	阶码上溢	抛出异常（中断）<br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20220927164632964.png" alt="image-20220927164632964"></p>
<h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><p><img src="D:\笔记\照片\image-20220927170207491.png" alt="image-20220927170207491"></p>
<h3 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="D:\笔记\照片\image-20220927170714437.png" alt="image-20220927170714437"></p>
<h2 id="电路基本原理"><a href="#电路基本原理" class="headerlink" title="电路基本原理"></a>电路基本原理</h2><p><img src="D:\笔记\照片\image-20220927172910219.png" alt="image-20220927172910219"></p>
<p>B x 输入信号  F1 输出信号  S1 控制信号</p>
<p><img src="D:\笔记\照片\image-20221005175643429.png" alt="image-20221005175643429"></p>
<p>​    复合逻辑</p>
<p><img src="D:\笔记\照片\image-20221005180401066.png" alt="image-20221005180401066"></p>
<p><img src="D:\笔记\照片\image-20221005180348985.png" alt="image-20221005180348985"></p>
<h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><p>本位 和 高位进位 </p>
<p> <img src="D:\笔记\照片\image-20221005180858730.png" alt="image-20221005180858730"></p>
<p><img src="D:\笔记\照片\image-20221005181016939.png" alt="image-20221005181016939"></p>
<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><ul>
<li><p>随机存取存储器 RAM : 内存条</p>
</li>
<li><p>顺序存取存储器 SAM : 磁带</p>
</li>
<li><p>直接存储 存储器 DAM : 磁盘</p>
<ul>
<li>​	顺序 直接 属于串行访问存储器：读写某个存储单元所需时间与存储单元的物理位置有关</li>
</ul>
</li>
<li><p>相联存储器 CAM 即可以按内容访问的存储器</p>
<ul>
<li>可以按照内容检索到存储位置进行读写，“快表” 就是一种相联存储器</li>
</ul>
</li>
</ul>
<p>读写存储器(Read&#x2F;Write Memory) - -即可读、也可写(如:磁盘、内存、Cache)<br>只读存储器(Read Only Memory) –只能读，不能写(如:实体音乐专辑通常采用CD-ROM,实体电影采用蓝光光碟，BIOS通 常写在ROM中)</p>
<p>断电后，存储信息消失的存储器一-易失性存储器 (主存、Cache)<br>断电后，存储信息依然保持的存储器–非易失性存储器 (磁盘、光盘)</p>
<p>信息读出后，原存储信息被破坏-一破坏性读出(如DRAM芯片，读出数据后要进行重写)<br>信息读出后，原存储信息不被破坏–非破坏性读出( 如SRAM芯片、磁盘、光盘)</p>
<p>​		</p>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>1.存储容量:存储字数X字长(如1MX8位)。<br>2.单位成本:每位价格&#x3D;总成本&#x2F;总容量。<br>3.存储速度:数据传输率&#x3D;数据的宽度&#x2F;存储周期。</p>
<p>①存取时间(Ta) :存取时间是指从<strong>启动一次存储器操作到完成该操作</strong>所经历<br>的时间，分为读出时间和写入时间。<br>②存取周期(Tm) :存取周期又称为读写周期或访问周期。它<strong>是指存储器进行</strong><br><strong>一次完整的读写操作所需的全部时间</strong>，即连续两次独立地访问存储器操作(读<br>或写操作)之间所需的最小时间间隔。</p>
<p><img src="D:\笔记\照片\image-20221019214527491.png" alt="image-20221019214527491"></p>
<p>主存带宽(Bm) :(主存带宽文称数据传输率，表示每秒从主存进出信息的最大)<br>数量单位为字&#x2F;秒、字节&#x2F;秒(B&#x2F;s) 或位&#x2F;秒(b&#x2F;s) 。</p>
<p><img src="D:\笔记\照片\image-20221019214643859.png" alt="image-20221019214643859"></p>
<h2 id="主寄存器的基本组成"><a href="#主寄存器的基本组成" class="headerlink" title="主寄存器的基本组成"></a>主寄存器的基本组成</h2><p><img src="D:\笔记\照片\image-20221020191523380.png" alt="image-20221020191523380"></p>
<p><img src="D:\笔记\照片\image-20221020192937503.png" alt="image-20221020192937503"></p>
<p><img src="D:\笔记\照片\image-20221020193201137.png" alt="image-20221020193201137"></p>
<p>按字节寻址  转换为 按字寻址  <strong>二进制左移两位</strong></p>
<p>第1 字节 位置  1 左移两位 100  及 对应字位置为4</p>
<p><img src="D:\笔记\照片\image-20221020194750735.png" alt="image-20221020194750735"></p>
<h3 id="DRAM-和SRAM"><a href="#DRAM-和SRAM" class="headerlink" title="DRAM 和SRAM"></a>DRAM 和SRAM</h3><p><img src="D:\笔记\照片\image-20221020200602254.png" alt="image-20221020200602254"></p>
<p>DRAM即动态RAM<br>SRAM即静态RAM )<br>DRAM用于主存、SRAM用于Cache高速缓存</p>
<p><strong>高频考点: DRAM和SRAM的对 比</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">DRAM芯片： 使用栅极电容存储信息<br><span class="hljs-section">SRAM芯片: 使用奴稳态触发器存储信息</span><br><span class="hljs-section">核心区别:存储元不一样</span><br><br></code></pre></td></tr></table></figure>

<p>DRAM 工作原理</p>
<img src="D:\笔记\照片\image-20221024110422051.png" alt="image-20221024110422051" style="zoom:50%;" />

<img src="D:\笔记\照片\image-20221024111131939.png" alt="image-20221024111131939" style="zoom:50%;" />





<h4 id="栅极电容存储信息"><a href="#栅极电容存储信息" class="headerlink" title="栅极电容存储信息"></a>栅极电容存储信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span>:电容内存储了电荷<br><span class="hljs-number">0</span>:电容内未存储电荷<br><br>读出<span class="hljs-number">1</span>: MOS管接通，电容放电，数据线，上产生电流<br>读出<span class="hljs-number">0</span>: MOS管接通后，数据线上无电流<br><br></code></pre></td></tr></table></figure>

<p><strong>‘电容放电信息被破坏，是破坏性读出读出后应有重写操作，也称“再生”</strong></p>
<p>成本低，集成度高，功耗大</p>
<h4 id="双稳态触发器-SRAM"><a href="#双稳态触发器-SRAM" class="headerlink" title="双稳态触发器 -  SRAM"></a>双稳态触发器 -  SRAM</h4><p>两根数据线读出数据 </p>
<p><img src="D:\笔记\照片\image-20221020201851885.png" alt="image-20221020201851885"></p>
<p><strong>读出数据，触发器状态保持稳定,是非破坏性读出，无需重写</strong></p>
<p>成本高，集成度低，功耗小</p>
<p><img src="D:\笔记\照片\image-20221020203530298.png" alt="image-20221020203530298"></p>
<p><img src="D:\笔记\照片\image-20221020203716750.png" alt=" "></p>
<h4 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h4><p><img src="D:\笔记\照片\image-20221020204812430.png" alt="image-20221020204812430"></p>
<p><img src="D:\笔记\照片\image-20221020205000016.png" alt="image-20221020205000016"></p>
<img src="D:\笔记\照片\image-20221020205031994.png" alt="image-20221020205031994" style="zoom:50%;" />

<img src="D:\笔记\照片\image-20221020205110740.png" alt="image-20221020205110740" style="zoom: 50%;" />

<p><img src="D:\笔记\照片\image-20221020205705925.png" alt="image-20221020205705925"> </p>
<h3 id="ROM只读存储器"><a href="#ROM只读存储器" class="headerlink" title="ROM只读存储器"></a>ROM只读存储器</h3><p>RAM芯片- –易失性,断电后数据消失<br>ROM芯片–非易失性，断电后数据不会丢失</p>
<img src="D:\笔记\照片\image-20221020210055462.png" alt="image-20221020210055462" style="zoom:25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">MROM 掩模式只读存储器<br>厂家按照客户需求，在芯片生产过程中直接写入信息，之后<span class="hljs-string">&#x27;任何人不可重写&#x27;</span>(只能读出)可靠性高、灵活性差、生产周期长、只适合批量定制<br><br>PROM -可编程只读存储器<br>用户可用专门的PROM写入器写入信息，<span class="hljs-string">&#x27;写一次之后就不可更改</span><br><span class="hljs-string"></span><br><span class="hljs-string">EPROM 可擦除可编程只读存储器</span><br><span class="hljs-string">允许用户写入信息，之后用某种方法擦除数据，可进行多次重写</span><br><span class="hljs-string">UVEPROM (ultraviolet rays)-用紫外线照射8~30分钟，擦除所有信息</span><br><span class="hljs-string">EEPROM (也常记为EPROM，第一个E是Electrically) - -- -可用“电擦除”的方式，擦除特定的字</span><br><span class="hljs-string"></span><br><span class="hljs-string">(Flash Memory- --闪速存储器(注: U盘、SD卡就是闪存)</span><br><span class="hljs-string">在EEPROM基础.上发展而来，断电后也能保存信息，且可进行多次快速擦除重写</span><br><span class="hljs-string">注意:由于闪存需要先擦除在写入，因此闪存的&#x27;</span>“写”速度要比“读”速度更慢。&#x27;<br><br> <span class="hljs-built_in">SSD</span> (Solid State Drives) -一固态硬盘<br>由控制单元+存储单元(Flash芯片)构成，与闪速存储器的核心区别在于控制单元不一样，存储介质都类似，可进行多次快速擦除重写。SSD速度快、功耗低、价格高。目前个人电脑上用SSD取代传统的机械硬盘<br><br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221020212430542.png" alt="image-20221020212430542"></p>
<p><img src="D:\笔记\照片\image-20221020212520941.png" alt="image-20221020212520941"></p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><img src="D:\笔记\照片\image-20221020212540078.png" alt="image-20221020212540078"></p>
<h2 id="CPU与主存储器的连接"><a href="#CPU与主存储器的连接" class="headerlink" title="CPU与主存储器的连接"></a>CPU与主存储器的连接</h2><p><img src="D:\笔记\照片\image-20221027162545343.png" alt="image-20221027162545343"></p>
<p><img src="D:\笔记\照片\image-20221027162836107.png" alt="image-20221027162836107"></p>
<p><strong>常用的输入输出表示</strong></p>
<p><img src="D:\笔记\照片\image-20221027163054108.png" alt="image-20221027163054108"></p>
<p>注意有无横线</p>
<pre><code class="hljs">1. 有横线代表低电平有效
1. 无横线代表高电平有效
</code></pre>
<h3 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h3><p>增加存储器的字长变的更长</p>
<p>更好的发挥数据总线的数据传输能力</p>
<p><img src="D:\笔记\照片\image-20221027163821495.png" alt="image-20221027163821495"></p>
<h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>增加存储器的存储子数，更好的利用CPU的寻址能力</p>
<ol>
<li><p><strong>线选法</strong></p>
<p><img src="D:\笔记\照片\image-20221027164204875.png" alt="image-20221027164204875"></p>
<p>CPU 中存在未使用的n条线，则可以添加 n个片选信号</p>
</li>
<li><p>译码器片选法</p>
<p><img src="D:\笔记\照片\image-20221027165052271.png" alt="image-20221027165052271"></p>
<p>CPU 为使用n条线，则可以添加 2的n次方个片选信号</p>
<p>3- 8译码器</p>
</li>
</ol>
<p><img src="D:\笔记\照片\image-20221027165517138.png" alt="image-20221027165517138"></p>
<p><img src="D:\笔记\照片\image-20221027165830476.png" alt="image-20221027165830476"></p>
<h3 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h3><p><img src="D:\笔记\照片\image-20221027170016619.png" alt="image-20221027170016619"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="D:\笔记\照片\image-20221027170243267.png" alt="image-20221027170243267"></p>
<p>”使能端“ ： 使移码器有效的端口</p>
<p><strong>74L138 有三个使能端</strong></p>
<p>注: CPU可 使用译码器的使能端控制片选信号的生效时间</p>
<p><img src="D:\笔记\照片\image-20221027170710573.png" alt="image-20221027170710573"></p>
<h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><p>CPU与存储器之间的速度无法匹配<br>解决之道</p>
<ul>
<li>采用高速器件提高速度;</li>
<li>采用双端口存储器;</li>
<li>增加字长，在每个存储周期中存取多个字。</li>
<li>将主存划分为多个模块，多模块并行</li>
<li>增加Cache;</li>
</ul>
<p> <img src="D:\笔记\照片\image-20221027201239285.png" alt="image-20221027201239285"></p>
<p>提升主存速率</p>
<p><img src="D:\笔记\照片\image-20221027201958655.png" alt="image-20221027201958655"></p>
<h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p>优化多核CPU访问一条内存的情况</p>
<p><img src="D:\笔记\照片\image-20221027202130609.png" alt="image-20221027202130609"></p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">两个端口对同一主存操作有以下4种情况:</span><br><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">两个端口同时对不同的地址单元存取数据。		</span><span class="hljs-literal">--</span><span class="hljs-comment">支持</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span><span class="hljs-comment">两个端口同时对同</span><span class="hljs-literal">--</span><span class="hljs-comment">地址单元读出数据。		</span><span class="hljs-literal">--</span><span class="hljs-comment">支持</span><br><br><span class="hljs-comment">3</span><span class="hljs-string">.</span><span class="hljs-comment">两个端口同时对同一地址单元写 入数据。		</span><span class="hljs-literal">--</span> <span class="hljs-comment">写错误</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span><span class="hljs-comment">两个端口同时对同一地址单元，</span><span class="hljs-literal">-</span> <span class="hljs-comment">一个写入数据，另一个读出数据。</span><span class="hljs-literal">--</span> <span class="hljs-comment">读错误</span><br><br><span class="hljs-comment">解决方法:置“忙”信号为0</span><span class="hljs-string">,</span><span class="hljs-comment">由判断逻辑决定暂时关闭</span><span class="hljs-literal">-</span><span class="hljs-comment">一个端口(即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。</span><br><br></code></pre></td></tr></table></figure>

<h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><p><img src="D:\笔记\照片\image-20221027203510123.png" alt="image-20221027203510123"></p>
<p>低位交叉编址的多体存储器</p>
<p>采用“流水线”的方式并行存取(宏观上并行，微观上串行)</p>
<p>宏观上，一个存储周期内，m体交叉存储器可以提供的数据量为单个模块的m倍<br>存取周期为T,存取时间为r,为了使流水线不间断，<br><strong>应保证模块数m≥T&#x2F;r</strong></p>
<p><img src="D:\笔记\照片\image-20221027204349779.png" alt="image-20221027204349779"></p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="D:\笔记\照片\image-20221027204720157.png" alt="image-20221027204720157"></p>
<h2 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h2><p><img src="D:\笔记\照片\image-20221107204837102.png" alt="image-20221107204837102"></p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p><img src="D:\笔记\照片\image-20221107212932132.png" alt="image-20221107212932132"></p>
<p>将主存的存储空间“分块”，如:每1KB为一块。主存与Cache之间以“块”为单位进行数据交换</p>
<p>4M&#x3D;222<br>1K&#x3D;2^10	整个主存被分为212 &#x3D; 4096块</p>
<p><img src="D:\笔记\照片\image-20221107215219862.png" alt="image-20221107215219862"></p>
<h3 id="Cache-主存的映射方式"><a href="#Cache-主存的映射方式" class="headerlink" title="Cache- 主存的映射方式"></a>Cache- 主存的映射方式</h3><ol>
<li><strong>全相联映射方式</strong> ： Cache中数据可以来自主存中任何地方</li>
<li><strong>直接相连映射方式</strong>：每个主存块只能放到一一个特定的位置:<br>   Cache块号&#x3D;主存块号% Cache总块数</li>
<li><strong>组相连映射方式</strong>：Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置<br>   组号&#x3D;主存块号%分组数.</li>
</ol>
<p><img src="D:\笔记\照片\image-20221108104439898.png" alt="image-20221108104439898"></p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p><img src="D:\笔记\照片\image-20221108104905080.png" alt="image-20221108104905080"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">标记(整个主存块号)+块内地址<br><br>优点: Cache存储空间利用充分，命中率高;缺点:查找“标记”最慢，有可能需要对比所有行的标记<br><br></code></pre></td></tr></table></figure>

<h4 id="直接相联映射"><a href="#直接相联映射" class="headerlink" title="直接相联映射"></a>直接相联映射</h4><p><img src="D:\笔记\照片\image-20221108105219527.png" alt="image-20221108105219527"></p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">标记位记录可以 进行优化， <span class="hljs-keyword">Cache</span>总块数为 <span class="hljs-number">2</span>^n 末位位可以不用保存<br><br>标记(主存块号前几位)+行号(主存块号末几位)块内地址<br><br>优点:对于任意-个地址，只需对比一个“标记”，速度最快;缺点: <span class="hljs-keyword">Cache</span>存储空间利用不充分，命中率低<br><br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221108105629232.png" alt="image-20221108105629232"></p>
<h4 id="组相联映射方法"><a href="#组相联映射方法" class="headerlink" title="组相联映射方法"></a>组相联映射方法</h4><p><img src="D:\笔记\照片\image-20221108105835255.png" alt="image-20221108105835255"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">标记位 将组号优化出去<br><br>标记<span class="hljs-comment">(主存块号前几位)</span>+组号<span class="hljs-comment">(主存块号末几位)</span>块内地址<br><br>优点:另外两种方式的折中，综合效果较好<br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221108110009763.png" alt="image-20221108110009763"></p>
<p><img src="D:\笔记\照片\image-20221108110044730.png" alt="image-20221108110044730"></p>
<h3 id="Cache的替换算法"><a href="#Cache的替换算法" class="headerlink" title="Cache的替换算法"></a>Cache的替换算法</h3><p>全相联映射：<strong>Cache完全满了</strong>才需要替换需要在<strong>全局选择</strong>替换哪一块</p>
<p>直接映射：如果对应位置非空，则毫无选择地直接替换</p>
<p>组相连映射：<strong>分组内满了</strong>才需要替换需要在<strong>分组内选择</strong>替换哪一块</p>
<p><img src="D:\笔记\照片\image-20221108110757171.png" alt="image-20221108110757171"></p>
<h4 id="随机算法RAND"><a href="#随机算法RAND" class="headerlink" title="随机算法RAND"></a>随机算法RAND</h4><p><img src="D:\笔记\照片\image-20221108111000872.png" alt="image-20221108111000872"></p>
<h4 id="先进先出算法FIFO"><a href="#先进先出算法FIFO" class="headerlink" title="先进先出算法FIFO"></a>先进先出算法FIFO</h4><p><img src="D:\笔记\照片\image-20221108111216081.png" alt="image-20221108111216081"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">抖动现象:频繁的换入换出现象.<span class="hljs-comment">(刚被替换的块很快又被调入)</span><br></code></pre></td></tr></table></figure>

<h4 id="近期最少使用算法LRU"><a href="#近期最少使用算法LRU" class="headerlink" title="近期最少使用算法LRU"></a>近期最少使用算法LRU</h4><p><img src="D:\笔记\照片\image-20221108111737597.png" alt="image-20221108111737597"></p>
<p>硬件实现</p>
<p><img src="D:\笔记\照片\image-20221108112413361.png" alt="image-20221108112413361"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">LRU算法- -基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀Cache命中率高。<br><br>若被频繁访问的主存块数量&gt; Cache行的数量，则有可能发生“抖动”，如: &#123;<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,1,2,5</span>,<span class="hljs-number">1</span>,..&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="最不经常使用算法-LFU"><a href="#最不经常使用算法-LFU" class="headerlink" title="最不经常使用算法 LFU"></a>最不经常使用算法 LFU</h4><p><img src="D:\笔记\照片\image-20221108112805844.png" alt="image-20221108112805844"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">LFU算法——曾经被经常访问的主存块在未来不一定会用到(如:微信视频聊天相关的块)，并没有很好地遵循<span class="hljs-string">&#x27;局部性原理&#x27;</span>，因此实际运行效果不如LRU<br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221108112927652.png" alt="image-20221108112927652"></p>
<h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><p><img src="D:\笔记\照片\image-20221108113054770.png" alt="image-20221108113054770"></p>
<h4 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h4><p><strong>写回法</strong>(write-back)-当CPU对Cache写 命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存</p>
<p><img src="D:\笔记\照片\image-20221108113236815.png" alt="image-20221108113236815"></p>
<h4 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h4><p>(<strong>全写法</strong>写直通法，write-through)- 当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)</p>
<p><img src="D:\笔记\照片\image-20221108113326074.png" alt="image-20221108113326074"></p>
<p><img src="D:\笔记\照片\image-20221108114202402.png" alt="image-20221108114202402"></p>
<h4 id="写分配法-和-非写分配法"><a href="#写分配法-和-非写分配法" class="headerlink" title="写分配法 和 非写分配法"></a>写分配法 和 非写分配法</h4><p><img src="D:\笔记\照片\image-20221108114256968.png" alt="image-20221108114256968"></p>
<p><img src="D:\笔记\照片\image-20221108114324673.png" alt="image-20221108114324673"></p>
<p><img src="D:\笔记\照片\image-20221108114534223.png" alt="image-20221108114534223"></p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img src="D:\笔记\照片\image-20221108114710298.png" alt="image-20221108114710298"></p>
<h3 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h3><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><img src="D:\笔记\照片\image-20221111203112865.png" alt="image-20221111203112865"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>总线是一组能为多个部件分时共享的公共信息传送线路。</p>
<ul>
<li>共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。</li>
<li>分时是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</li>
</ul>
<h3 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">1.机械特性:尺寸、形状、管脚数、排列顺序</span><br><span class="hljs-section">2.电气特性:传输方向和有效的电平范围</span><br><span class="hljs-section">3.功能特性:每根传输线的功能(地址、数据、控制)</span><br><span class="hljs-section">4.时间特性:信号的时序关系</span><br><br></code></pre></td></tr></table></figure>

<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="D:\笔记\照片\image-20221111204502733.png" alt="image-20221111204502733"></p>
<p><strong>传输格式分类</strong></p>
<p><img src="D:\笔记\照片\image-20221111205137374.png" alt="image-20221111205137374"></p>
<p><img src="D:\笔记\照片\image-20221111205652096.png" alt="image-20221111205652096"></p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><img src="D:\笔记\照片\image-20221114194940410.png" alt="image-20221114194940410"></p>
<p><strong>指令(又称机器指令)</strong> :是指示计算机执行某种操作的命令,是计算机运行的最小功能单位。<br>一台计算机的所有指令的集合构成该机的<strong>指令系统</strong>，也称为<strong>指令集</strong>。</p>
<ul>
<li>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码</li>
<li>一条指令通常要包括操作码字段和地址码字段</li>
</ul>
<h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><p><img src="D:\笔记\照片\image-20221114195756099.png" alt="image-20221114195756099"></p>
<h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><p><img src="D:\笔记\照片\image-20221114203900241.png" alt="image-20221114203900241"></p>
<h4 id="二、三地址指令"><a href="#二、三地址指令" class="headerlink" title="二、三地址指令"></a>二、三地址指令</h4><p><img src="D:\笔记\照片\image-20221114204022119.png" alt="image-20221114204022119"></p>
<h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><p><img src="D:\笔记\照片\image-20221114204240173.png" alt="image-20221114204240173"></p>
<h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p><img src="D:\笔记\照片\image-20221114204348450.png" alt="image-20221114204348450"></p>
<h4 id="按指令长度分类"><a href="#按指令长度分类" class="headerlink" title="按指令长度分类"></a>按指令长度分类</h4><p><strong>指令长度</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">指令字长一条指令的总长度<span class="hljs-comment">(可能会变)</span><br>机器字长:CPU进行一次整数运算所能处理的二进制数据的位数<span class="hljs-comment">(通常和ALU直接相关)</span><br>存储字长:一个存储单元中的二进制代码位数<span class="hljs-comment">(通常和MDR位数相同)</span><br></code></pre></td></tr></table></figure>

<p><strong>半字长指令、单字长指令、双字长指令		—— 指令长度是机器字长的多少倍</strong></p>
<p>指令字长会影响取指令所需时间。</p>
<p> 如:机器字长&#x3D;存储字长&#x3D;16bit，则取一条双字长指令需要两次访存</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">定长指令字结构: 	指令系统中所有指令的长度都相等</span><br><span class="hljs-section">变长指令字结构:	指令系统中各种指今的长度不等</span><br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221121113458385.png" alt="image-20221121113458385"></p>
<h4 id="按操作类型分类"><a href="#按操作类型分类" class="headerlink" title="按操作类型分类"></a>按操作类型分类</h4><p><img src="D:\笔记\照片\image-20221121113843553.png" alt="image-20221121113843553"></p>
<p>总结</p>
<p><img src="D:\笔记\照片\image-20221121114006448.png" alt="image-20221121114006448"></p>
<h3 id="扩展操作码"><a href="#扩展操作码" class="headerlink" title="扩展操作码"></a>扩展操作码</h3><p>定长指令字结构 + 可边长操作码 &#x3D; 扩展操作码指令格式</p>
<p>不同地址数的指令使用不同长度的操作码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">全1111</span> <span class="hljs-string">保留作为扩展操作码</span><br><span class="hljs-string">...</span>		   <span class="hljs-number">3</span><span class="hljs-string">地址指令</span><br><span class="hljs-number">1111</span>  <span class="hljs-string">...</span>  <span class="hljs-number">2</span><span class="hljs-string">地址指令</span><br><span class="hljs-number">1111 </span><span class="hljs-number">1111  </span><span class="hljs-number">1</span><span class="hljs-string">地址指令</span><br><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">0</span><span class="hljs-string">地址指令</span><br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221121170722693.png" alt="image-20221121170722693"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">注： 不允许短码是长码的前缀 及1111 地址保留<br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221129143629556.png" alt="image-20221129143629556"></p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>PC程序计数器始终指向下一条预执行的指令地址</p>
<p><strong>按字编址</strong></p>
<p><img src="D:\笔记\照片\image-20221129145434471.png" alt="image-20221129145434471"></p>
<p><strong>按字节编址</strong></p>
<p>一条指令占 2个字  PC应该改为 一次加2</p>
<p><img src="D:\笔记\照片\image-20221129150118601.png" alt="image-20221129150118601"></p>
<p><strong>变长指令字</strong></p>
<p><img src="D:\笔记\照片\image-20221129150413413.png" alt="image-20221129150413413"></p>
<h4 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h4><p><img src="D:\笔记\照片\image-20221129150503115.png" alt="image-20221129150503115"></p>
<h4 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h4><p><img src="D:\笔记\照片\image-20221129150856967.png" alt="image-20221129150856967"></p>
<h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p><img src="D:\笔记\照片\image-20221129150918968.png" alt="image-20221129150918968"></p>
<h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>对于转移指令的解读不同 数据寻址有不同的寻址方式</p>
<p><img src="D:\笔记\照片\image-20221129151551093.png" alt="image-20221129151551093"></p>
<p><img src="D:\笔记\照片\image-20221129151905157.png" alt="image-20221129151905157"></p>
<p><img src="D:\笔记\照片\image-20221129151929522.png" alt="image-20221129151929522"></p>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>直接寻址:指令字中的形式地址A就是操作数的真实地址EA，即EA&#x3D;A。</p>
<p><img src="D:\笔记\照片\image-20221129152824779.png" alt="image-20221129152824779"></p>
<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>间接寻址:指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址<br>所在的存储单元的地址，也就是操作数地址的地址，即EA&#x3D;(A)。</p>
<p><img src="D:\笔记\照片\image-20221129153633499.png" alt="image-20221129153633499"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">优点:<br>可扩大寻址范围<span class="hljs-comment">(有效地址EA的位数大于形式地址A的位数)</span>。<br>便于编制程序<span class="hljs-comment">(用间接寻址可以方便地完成子程序返回)</span>。<br><br>决点:指令在执行阶段要多次访存<span class="hljs-comment">(--次间址需两欠访存，多次寻址需根据存储字的最高位角定几次访存)</span>。<br><br></code></pre></td></tr></table></figure>

<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>寄存器寻址:在指令字中直接给出操作数所在的寄存器编号，即EA&#x3D;R，其操作数在由R;所指的寄存器内。</p>
<p><img src="D:\笔记\照片\image-20221129154207899.png" alt="image-20221129154207899"></p>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>寄存器间接寻址:寄存器R中给出的不是-一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;(R)。</p>
<p><img src="D:\笔记\照片\image-20221129154320700.png" alt="image-20221129154320700"></p>
<h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>隐含寻址:不是明显地给出操作数的地址，而是在指令中<strong>隐含着操作数</strong>的地址。</p>
<p><img src="D:\笔记\照片\image-20221129154512069.png" alt="image-20221129154512069"></p>
<h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>立即寻址: (<strong>形式地址A就是操作数本身</strong>，又称为立即数，一般采用<strong>补码</strong>形式。<br>         #表示立即寻址特征。</p>
<p><img src="D:\笔记\照片\image-20221129154713979.png" alt="image-20221129154713979"></p>
<p><img src="D:\笔记\照片\image-20221129154735086.png" alt="image-20221129154735086"></p>
<h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><p><img src="D:\笔记\照片\image-20221129163811028.png" alt="image-20221129163811028"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">基址寻址:以程序的起始存放地址作为“起点”</span><br><span class="hljs-section">变址寻址:程序员自己决定从哪里作为“起点”</span><br><span class="hljs-section">相对寻址:以程序计数器PC所指地址作为“起点”</span><br><br></code></pre></td></tr></table></figure>

<h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>基址寻址:将**CPU中基址寄存器(BR)**的内容加上指令格式中的形式地址A,.<br>而形成操作数的有效地址，即EA&#x3D;(BR)+A。</p>
<p><img src="D:\笔记\照片\image-20221129164308193.png" alt="image-20221129164308193"></p>
<p><img src="D:\笔记\照片\image-20221129164718054.png" alt="image-20221129164718054"></p>
<p>注:<strong>基址寄存器是面向操作系统</strong>的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)。<br>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器</strong>作为基址寄存器，但<strong>其内容仍由操作系统确定</strong>。</p>
<p>优点:可扩大得址范围(基址寄存器的位数大于形式地址A的位数) ;用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于**编制浮动程序(整个程序在内存里边的浮动)**。</p>
<h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>变址寻址:有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和,<br>即<strong>EA&#x3D; (IX)+A</strong>，其中**IX可为变址寄存器(专用)**，也可用通用寄存器作为变址寄存器</p>
<p><img src="D:\笔记\照片\image-20221129165046658.png" alt="image-20221129165046658"></p>
<p>注:变址寄存器是<strong>面向用户</strong>的，在程序执行过程中，变址寄存器的内容可由用户改变(<strong>IX作为偏移量)<strong>，形式地址</strong>A不变(作为基地址)</strong></p>
<p><img src="D:\笔记\照片\image-20221129170053058.png" alt="image-20221129170053058"></p>
<h4 id="基址-编址复合"><a href="#基址-编址复合" class="headerlink" title="基址&amp;编址复合"></a>基址&amp;编址复合</h4><p><strong>先基址后变址寻址: EA&#x3D;(IX)+((BR)+A)</strong></p>
<p><img src="D:\笔记\照片\image-20221129170337984.png" alt="image-20221129170337984"></p>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>相对寻址:把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即<strong>EA&#x3D;(PC)+A</strong>，其中<strong>A是相对于PC所指地址的位移量</strong>，可正可负，<strong>补码表示</strong>。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">当取出一条指令时 <span class="hljs-built_in">PC</span>值会自动 + “<span class="hljs-number">1</span>”<br>及 A 是相当于 下一条指令的位移量<br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221129170659916.png" alt="image-20221129170659916"></p>
<p>例子 方便某段代码在程序 内部浮动</p>
<p><img src="D:\笔记\照片\image-20221129171315455.png" alt="image-20221129171315455"></p>
<p>优点:操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此<strong>便于程序浮动(一段代码在程序内部的浮动)。</strong><br><strong>相对寻址广泛应用于转移指令。</strong></p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><img src="D:\笔记\照片\image-20221129171900524.png" alt="image-20221129171900524"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">有点机器吧 PSW 称为 “标志寄存器”<br></code></pre></td></tr></table></figure>

<h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>堆栈寻址:操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。</p>
<p><img src="D:\笔记\照片\image-20221129172449614.png" alt="image-20221129172449614"></p>
<p><img src="D:\笔记\照片\image-20221129172539663.png" alt="image-20221129172539663"></p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="D:\笔记\照片\image-20221129172618763.png" alt="image-20221129172618763"></p>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>  CPU 由运算器 和 控制器组成</p>
<p><strong>运算器</strong>  由 ACC ＭＱ　Ｘ　ALU组成</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ACC:</span><br>累加器，用于存放操作数，或运算结果。<br><span class="hljs-symbol">MQ:</span><br>乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。<br><span class="hljs-symbol">X:</span><br>通用的操作数寄存器，用于存放操作数<br><span class="hljs-symbol">ALU:</span><br>算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算<br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221201135159735.png" alt="image-20221201135159735"></p>
<p><strong>控制器</strong>　由　CU　IR  PC</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm">CU： 控制单元，分析指令，给出控制信号<br><span class="hljs-symbol">IR:</span> 指令寄存器，存放当前执行的指令<br><span class="hljs-symbol">PC:</span> 程序计数器，存放下一条指令地址，有自动加<span class="hljs-number">1</span>功能<br><br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221201135302813.png" alt="image-20221201135302813"></p>
<h2 id="CPU-功能"><a href="#CPU-功能" class="headerlink" title="CPU 功能"></a>CPU 功能</h2><ol>
<li><strong>指令控制</strong>。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</li>
<li><strong>操作控制</strong>。一条指令的功能往往是由若干操作信号的组合来实现的。CPU管<br>理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件从而控制这些部件按指令的要求进行动作。</li>
<li><strong>时间控制</strong>。对各种操作加以时间上的控制。时间控制要为每条指令按时间<br>顺序提供应有的控制信号。</li>
<li><strong>数据加工</strong>。对数据进行算术和逻辑运算。</li>
<li><strong>中断处理</strong>。对计算机运行过程中出现的异常情况和特殊请求进行处理。</li>
</ol>
<p>讲功能分给 运算器 和 控制器</p>
<p><img src="D:\笔记\照片\image-20221201150040768.png" alt="image-20221201150040768"></p>
<h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">1</span>.算术逻辑单元:主要功能是进行算术/逻辑运算。<br><span class="hljs-number">2</span>.通用寄存器组:如<span class="hljs-built_in">AX</span>、 <span class="hljs-built_in">BX</span>、<span class="hljs-built_in">CX</span>、<span class="hljs-built_in">DX</span>、<span class="hljs-built_in">SP</span>等，用于存放操作数(包括源操作数、目的操作数及中间结果)和各种地址信息等。<span class="hljs-built_in">SP</span>是堆栈指针，用于指示栈顶的地址<br><br></code></pre></td></tr></table></figure>

<p><strong>专用数据通路方式</strong></p>
<p><img src="D:\笔记\照片\image-20221201151429469.png" alt="image-20221201151429469"></p>
<p><strong>CPU内部单总线方式</strong>:将所有寄存器的输入端和输出端都连接到一条公共的通路上。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">3.暂存寄存器:用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。</span><br><br><span class="hljs-section">如:两个操作数分别来自主存和Ro,最后结果存回R。</span><br>   那么从主存中取来的操作数直接放入暂存器，就不会破坏运算前Ro的内容。<br><br></code></pre></td></tr></table></figure>

<p><img src="D:\笔记\照片\image-20221201151859161.png" alt="image-20221201151859161"></p>
<p><strong>运算器基本结构完整</strong></p>
<p><img src="D:\笔记\照片\image-20221201152253185.png" alt="image-20221201152253185"></p>
<h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="D:\笔记\照片\image-20221201154748286.png" alt="image-20221201154748286"></p>
<h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p><img src="D:\笔记\照片\image-20221201155043953.png" alt="image-20221201155043953"></p>
<p><img src="D:\笔记\照片\image-20221201155116403.png" alt="image-20221201155116403"></p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><img src="D:\笔记\照片\image-20221201155202568.png" alt="image-20221201155202568"></p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>指令周期:CPU从主存中每取出并执行一条指令所需的全部时间。</p>
<p><strong>指令周期</strong>常常用若干<strong>机器周期</strong>来表示，机器周期又叫CPU周期。<br>一个<strong>机器周期</strong>又包含若干<strong>时钟周期</strong>(也称为<strong>节拍</strong>、<strong>T周期</strong>或<strong>CPU时钟周期</strong>，它是<strong>CPU操作的最基本单位</strong>)。</p>
<img src="D:\笔记\照片\image-20221201193100859.png" alt="image-20221201193100859" style="zoom:33%;" />

<p><img src="D:\笔记\照片\image-20221201193041478.png" alt="image-20221201193041478"></p>
<p>每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。</p>
<h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><img src="D:\笔记\照片\image-20221201200715841.png" alt="image-20221201200715841"></p>
<p><img src="D:\笔记\照片\image-20221201200752576.png" alt="image-20221201200752576"></p>
<p>指令周期流程</p>
<p><img src="D:\笔记\照片\image-20221201200904282.png" alt="image-20221201200904282"></p>
<p>如何判断属于哪个周期呢</p>
<p><img src="D:\笔记\照片\image-20221201201010733.png" alt="image-20221201201010733"></p>
<h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="D:\笔记\照片\image-20221201202457211.png" alt="image-20221201202457211"></p>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="D:\笔记\照片\image-20221201203946885.png" alt="image-20221201203946885"></p>
<p>注：第四步可以 直接讲MDR中的实际地址 给到 MAR 指明操作数的存放地址</p>
<h3 id="指令周期-1"><a href="#指令周期-1" class="headerlink" title="指令周期"></a>指令周期</h3><p>执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。 </p>
<h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p>中断:暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点</p>
<p>一般使用<strong>推栈</strong>来保存断点，这里用<strong>SP表示栈顶地址</strong>，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据。</p>
<p>注 ：实际情况一般先存入高地址， 再存入低地址 SP–</p>
<p><img src="D:\笔记\照片\image-20221201210154525.png" alt="image-20221201210154525"></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>. CU控制将<span class="hljs-built_in">SP</span>减<span class="hljs-number">1</span>，修改后的地址送入<span class="hljs-keyword">MAR</span><br>		记做: (<span class="hljs-built_in">SP</span>)-<span class="hljs-number">1</span> &gt; <span class="hljs-built_in">SP</span>，(<span class="hljs-built_in">SP</span>) &gt; <span class="hljs-keyword">MAR</span> <br>		本质上是将断点存入某个存储单元，假设其地址为a，故可记做:a+&gt; <span class="hljs-keyword">MAR</span><br><span class="hljs-number">2</span>. CU发出控制信号，启动主存做写操作，<br>		记做: <span class="hljs-number">1</span>&gt; W<br><span class="hljs-number">3</span>.将断点(<span class="hljs-built_in">PC</span>内容)送入MDR,<br>		记做:(<span class="hljs-built_in">PC</span>)→MDR<br><span class="hljs-number">4</span>.CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入<span class="hljs-built_in">PC</span>,<br>		记做:向量地址-&gt;<span class="hljs-built_in">PC</span><br><br></code></pre></td></tr></table></figure>

<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p>一个指令周期通常要包括几个时间段(执行步骤)，每个步骤完成指令的一-部分功能，几个依次执行的步骤完成这条指令的全部功能。</p>
<p><strong>单指令周期</strong></p>
<img src="D:\笔记\照片\image-20221201210713855.png" alt="image-20221201210713855" style="zoom:33%;" />

<p>指令之间串行执行;<strong>指令周期取决于执行时间最长的指令的执行时间</strong>。</p>
<p>对于那些本来可以在更短时间内完成的指令，要使用这个<strong>较长的周期来完成</strong>，会降低整个系统的运行速度。</p>
<p><strong>多指令周期</strong></p>
<p><img src="D:\笔记\照片\image-20221201210832437.png" alt="image-20221201210832437"></p>
<p><strong>流水线周期</strong></p>
<p><img src="D:\笔记\照片\image-20221201210958571.png" alt="image-20221201210958571"></p>
<p>资源空闲让给其他 指令使用</p>
<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="D:\笔记\照片\image-20221201211044754.png" alt="image-20221201211044754"></p>
]]></content>
      <tags>
        <tag>考研</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法模板</title>
    <url>/2022/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">	分治<br><span class="hljs-number">1</span>.确定分界点   <span class="hljs-string">q[r]</span>  随机<br><span class="hljs-number">2</span>.调整区间, 左边区间&lt;=<span class="hljs-keyword">x</span> ，右边&gt;=<span class="hljs-keyword">x</span> (分界点不一定为<span class="hljs-keyword">x</span>)<br><span class="hljs-number">3</span>.递归处理左右两段<br></code></pre></td></tr></table></figure>

<p>暴力：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl"><span class="hljs-number">1</span>.a[] b[]<br><span class="hljs-number">2</span>.<span class="hljs-string">q[i~r]</span> 遍历 将 <span class="hljs-string">q[i]</span> &lt;= <span class="hljs-keyword">x</span> -&gt; a[]<br>			  <span class="hljs-string">q[i]</span> &gt;  <span class="hljs-keyword">x</span> -&gt; b[]	<br><span class="hljs-number">3</span>.在将 a[] b[] 放入<span class="hljs-string">q[]</span> 中		  <br></code></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">i <span class="hljs-keyword">j </span><br>i从头开始遍历， <span class="hljs-keyword">j从尾开始遍历</span><br><span class="hljs-keyword"></span><br><span class="hljs-number">1</span>.i遍历寻找到一个 大于 x的数, 然后<span class="hljs-keyword">j遍历 </span>寻找一个小于 x的数<br><span class="hljs-number">2</span>. i 与 <span class="hljs-keyword">j </span>交换<span class="hljs-keyword">swap</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>. 重复上述过程遍历， 直至i与<span class="hljs-keyword">j相遇</span><br></code></pre></td></tr></table></figure>

<p>快速选择算法</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">快排的思想<br><span class="hljs-number">1</span>.找到分界点<span class="hljs-keyword">x</span>,<span class="hljs-string">q[L]</span>,<span class="hljs-string">q[(L+R)/2]</span>,<span class="hljs-string">q[R]</span><br><span class="hljs-number">2</span>.左边所有数Left &lt;= <span class="hljs-keyword">x</span>, 右边所有数Right &gt;= <span class="hljs-keyword">x</span><br><span class="hljs-number">3</span>.递归排序Left , 递归排序Right<br><br>快速选择<br>	k &lt;= s1, 递归Lelf<br>	k &gt; s1, 递归Right<br>只选择一边递归	<br><br>时间复杂度 ：<span class="hljs-number">2</span>n<br></code></pre></td></tr></table></figure>

<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><h3 id="快速排序算法模板"><a href="#快速排序算法模板" class="headerlink" title="快速排序算法模板"></a>快速排序算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="归并排序算法模板"><a href="#归并排序算法模板" class="headerlink" title="归并排序算法模板"></a>归并排序算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="整数二分算法模板"><a href="#整数二分算法模板" class="headerlink" title="整数二分算法模板"></a>整数二分算法模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">bool <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="浮点数二分算法模板"><a href="#浮点数二分算法模板" class="headerlink" title="浮点数二分算法模板"></a>浮点数二分算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure>

<h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure>



<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>

<h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure>





<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>Trie 高效的存储和查找字符串</p>
<p>集合的数据结构</p>
<p>用处：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 存储字符串集合<br><span class="hljs-bullet">2.</span> 高效的查找 某一个单词 在集合中出现是否出现过<br></code></pre></td></tr></table></figure>

<p>说明</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">1. son<span class="hljs-comment">[N]</span><span class="hljs-comment">[26]</span> 存储Trie树 ， 26列字母    str字符串每一位占一行 （竖着排列）<br>2. cnt<span class="hljs-comment">[N]</span> 存储以这个点为结尾单词个数 <br>            **cnt<span class="hljs-comment">[N]</span>  由于idx 不回头  <br>            abcf 最后一位 p = 4<br>            下一个字符串<br>            abcg 只有最后一位需要增加  p = 5<br>            abcf 与 abcg cnt<span class="hljs-comment">[N]</span> 存在不同位置**<br>3. idx 记录当前使用到那个下标 <br></code></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>作用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>将两个集合合并<br><span class="hljs-number">2.</span>询问两个元素是否在一个集合当中<br></code></pre></td></tr></table></figure>

<p>基本原理</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">基本原理:每个集合用-棵树来表示。树根的编号就是整个集合的编号。每<br>个节点存储它的父节点，p[<span class="hljs-keyword">x</span>]表示<span class="hljs-keyword">x</span>的父节点<br><br>问题<span class="hljs-number">1</span>:如何判断树根: if (p[<span class="hljs-keyword">x</span>]<span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>)<br>问题<span class="hljs-number">2</span>:如何求<span class="hljs-keyword">x</span>的集合编号: while (p[<span class="hljs-keyword">x</span>]!<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>)<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> p[<span class="hljs-keyword">x</span>]<span class="hljs-comment">;</span><br>问题<span class="hljs-number">3</span>：如何合并集合 px是<span class="hljs-keyword">x</span>的集合编号，py是y的集合编号。p[<span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> y<br><br>优化<span class="hljs-number">1</span>：路径压缩<br></code></pre></td></tr></table></figure>





<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector,变长数组，倍增的思想<br>string,<br>字符串，<span class="hljs-built_in">substr</span>(), <span class="hljs-built_in">c_str</span>()<br>queue，队列，<span class="hljs-built_in">push</span>(), <span class="hljs-built_in">front</span>(), <span class="hljs-built_in">pop</span>()<br>priority_ queue,优先队列，<span class="hljs-built_in">push</span>(), <span class="hljs-built_in">top</span>()， <span class="hljs-built_in">pop</span>()<br>stack,栈，<span class="hljs-built_in">push</span>(), <span class="hljs-built_in">top</span>(), <span class="hljs-built_in">pop</span>()<br>deque，双端队列<br>set, map, multiset, multimap, 基于平衡二叉树(红黑树)，动态维护有序序列<br>unordered_ set, unordered_ _map, unordered_ multiset, unordered_ multimap, 哈希表<br>bitset,庄位<br><br></code></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;vector,变长数组，倍增的思想</span><br><span class="hljs-string">    vector&lt;int&gt; a;</span><br><span class="hljs-string">    vector&lt;int&gt; a(-3, 10);</span><br><span class="hljs-string"></span><br><span class="hljs-string">    a.size();	返回元素个数</span><br><span class="hljs-string">    a.empty();	返回是否为空</span><br><span class="hljs-string">    a.clear();	清空</span><br><span class="hljs-string">	front() / back() 返回vetocr第一个数 / 最后一个数</span><br><span class="hljs-string">	push_back() / pop_back() 插入/删除最后一个数</span><br><span class="hljs-string">	begin() / end()</span><br><span class="hljs-string">        </span><br><span class="hljs-string">    </span><br><span class="hljs-string">系统为某一程序分配空间时，所需时间与空间大小无关，与分配次数有关</span><br><span class="hljs-string">	所以要尽可能减少请求空间次数</span><br><span class="hljs-string">        </span><br><span class="hljs-string">遍历       </span><br><span class="hljs-string"> vector&lt;int&gt; a;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    for(int i = 0; i &lt; 10; i++) a.push_back(i);</span><br><span class="hljs-string"></span><br><span class="hljs-string">    //遍历</span><br><span class="hljs-string">    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt;&quot; &quot;;</span><br><span class="hljs-string">    cout &lt;&lt; endl;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    //迭代器遍历</span><br><span class="hljs-string">    for(vector&lt;int&gt; ::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt;&#x27;</span> <span class="hljs-string">&#x27;;</span><br><span class="hljs-string">	for(auto i = a.begin(); i != a.end(); i++)</span><br><span class="hljs-string">    cout &lt;&lt; endl;</span><br><span class="hljs-string">    // a.begin() = a[0]</span><br><span class="hljs-string">    // a.end() = a[a.size()] 最后一个数的下一个数</span><br><span class="hljs-string">    // a.begin() a. end() 相当于指针 可以直接使用 *i</span><br><span class="hljs-string">    // vetcor&lt;int&gt; :: iterator 可以直接换成 auto c++自己推断类型</span><br><span class="hljs-string"></span><br><span class="hljs-string">    //foreach遍历</span><br><span class="hljs-string">    for(auto x : a) cout &lt;&lt; x &lt;&lt; &#x27;</span> <span class="hljs-string">&#x27;;</span><br><span class="hljs-string">    cout &lt;&lt; endl;   </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">vector 支持比较运算</span><br><span class="hljs-string">    vector&lt;int&gt; a(4,3) b(3,4);</span><br><span class="hljs-string">	按字典比较 a三个4 小于 b 4个3</span><br><span class="hljs-string">	if(a &lt; b) puts(&quot;a &lt; b&quot;);</span><br></code></pre></td></tr></table></figure>

<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">pair</span>(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>)<br>    first, 第一个元素<br>    second，第二个元素<br>	<span class="hljs-comment">//支持比较运算， 以first为第一关键字, second为第二关键字</span><br>    <br>    <br>	pair&lt;<span class="hljs-type">int</span>, String&gt; p;<br>	p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;crx&quot;</span>);<br>	p = &#123;<span class="hljs-number">19</span>, <span class="hljs-string">&quot;ddd&quot;</span>&#125;;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;p<br>        <br>可以将需要比较的元素放在first 直接比较pair就可以<br></code></pre></td></tr></table></figure>



<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">字符串，<span class="hljs-built_in">substr</span>(), <span class="hljs-built_in">c_str</span>()<br><span class="hljs-built_in">size</span>()<br><span class="hljs-built_in">empty</span>()<br><span class="hljs-built_in">clear</span>()<br><br>    string a = <span class="hljs-string">&quot;abc&quot;</span>;<br>    a += <span class="hljs-string">&quot;ccc&quot;</span>;<br>    a += <span class="hljs-string">&quot;ddd&quot;</span>;<br><br>	<span class="hljs-built_in">substr</span>(起始位置， 长度)<br>    cout &lt;&lt; a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">//返回给定长度的 字符串子串</span><br>    a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s/n&quot;</span> ,a.<span class="hljs-built_in">c_str</span>()); <br>    <span class="hljs-comment">// 输出字符串 需要获取字符串的起始地址 c_str() 可以获得起始地址</span><br></code></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">size</span>()<br><span class="hljs-built_in">empty</span>()<br><span class="hljs-built_in">push</span>() 向队尾插入一个元素<br><span class="hljs-built_in">front</span>()返回队头元素<br><span class="hljs-built_in">back</span>() 返回队尾元素<br><span class="hljs-built_in">pop</span>()  弹出队头元素<br><br>没有clear 函数 <br>	q = queue&lt;<span class="hljs-type">int</span>&gt;<br></code></pre></td></tr></table></figure>

<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_ queue"></a>priority_ queue</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//priority_ queue, 优先队列，默认是大根堆</span><br>    <span class="hljs-built_in">push</span>()插入一个元素 <br>    <span class="hljs-built_in">top</span>()返回堆顶元素<br>    <span class="hljs-built_in">pop</span>()弹 出堆顶元素<br>        <br>如果像用小根堆<br>   <span class="hljs-number">1.</span> <span class="hljs-string">&#x27;在存入的时候存入负数</span><br><span class="hljs-string">   2. 定义的时候</span><br><span class="hljs-string">        priority_queue&lt;int, vetcor&lt;int&gt;, greater&lt;int&gt;&gt; heap;</span><br><span class="hljs-string">	</span><br></code></pre></td></tr></table></figure>

<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">stack,栈<br>    <span class="hljs-built_in">size</span>( )<br>    <span class="hljs-built_in">empty</span>( )<br>    <span class="hljs-built_in">push</span>()向 栈顶插入一个元素<br>    <span class="hljs-built_in">top</span>()返回栈顶元素<br>    <span class="hljs-built_in">pop</span>() 弹出栈顶元素<br><br></code></pre></td></tr></table></figure>



<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">双端队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    push_ _back()/pop_ _back()<br>    push_ _front()/pop_ _front()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br></code></pre></td></tr></table></figure>



<p>set, map, multiset, multimap, 基于平衡二叉树(红黑树)，动态维护有序序列</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br>++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br></code></pre></td></tr></table></figure>



<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set &#x2F; multiset"></a>set &#x2F; multiset</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">set / multiset<br>set 不允许重复 multiset 可以重复<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    set/<span class="hljs-function">multiset</span><br><span class="hljs-function">    <span class="hljs-title">insert</span><span class="hljs-params">()</span>插入一个数</span><br><span class="hljs-function">    <span class="hljs-title">find</span><span class="hljs-params">()</span>查找一个 数</span><br><span class="hljs-function">    <span class="hljs-title">count</span><span class="hljs-params">()</span>返回某 一个数的个数</span><br><span class="hljs-function">    <span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        <span class="hljs-params">(<span class="hljs-number">1</span>)</span>输入是一个数x，删除所有x 0<span class="hljs-params">(k + logn)</span></span><br><span class="hljs-function">        <span class="hljs-params">(<span class="hljs-number">2</span>)</span>输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">    lower_ _<span class="hljs-title">bound</span><span class="hljs-params">()</span>/upper_ _<span class="hljs-title">bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    	lower_ <span class="hljs-title">bound</span><span class="hljs-params">(x)</span> 返回大于等 于x的最小的数的迭代器</span><br><span class="hljs-function">        upper_ _<span class="hljs-title">bound</span><span class="hljs-params">(x)</span> 返回 大于x的最小的数的迭代器</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>

<p>map&#x2F; multimap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    map/<span class="hljs-function">multimap</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入的数是一个pair</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span>  输入的参数是pair或者迭代器</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(logn)</span></span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span><br><span class="hljs-function">        </span><br><span class="hljs-function">    map&lt;string, <span class="hljs-type">int</span>&gt; a</span>;<br>    a[<span class="hljs-string">&quot;crx&quot;</span>] = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; a[<span class="hljs-string">&quot;crx&quot;</span>] &lt;&lt; endl;<br>像数组一样使用map<br></code></pre></td></tr></table></figure>





<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>    不支持 <span class="hljs-built_in">lower_bound</span>()/<span class="hljs-built_in">upper_bound</span>()， 迭代器的++，--<br></code></pre></td></tr></table></figure>



<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">bitset, 圧位<br>    bitset&lt;<span class="hljs-number">10000</span>&gt; s;<br>    ~(取反), &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    count()  返回有多少个<span class="hljs-number">1</span><br><br>    any()  判断是否至少有一个<span class="hljs-number">1</span><br>    none()  判断是否全为<span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">set</span>()  把所有位置成1<br>    <span class="hljs-keyword">set</span>(k, v)  将第<span class="hljs-comment">k</span>位变成<span class="hljs-comment">v</span><br>    reset()  把所有位变成<span class="hljs-comment">0</span><br>    flip()  等价于~<br>    flip(k) 把第<span class="hljs-comment">k</span>位取反<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/03/03/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.数据：是能输入计算机且能被计算机处理的各种符号的集合<br>2.数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理，<br>			也称元素，或者称为结点或顶点<br>			一个数据元素也可若干个数据项组成<br>3.数据项：构成数据元素不可分割的最小单位<br>		数据 &gt; 数据元素 &gt; 数据项<br>4.数据对象：性质相同的数据元素的集合<br>		数据元素——组成数据的基本单位（集合和个体）<br>		数据对象——性质相同的数据元素的集合（集合的子集）<br>5.数据结构：数据元素不是孤立存在的，他们直接存在着某种关系，数据元素相互之间的关系称为结构<br>			（带结构的数据元素的集合）<br>	数据结构包括：<br>		逻辑结构：数据元素之间的逻辑关系<br>		储存结构：数据元素及其关系在计算机内存中的表示（映像），称为数据的物理结构或数据存储结构<br>		数据的运算和实现，即对数据元素可以施加的操作以及这些操作在相应存储结构上的实现<br></code></pre></td></tr></table></figure>

<h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">逻辑结构<br>描述数据元素之间的逻辑关系<br>与数据存储无关，独立与计算机<br>是具体问题抽象出来的数学模型<br><br>物理结构（存储结构）<br>数据元素及其关系在计算机储存器中的结构（储存方式）<br>是数据结构在计算机中的表示<br><br>存储结构是逻辑关系的映像与元素本身的映像<br>逻辑结构是数据的抽象，存储结构是数据的实现<br>两者建立数据元素之间的结构关系<br></code></pre></td></tr></table></figure>

<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">种类<br>1.线性结构：有且仅有一个开始和一个终端节点，并且结点都最多有一个直接前趋和一个直接后继<br>2.非线性结构，一个节点可能有多个直接前趋和直接后继<br><br>第二种划分：<br>1.集合结构<br>2.线性结构：一对一<br>3.树形结构：一对多<br>4.图状结构：多对多<br></code></pre></td></tr></table></figure>

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">种类：<br>顺序存储结构：<br>	用一组<span class="hljs-string">&#x27;连续&#x27;</span>的存储单元依次存储数据元素，数据元素之间的逻辑关系有元素的存储位置来表示（数组）<br>链式存储结构：<br>	用一组<span class="hljs-string">&#x27;任意&#x27;</span>的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示（指针-&gt;地址）<br>    	在存储每一个元素的同时也存储了下一个元素的地址<br></code></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>抽象数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">作用：<br>约束变量或常量的取值范围<br>约束变量或常量的操作<br><br>数据类型：数据类型是一组性质相同的值的集合以及定义于这个值的集合上的一组操作的总称<br>	数据类型 = 值的集合 + 值集合上的一组操作<br><br>抽象数据类型：指一个数学模型以及定义在此数学模型上的一组操作<br>	<br>	定义格式<br>	ADT &lt;抽象数据类型名&gt;&#123;<br>		数据对象：&lt;数据对象的定义&gt;<br>		数据关系：&lt;数据关系的定义&gt;<br>		基本操作：&lt;基本操作的定义&gt;<br>	&#125; ADT 抽象数据类型名<br>    <br>    <br>    基本操作的定义格式为：<br>    基本操作名（参数表）<br>    初始条件：&lt;初始条件描述&gt;<br>	操作结构：&lt;操作结果描述&gt;<br>    <br>	基本操作定义格式说明：<br>    参数表:赋值参数 只为操作操作提供输入值<br>    	  引用参数 以&amp;打头，除可提供输入值外，还将返回操作结果 （类形参 ，加上&amp;取地址，可带回返回值）<br>    <br>    初始条件：描述操作执行前数据结构和参数应满足的条件，若不满足则操作失败，并返回相应出错信息。若初始条件为空，则省略之。<br>    <br>    操作结果：说明操作正常完成之后，数据结构的变化状况和相应的返回结果<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">eg.<br><span class="hljs-comment">//复数</span><br>    ADT Complex&#123;<br>    D = &#123;r1,r2| r1,r2都是实数&#125;<br>    S = &#123;&lt;r1,r2&gt;|r1是实部，r2是虚部&#125;<br>    assign（&amp;C,v1,v2)<br>        初始条件：<br>        操作结果：<br>    destroy(&amp;C)<br>&#125;ADT Complex<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/KFcLWo2gAp8Bl1f.png" alt="image-20220315112140283"></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">抽象数据类型的实现<br>	<span class="hljs-keyword">c</span>语言实现抽象数据类型<br>		用已有的数据定义描述它的存储结构<br>		用函数定义它的操作 <br>			-》在程序中使用<br>类<span class="hljs-keyword">c</span>语言（介于伪码和<span class="hljs-keyword">c</span>语言之间）<br></code></pre></td></tr></table></figure>

<h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">算法的特性：<br><span class="hljs-number">1</span>.有穷性<br><span class="hljs-number">2</span>.确定性<br><span class="hljs-number">3</span>.可行性<br><span class="hljs-number">4</span>.输入（<span class="hljs-number">0</span>个或多个输入）<br><span class="hljs-number">5</span>.输出（<span class="hljs-number">1</span>个或多个输出）<br><br>算法设计的要求：<br><span class="hljs-number">1</span>.正确性 <br><span class="hljs-number">2</span>.可读性<br><span class="hljs-number">3</span>.健壮性<br><span class="hljs-number">4</span>.高效性<br><br>通过算法的效率，来判断算法的优劣<br><span class="hljs-number">1</span>.时间效率，所消耗的时间<br><span class="hljs-number">2</span>.空间效率， 数量级用来衡量算法的复杂度，称为算法的渐进时间复杂度，简称时间复杂度。<br><br>时间复杂度，只看最高次项，不用考虑低次项和系数<br>	方法：<span class="hljs-number">1</span>.找出语句频率最大的那条语句，作为基本语句（嵌套层次最深的）<br>		 <span class="hljs-number">2</span>.计算基本语句的频率得到问题规模<span class="hljs-built_in">n</span>的某个函数f(<span class="hljs-built_in">n</span>)<br>		 <span class="hljs-number">3</span>.取其数量级<br><br>最坏时间复杂度，平均时间复杂度<br><br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/t7CfmrDxKS6dgU9.png" alt="image-20220316151905410"></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是具有相同特性的数据元素的一个有限序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">由 n(n&gt;=<span class="hljs-number">0</span>)个数据元素（结点）a1，a2，...,an组成的有限序列<br>	首元，线性起点（起始节点）<br>	线性终点，终端结点<br>	直接前趋，直接后继<br>	<br>	数据元素的个数n定义为表的长度<br>	当n=<span class="hljs-number">0</span> 时为空表<br>	<br>	<span class="hljs-string">&#x27;同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系&#x27;</span><br></code></pre></td></tr></table></figure>

<p>线性表的类型定义</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">抽象数据类型 <span class="hljs-variable">ADT</span><br><span class="hljs-variable">ADT</span> <span class="hljs-built_in">List</span><span class="hljs-punctuation">&#123;</span><br>	数据对象：<span class="hljs-built_in">D</span><span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>	数据关系：<br>	基本操作：<br><span class="hljs-punctuation">&#125;</span><span class="hljs-variable">ADT</span> <span class="hljs-built_in">List</span><br></code></pre></td></tr></table></figure>

<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>初始化 <br>	lnitList(&amp;L) 操作结果：构造一个空的线性表L<br><span class="hljs-number">2.</span>删除<br>	DestroyList(&amp;L)<br>		条件：线性表L存在	结果：销毁线性表L。<br><span class="hljs-number">3.</span>清除<br>	ClearLIst(&amp;L)	<br>		将线性表L置为空表<br><span class="hljs-number">4.</span>判断线性表是否为空<br>	ListEmpty(L)<br>		结果：若线性表为L为空表，则返回<span class="hljs-literal">true</span>;否则返回False<br><span class="hljs-number">5.</span>求线性表的长度<br>    ListLength(L)<br>        结果：返回线性表L中的数据元素个数<br><span class="hljs-number">6.</span>获取元素<br>	GetElem(L,i,&amp;e);<br>		<span class="hljs-number">1</span>&lt;=i&lt;= ListLength(L)<br>        结果：用e返回线性表L中第i个数据元素的值<br><span class="hljs-number">7.</span>查找<br>	LocateElem(L,e,compare())<br>		compare()是元素判定函数<br>        结果：返回L中第<span class="hljs-number">1</span>个与e满足 compare()的数据元素 的位序。若不存在则返回值为<span class="hljs-number">0</span><br><span class="hljs-number">8.</span>获取一个元素的前驱<br>   	PriorElem(L,cur_e, &amp;pre_e)<br>		结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义<br><span class="hljs-number">9.</span>获取一个元素的后继<br>	NextElem(L,cur_e,&amp;next_e)<br>    	结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败<br><span class="hljs-number">10.</span>在线性表中插入一个元素<br>	Listnsert(&amp;L,i,e)<br>		<span class="hljs-number">1</span> &lt;= i &lt;= ListLength(L)+<span class="hljs-number">1</span><br>		结果：在L的第i个位置插入新的数据元素，L长度加<span class="hljs-number">1</span><br><span class="hljs-number">11.</span>删除线性表中的元素<br>	ListDelete(&amp;L,i,&amp;e)<br>		<span class="hljs-number">1</span> &lt;=i &lt;= ListLength(L)<br>        结果：删除L的第i个数据元素，并用e返回其值，L的长度减一<br><span class="hljs-number">12.</span>遍历线性表<br>	ListTraverse(&amp;L,visited())<br>        依次对线性表中的每个元素调用visited()<br>		<br></code></pre></td></tr></table></figure>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>——线性表的顺序表示</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">顺序存储的定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构占用一片连续的存储空间，<span class="hljs-comment">(知道一个元素存储单元存储位置，可以通过计算知道其他元素位置)</span><br>	特点：<br>		以物理位置相邻表示逻辑关系，任一元素位置均可随机存取。<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">数组长度需要变化，c89不支持可变长度，c99好像支持<br>	<br>	数组长度不可变时，可以用变量表示顺序表的长度属性<br>    <br>初始化模板：（类c）	<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;		<span class="hljs-comment">//数据类型定义也可使用 typedef 进行预编译</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        ElemType elem[LIST_INIT_SIZE];		<span class="hljs-comment">//ElemType 代表元素类型（int...)</span><br>        <span class="hljs-type">int</span> length;<br>    &#125;Sqlist;<br><br>eg.也可用结构体嵌套定义数据类型<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	<span class="hljs-type">float</span> p;<br>	<span class="hljs-type">int</span> e;<br>	&#125;Polynomial;<br>	<br>	<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        Polynomial *elem;		<span class="hljs-comment">// *data 定义数组第一个元素的地址，后续由动态分布，分布空间</span><br>        <span class="hljs-type">int</span> length;<br>    &#125;SqList;<br></code></pre></td></tr></table></figure>

<h3 id="c语言的内存动态分配"><a href="#c语言的内存动态分配" class="headerlink" title="c语言的内存动态分配"></a>c语言的内存动态分配</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">ElemType data[MaxSize] 			<span class="hljs-comment">//数组静态分配</span><br><br>ElemType *data					<span class="hljs-comment">//数组动态分配</span><br>    L.data=(Elemtype*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize); <span class="hljs-comment">//ElemType可以是变量也可以是类型</span><br><span class="hljs-comment">//malloc(sizeof(ElemType)*MaxSize) 开辟 一个长度 * 总数 的长度空间</span><br><span class="hljs-comment">//(Elemtype*)，通过类型将分配的长空间，化成小单位</span><br><span class="hljs-comment">//(xxx*)  ()是强制类型转化，这里转化成指向xxx类型的指针(原因：*data)</span><br>		eg.(<span class="hljs-type">int</span>*)表示强制转化为指向整型的指针<br><br>内存分配函数：<br>    <span class="hljs-built_in">malloc</span>(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址<br>    <span class="hljs-keyword">sizeof</span>(X)运算，计算变量x的长度<br>    <span class="hljs-built_in">free</span>(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量<br><span class="hljs-comment">//注：需要声明头文件&lt;stdlib.h&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="c-的动态存储分配"><a href="#c-的动态存储分配" class="headerlink" title="c++的动态存储分配"></a>c++的动态存储分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> 类型名<span class="hljs-built_in">T</span> (初值列表)			eg. <span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> / <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    申请用于存放T类型对象的内存空间，并依初值列表赋初值<br>    结果值：<br>        	成功：T类型的指针，指向新分配的内存<br>        	失败：<span class="hljs-number">0</span> （<span class="hljs-literal">NULL</span>）<br><span class="hljs-keyword">delete</span> 指针P<br>    释放指针p所指向的内存，P必须是<span class="hljs-keyword">new</span>操作的返回值<br><br>c++ 创建动态数组<br>		<span class="hljs-type">int</span> *type = <span class="hljs-keyword">new</span> type[n];<br>		<span class="hljs-keyword">delete</span>[]type<br></code></pre></td></tr></table></figure>

<h3 id="c-中的参数传递"><a href="#c-中的参数传递" class="headerlink" title="c++中的参数传递"></a>c++中的参数传递</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">实参与形参 类型,个数，顺序 必须一致<br><br>参数传递的两种方式：<br>	<span class="hljs-number">1.</span>传值方式(参数为整形，实型，字符型),（	形参改变，实参不变）<br>    <span class="hljs-number">2.</span>传地址<br>    	参数为指针变量<br>    	参数为引用类型 <span class="hljs-comment">//c++ 新增</span><br>    	参数为数组名<br><br>引用类型作参数<br>    引用：用来给一个对象提供一个代替的名字<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-type">int</span> i=<span class="hljs-number">5</span>；<br>        <span class="hljs-type">int</span> &amp;j=i;			<span class="hljs-comment">//j是一个引用类型，代表i的一个替代名i值改变时，j值也跟着改变</span><br>    	i=<span class="hljs-number">7</span>;<br>    	cout&lt;&lt; <span class="hljs-string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;j= &quot;</span> &lt;&lt; j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span>&amp; m ,<span class="hljs-type">float</span>&amp; n)</span></span>&#123;&#125;		<span class="hljs-comment">//对形参操作相当于对实参操作</span><br><br><span class="hljs-number">1.</span>传递引用给函数与传递指针的效果时一样的<br><span class="hljs-number">2.</span>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作；而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值是实参变量的副本。所以，传递参数数据量较大时，引用比用一般变量传递参数的时间和空间效率都好。<br></code></pre></td></tr></table></figure>

<h3 id="线性表基本实现"><a href="#线性表基本实现" class="headerlink" title="线性表基本实现"></a>线性表基本实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZEE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *elem;		<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;		<span class="hljs-comment">//定义顺序表的类型</span><br><br>SqList L;		<span class="hljs-comment">//定义变量，分配内存空间</span><br><br><br><span class="hljs-comment">//函数结果状态代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	TRUE	1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	FALSAE	0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	OK		1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	ERROR	0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>	INFEASIBLE	-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW	-2</span><br><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;<br></code></pre></td></tr></table></figure>

<h4 id="线性表的初始化"><a href="#线性表的初始化" class="headerlink" title="线性表的初始化"></a>线性表的初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//伪代码</span><br><span class="hljs-function">Status <span class="hljs-title">lnitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;					<span class="hljs-comment">//构造一个空的顺序表L</span><br>	L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE];				<span class="hljs-comment">//为顺序表分配空间C++</span><br>	<span class="hljs-keyword">if</span>(!L.elem)	<span class="hljs-built_in">exit</span>(OVERFLOW);					<span class="hljs-comment">//储存分配失败</span><br>	L.length=<span class="hljs-number">0</span>;									<span class="hljs-comment">//空表长度为0</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="销毁线性表L"><a href="#销毁线性表L" class="headerlink" title="销毁线性表L"></a>销毁线性表L</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(L.elem) <span class="hljs-keyword">delete</span> L.elem;		<span class="hljs-comment">//释放存储空间</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="清空线性表L"><a href="#清空线性表L" class="headerlink" title="清空线性表L"></a>清空线性表L</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>	L.length = <span class="hljs-number">0</span>; 				<span class="hljs-comment">//将线性表的长度置为0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="求线性表长度"><a href="#求线性表长度" class="headerlink" title="求线性表长度"></a>求线性表长度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>	<span class="hljs-keyword">return</span>(L.length);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判断线性表L是否为空"><a href="#判断线性表L是否为空" class="headerlink" title="判断线性表L是否为空"></a>判断线性表L是否为空</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取第i个元素"><a href="#获取第i个元素" class="headerlink" title="获取第i个元素"></a>获取第i个元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>|i&gt;L.length) <span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//判断i值是否合理，不合理返回ERROR</span><br>	e = L.elem[i<span class="hljs-number">-1</span>];	<span class="hljs-comment">//i-1的单元存储第i个元素</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">算法思想<br><span class="hljs-number">1</span>.插入位置<span class="hljs-selector-tag">i</span>是否合法。<br><span class="hljs-number">2</span>.判断顺序表的存储空间是否已满，若已满返回ERROR<br><span class="hljs-number">3</span>.将第n至第<span class="hljs-selector-tag">i</span>位的元素依次向后移动一个位置，空出第<span class="hljs-selector-tag">i</span>个位置<br><span class="hljs-number">4</span>.将要插入的新元素e放入第<span class="hljs-selector-tag">i</span>个位置<br><span class="hljs-number">5</span>.表长加<span class="hljs-number">1</span>，插入成功返沪OK。<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Listlnsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i ,ElemType e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//i值不合法  i是位置</span><br>	<span class="hljs-keyword">if</span>(L.length==MAXSIZE) <span class="hljs-keyword">return</span> ERROR;		<span class="hljs-comment">//当前储存空间已满</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span> ;j&gt;=i<span class="hljs-number">-1</span>;j--)<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];	<span class="hljs-comment">//插入位置及之后的元素后移</span><br>    L.elem[i<span class="hljs-number">-1</span>]=e;			<span class="hljs-comment">//将新元素e放入第i个位置</span><br>    L.length++;				<span class="hljs-comment">//表长加1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Eins</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>	平均移动次数  时间复杂度为O(n)<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">List_Insert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i ,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(L.length==MAXSIZE)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;MAXSIZE&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j=L.length<span class="hljs-number">-1</span> ; j&gt;=i<span class="hljs-number">-1</span>; j--)<br>    &#123;<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<br>    &#125;<br>    L.elem[i<span class="hljs-number">-1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><p>算法思想</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.判断删除位置i是否合法（合法值<span class="hljs-number">1</span>&lt;=i&lt;=n)<br><span class="hljs-attribute">2</span>.将欲删除的元素保留在e中（可省）<br><span class="hljs-attribute">3</span>.将第i+<span class="hljs-number">1</span>至第n位的元素依次向前移动一个位置<br><span class="hljs-attribute">4</span>.表长减一，删除成功返回OK<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.Length)) <span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//i值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++)<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];			<span class="hljs-comment">//被删除元素之后的元素前移（后面元素赋值到以前一个）</span><br>    L.length--;<br>    returnOK<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Edel</span><span class="hljs-operator">=</span> (n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>		时间复杂度O(n)<br></code></pre></td></tr></table></figure>

<p>c++代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">List_Delete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;=L.length<span class="hljs-number">-1</span>; j++ )<span class="hljs-comment">//小于还是小于等于需要仔细判断</span><br>    &#123;<br>        L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>——线性表的链式表示</p>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>单链表是由头指针唯一确定，因此单链表可以用头指针的名字来命名</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">各个结点由两个域组成：<br><span class="hljs-number">1</span>.数据域：存储元素数值数据<br><span class="hljs-number">2</span>.指针域:储存直接后继结点的存储位置<br><br>结点：数据元素的存储映像，由数据域和指针域两部分组成<br>链表：n个结点由指针链组成一个链表，他是线性表的链式存储映像，称为线性表的链式存储结构<br><br>单链表：结点只有一个指针域的链表，称为单链表或者线性链表<br>双链表：结点由两个指针域的链表，称为双链表<br>循环链表：首位相接的链表称为循环链表<br><br>头指针：是指向链表中第一个结点的指针<br>首元节点：是指链表中存储第一个数据元素<span class="hljs-built_in">a1</span>的结点<br>头结点：是在链表的首元结点之前附设的一个结点<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/he2pwcRFrCZIaS3.png" alt="image-20220321143557148"></p>
<p>所以链表存储形式有</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.不带头结点<br>2.带头结点<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">空表表示：<br>1.无头结点时，头指针为空时表示空表<br>2.有头节点时，当头结点的指针域为空时表示空表<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">头节点的好处<br>1.便于首元结点的处理<br>		首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作与其他位置一致，无需特殊处理<br>2.便于空表和非空表的统一处理<br>	无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理得到统一<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">头节点的数据域<br>	可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值<br></code></pre></td></tr></table></figure>

<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">链表（链式存储结构）的特点<br>（<span class="hljs-number">1</span>）结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。<br>（<span class="hljs-number">2</span>）访问时只能通过头指针进入链表）井通过每个结点的指针城依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等<br>			链表<span class="hljs-comment">---顺序存取法	（从头开始寻找）</span><br>			顺序表<span class="hljs-comment">---随机存取法（下标直接定位）</span><br></code></pre></td></tr></table></figure>

<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>，带头结点的单链表<br>		单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L<br>	用结构体实现<br>		包括两个成员一个为<span class="hljs-meta">data</span>，一个为next指针 指向结构体地址		<span class="hljs-comment">//嵌套定义</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123;		<span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>	ElemType data;			<span class="hljs-comment">//结点的数据域</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;		<span class="hljs-comment">//结点的指针域</span><br>&#125;Lnode,*LinkList;			<span class="hljs-comment">//LinkList为指向结构体Lnode的指针类型	</span><br><br>Londe a;	<span class="hljs-comment">//定义一个a结点</span><br>Londe *L; = LinkList L;	<span class="hljs-comment">//定义指向结点的指针</span><br><br>定义指向头节点的指针，就代表了整个链表<br>定义链表L ：LinkList L;	<br>定义结点指针p：LNode *p; = LinkList p;		<br></code></pre></td></tr></table></figure>

<p>对于多个数据域通常这样定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];	<span class="hljs-comment">//数据域</span><br>	<span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];	<span class="hljs-comment">//数据域</span><br>	<span class="hljs-type">int</span> score;		<span class="hljs-comment">//数据域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123;<br>    ElemType data;			<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;		<span class="hljs-comment">//指针域</span><br>&#125;Lnode,*LinkList;<br></code></pre></td></tr></table></figure>

<h3 id="单链表的销毁"><a href="#单链表的销毁" class="headerlink" title="单链表的销毁"></a>单链表的销毁</h3><p>销毁所有元素，包括头指针，头节点</p>
<p>算法思路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">从头指针开始，依次释放所有结点<br>将后一个结点的地址，赋值给L,释放当前节点<br>	L = L-&gt;next;	!!!<br>    <span class="hljs-keyword">delete</span> p;	--创建时为<span class="hljs-keyword">new</span>			C++<br>    <span class="hljs-built_in">free</span>(p);	--创建时为<span class="hljs-built_in">malloc</span>()  	c<br>结束条件：L==<span class="hljs-literal">NULL</span><br>循环条件：L！==<span class="hljs-literal">NULL</span> 或L<br></code></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestroyList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>	Lnode *p;<br>	<span class="hljs-keyword">while</span>(L)&#123;		<span class="hljs-comment">//L不为空时循环继续</span><br>		p = L;				<span class="hljs-comment">//从头结点开始销毁，L开始存放的为头结点地址</span><br>		L = L-&gt;next;	<span class="hljs-comment">//指向下一个，释放当前</span><br>		<span class="hljs-keyword">delete</span> p		<span class="hljs-comment">//最后一个时：指向空，释放最后一个</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="清空单链表"><a href="#清空单链表" class="headerlink" title="清空单链表"></a>清空单链表</h3><p>链表仍存在，但链表中无元素，成为空链表（头指针和头结点仍然存在）</p>
<p>算法思路</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">依次释放所有的结点，并将头结点指针域设置为空<br>	L来保存头部结点指针域<br>	<br><span class="hljs-number">1.</span>开始p用来存储第一结点（及头部结点下一个，p=L-&gt;next;）<br><span class="hljs-number">2.</span>释放p结点,同时需要保存下一个结点的地址（q = p-&gt;next;)<br><span class="hljs-number">3.</span>反复执行p=q; q=q-&gt;next;<br>	<span class="hljs-comment">//注：不用L的原因：L用来存储头部指针，如果使用头部指针无处存放</span><br>	<span class="hljs-comment">//		具体实现q=q-&gt;next与q=p-&gt;next重复，表达思维相同</span><br><br>结束条件：p==<span class="hljs-literal">NULL</span><br>循环条件：p！==<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;	<span class="hljs-comment">//将L重置为空表</span><br>	Lnode *p,*q;	<span class="hljs-comment">//或者LinkList p,q;</span><br>    p=L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;	<span class="hljs-comment">//p不为空反复执行</span><br>        q=p-&gt;next;		<span class="hljs-comment">//最后一个情况：q = NULL, p存的是当前地址</span><br>        <span class="hljs-keyword">delete</span> p;		<span class="hljs-comment">//释放当前指针</span><br>        p = q;			<span class="hljs-comment">//将下一个指针地址传给p</span><br>    &#125;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">//将头结点指针域为空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>总结：q用来存放下一个结点地址，当p释放当前结点成功后，将下一个指针地址重新赋值给p<br></code></pre></td></tr></table></figure>

<h3 id="求链表的表长"><a href="#求链表的表长" class="headerlink" title="求链表的表长"></a>求链表的表长</h3><p>算法思想：从首元结点开始，依次计数所有结点</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">依次遍历直到 <span class="hljs-attribute">p</span>=<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>	LinkList p;<br>	p =L-&gt;next			<span class="hljs-comment">//p指向第一个结点</span><br>	i = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(p)&#123;			<span class="hljs-comment">//遍历单链表，统计结点数</span><br>		i++;<br>		p=p-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> i;		<span class="hljs-comment">//如果长度为0及为空表</span><br>&#125;		<br></code></pre></td></tr></table></figure>

<p>重要操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p = L;			<span class="hljs-comment">//p指向头结点</span><br>s = L-&gt;next;	<span class="hljs-comment">//s指向首元结点</span><br>p = p-&gt;next;	<span class="hljs-comment">//p指向下一结点</span><br></code></pre></td></tr></table></figure>

<h3 id="查找——取单链表中第i个元素"><a href="#查找——取单链表中第i个元素" class="headerlink" title="查找——取单链表中第i个元素"></a>查找——取单链表中第i个元素</h3><p>还不是查找,按下标查询,并不是按数据元素查询</p>
<p>算法思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止，因此，链表不是随机存储结构。<br><br><span class="hljs-number">1.</span>从第<span class="hljs-number">1</span>个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p=L-&gt;next<br><span class="hljs-number">2.</span>j做计数器，累计当前扫描过的结点数，j初值为<span class="hljs-number">1</span><br><span class="hljs-number">3.</span>当p指向扫描到的下一结点，计数器j加<span class="hljs-number">1</span><br><span class="hljs-number">4.</span>当j==i时，p所指的结点就是要找的第i个结点<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br>	p = L-&gt;next; j=<span class="hljs-number">1</span>		<span class="hljs-comment">//初始化</span><br>	<span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;		<span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>        p = p-&gt;next; ++j;<br>	&#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;???  <span class="hljs-comment">//第i个元素不存在  j&gt;i是判断万一i为负/0的情况和未找到元素j</span><br>    e = p-&gt;data;			<span class="hljs-comment">//取第i个元素</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>!p || j&gt;i   <span class="hljs-number">5</span>   <span class="hljs-number">4</span><br>当i小于链表长度，当j=i时p不为空，循环继续，结果至p=<span class="hljs-literal">NULL</span>，j&gt;i,(!p=<span class="hljs-number">1</span>,j&gt;i =<span class="hljs-number">1</span>)<br>当i大于链表长度，p为空，j&lt;<span class="hljs-built_in">i</span> (!p=<span class="hljs-number">1</span> || j&lt;i = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">时间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h3 id="增加——插入一个结点"><a href="#增加——插入一个结点" class="headerlink" title="增加——插入一个结点"></a>增加——插入一个结点</h3><p>在第i个节点前插入值为e的新结点</p>
<p>算法思想：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">在ai前插入一个新结点<br><br><span class="hljs-number">1.</span>首先找到a（i<span class="hljs-number">-1</span>）的存储位置p<br><span class="hljs-number">2.</span>生成一个数据域为e的新结点s;<br><span class="hljs-number">3.</span>插入新结点：(<span class="hljs-number">1</span>)新结点的指针域指向结点ai	s-&gt;next = p-&gt;<span class="hljs-built_in">next</span><br>			(<span class="hljs-number">2</span>)结点<span class="hljs-built_in">a</span>(i<span class="hljs-number">-1</span>)的指针域指向新结点	p-&gt;next = s;<br>注意顺序，小心内存泄漏，ai地址丢失<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>	p = L;j = <span class="hljs-number">0</span>;		<span class="hljs-comment">//p指向头结点，不是首元结点，所以j=0，与前一个不同</span><br>	<span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123;<br>        p=p-&gt;next;<br>        ++j;			<span class="hljs-comment">//寻找第i-1个结点，p指向i-1结点</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//i大于表长+1或者小于1，插入位置非法</span><br>    			<span class="hljs-comment">//!p 过滤i大于表长，j&gt;i-1过滤i小于1的情况</span><br>    s = <span class="hljs-keyword">new</span> LNode; s-&gt;data=e;	<span class="hljs-comment">//生成新结点s，将结点s的数据域置为e</span><br>    s-&gt;next = p-&gt;next;		<br>    p-&gt;next = s;		<span class="hljs-comment">//将结点插入L中</span><br>&#125;<br><br><span class="hljs-comment">//p不从首元结点开始，原因避免插入位置为第一个，p指向的地址出现问题</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">时间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，不需要移动元素只需要修改指针<br></code></pre></td></tr></table></figure>

<h3 id="删除——第i个结点"><a href="#删除——第i个结点" class="headerlink" title="删除——第i个结点"></a>删除——第i个结点</h3><p>算法思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">寻找第i<span class="hljs-number">-1</span>个结点，修改指针域指向i+<span class="hljs-number">1</span>，释放第i个结点<br><br><span class="hljs-number">1.</span>首先找到<span class="hljs-built_in">a</span>(i<span class="hljs-number">-1</span>)的储存位置p，保存要删除的ai的值<br><span class="hljs-number">2.</span>令p-&gt;next指向<span class="hljs-built_in">a</span>(i+<span class="hljs-number">1</span>)<br>    p-&gt;next = p-&gt;next-&gt;next		<br><span class="hljs-number">3.</span>释放结点ai的空间<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>	p = L;j = <span class="hljs-number">0</span>;Lnode *q;<br>	<span class="hljs-keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)&#123;<br>		p=p-&gt;next; ++j;		<span class="hljs-comment">//寻找第i-1个结点，并令p指向其前驱</span><br>	&#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;		<span class="hljs-comment">//删除位置不合理</span><br>    		<span class="hljs-comment">//p是头结点，p-&gt;next为空，一种是空表，一种是i超出长度</span><br>    q = p-&gt;next;		<span class="hljs-comment">//临时保存被删除结点的地址以备释放</span><br>   <span class="hljs-string">&quot;p-&gt;next=q-&gt;next;&quot;</span>	<span class="hljs-comment">//改变删除结点前驱结点的指针域		</span><br>    e=q-&gt;data;			<span class="hljs-comment">//保存删除节点的数据域</span><br>    <span class="hljs-keyword">delete</span> q;			<span class="hljs-comment">//释放删除结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//q结点用来保存需要删除的结点</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">时间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，不需要移动元素只需要修改指针<br></code></pre></td></tr></table></figure>

<h3 id="建立单链表"><a href="#建立单链表" class="headerlink" title="建立单链表"></a>建立单链表</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>.从一个空表开始，重复读入数据<span class="hljs-comment">;</span><br><span class="hljs-number">2</span>.生成新结点，将读入数据存放到新结点的数据域中<br><span class="hljs-number">3</span>.从最后一个结点开始，依次将各结点插入到链表的前端 (头结点的后方)<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ky4r8nwh6Qcuobz.png" alt="image-20220322162218117"></p>
<p>算法思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>创建头结点<br>    L = <span class="hljs-keyword">new</span> LNode;	<span class="hljs-comment">//c++</span><br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));	<span class="hljs-comment">//c</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">2.</span>插入其余结点<br>    p =<span class="hljs-keyword">new</span> LNode;	<span class="hljs-comment">//c++	</span><br>	p-&gt;data=an;<br><span class="hljs-number">3.</span>将头结点后面的东西，放入新结点之后,头结点指针域方新节点<br>    p-&gt;next=L-&gt;next;<br>	L-&gt;next=p;<br><span class="hljs-number">4.</span>插入下一个,循环开始<br>    p=<span class="hljs-keyword">new</span> LNode;<br>	p-&gt;data=<span class="hljs-built_in">a</span>(n<span class="hljs-number">-1</span>)<br>    p-&gt;next = L-&gt;next;<br>	L-&gt;next=p;<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> n)</span></span>&#123;		<span class="hljs-comment">//n为结点数，插入次数(循环次数)</span><br>    L=<span class="hljs-keyword">new</span> LNode;<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;	<span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    <span class="hljs-keyword">for</span>(i=n;i&gt;<span class="hljs-number">0</span>;--i)&#123;<br>        p=<span class="hljs-keyword">new</span> LNode;	<span class="hljs-comment">//生成新结点 c p=(LNode*)malloc(sizeof(LNode));</span><br>        cin&gt;&gt;p-&gt;data;	<span class="hljs-comment">//输入元素值 c scanf(&amp;p-&gt;data);</span><br>        p-&gt;next=L-&gt;next;	<span class="hljs-comment">//插入到表头</span><br>        L-&gt;next=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">头插法——时间复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p>元素插入在链表尾部</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>从一个空表开始，将新结点逐个插入到链表的尾部，<span class="hljs-string">&quot;尾指针r&quot;</span>指向链表的尾结点<br><span class="hljs-number">2.</span>初始时，r同L均指向头节点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点<br>        p-&gt;data=ai	p-&gt;next=<span class="hljs-literal">NULL</span><br>        r-&gt;next=p;	r=p;<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/TLRsnG1zwuhVCIP.png" alt="image-20220322170116369" style="zoom: 67%;" />

<p>正位序输入n个元素的值，建立带表头结点的单链表L</p>
<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;	L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    r=L;	<span class="hljs-comment">//尾指针r指向头节点</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        p=<span class="hljs-keyword">new</span> LNode;<br>        cin&gt;&gt;p-&gt;data;	<span class="hljs-comment">//生成新节点，输入元素值</span><br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<br>        r-&gt;next=p;		<span class="hljs-comment">//插入到表尾</span><br>        r=p;			<span class="hljs-comment">//尾指针r指向新的尾结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">尾插法——时间复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表:是一种头尾相接的链表(即:表中最后一个结点的指针域指向头节点,整个链表形成一个环)</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">优点:从表中任一结点出发均可找到表中其他结点。<br><br>循环链表中没有NULL指针，故遍历操作的终止条件是判断其是否等于头指针。<br>	<span class="hljs-function"><span class="hljs-title">p</span>!=NULL   		---&gt;</span>&gt;&gt;		p！= L;<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>!=NULL	---&gt;</span>&gt;&gt;		<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>next!=L<br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">经常对首位经行操作采用：尾指针,<br>	首元节点位置 ：R-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>	<span class="hljs-regexp">//</span>尾指针指向头结点 再指向首元<br>		 尾节点 ：R<br></code></pre></td></tr></table></figure>

<h3 id="带尾指针的循环链表合并"><a href="#带尾指针的循环链表合并" class="headerlink" title="带尾指针的循环链表合并"></a>带尾指针的循环链表合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">将带尾指针的链表进行合并：		<br><span class="hljs-comment">//Ta为链表1为指针，Tb为链表2尾结点</span><br>	<span class="hljs-number">1.</span>p存头节点<br>    <span class="hljs-number">2.</span>Tb表头连接到Ta表尾<br>	<span class="hljs-number">3.</span>释放Tb头结点<br>	<span class="hljs-number">4.</span>修改尾指针<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p = Ta-&gt;next;	<span class="hljs-comment">//存Ta头节点</span><br>Ta-&gt;next = Tb-&gt;next-&gt;next;<br><span class="hljs-keyword">delete</span> Tb -&gt; next;<br>Tb-&gt;next = p;<br></code></pre></td></tr></table></figure>

<p>带尾指针的循环链表合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>	p = Ta-&gt;next;	<br>    Ta-&gt;next = Tb-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> Tb -&gt; next;<br>    Tb-&gt;next = p;<br>    <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="双向列表"><a href="#双向列表" class="headerlink" title="双向列表"></a>双向列表</h2><p>在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，使链表形参有两个不同方向的链</p>
<h3 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>    Elemtype	data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior, *next;<br>&#125;DuLNode,*DuLinkList;<br></code></pre></td></tr></table></figure>

<p>双向循环链表</p>
<p>让头结点的前驱指针指向链表的最后一个结点</p>
<p>让最后一个结点的后继指针指向头结点</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">双向链表结构的对称性(设指针p指向某一结点):<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = p = p -&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior<br></code></pre></td></tr></table></figure>

<p>求长度，于获取元素和单链表相同，单插入删除则略有不同</p>
<h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">只需要找到第i个元素，i-<span class="hljs-number">1</span>通过指针prior寻找<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = p-&gt;</span>prior;	<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span>next = s;		<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span>next = p;<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>prior=s;<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsert_Dul</span><span class="hljs-params">(DulinkList &amp;L,<span class="hljs-type">int</span> i,Elemtype e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElemP_Dul</span>(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>	s = <span class="hljs-keyword">new</span> DuLNode;<br>	s-&gt;data = e;<br>	<br>	s-&gt;prior = p-&gt;prior;	<br>    p-&gt;prior-&gt;next = s;<br>    <br>    s-&gt;next = p;<br>    p-&gt;prior=s;<br>    <span class="hljs-keyword">return</span> OK<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h3><p>算法思想</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> -&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = p-&gt;</span>next;<br> 	<span class="hljs-comment">//删除结点的prior是其前驱节点，再将其前驱节点，与后半部分相连</span><br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = p-&gt;</span>prior<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">void ListDelete_Dul(DuLink &amp;L, int i ,ElemType &amp;e)&#123;<br>	<span class="hljs-keyword">if</span>(!(p=GetElemP_DuL(L,i))) return ERROR;<br>	<span class="hljs-function"><span class="hljs-title">e</span> = p-&gt;</span><span class="hljs-keyword">data</span>;<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = p-&gt;</span>next;<br>	<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = p-&gt;</span>prior;<br>	free(p);<br>	return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Eba4pUCdv1oQTer.png" alt="image-20220326221130903"></p>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>优点</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">结点空间可以动态的申请和释放<br>数据元素的逻辑次序靠结点的指针来指示，删除和插入时不需要移动数据元素<br></code></pre></td></tr></table></figure>

<p>缺点</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">存储密度小，每个结点的指针域需要额外占存储空间，每个结点的数据域所占字节不多，指针域所占存储空间比重大<br>	存储密度 <span class="hljs-operator">=</span> 结点数据所占空间/结点所占空间<br>		存储密度越大，存储空间利用率越高，顺序表密度为<span class="hljs-number">1</span><br>		<br>链式存储结构是非随机存储结构，对任一结点的操作都要从头指针依指针链查找到该结点<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/sGkJTrOoe8Bmy2i.png" alt="image-20220326224722636"></p>
<h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="线性表的合并"><a href="#线性表的合并" class="headerlink" title="线性表的合并"></a>线性表的合并</h3><p>算法思想</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">依次取出Lb中的每个元素<br>	1.在<span class="hljs-keyword">La</span>中查找该元素<br>	2.如果找不到，则将其插入到<span class="hljs-keyword">La</span>的最后<br></code></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(List &amp;La, List Lb)</span></span>&#123;<br>    La_len=<span class="hljs-built_in">ListLength</span>(La);<br>    Lb_len=<span class="hljs-built_in">ListLength</span>(Lb);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;Lb_len;i++)&#123;<br>        <span class="hljs-built_in">GetElem</span>(Lb,i,e);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LocateElem</span>(La,e))&#123;<br>            <span class="hljs-built_in">ListInsert</span>(&amp;La,++La_len,e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">时间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">ListLength</span>(<span class="hljs-variable">La</span>)*<span class="hljs-title">ListLength</span>(<span class="hljs-variable">Lb</span>))</span><br></code></pre></td></tr></table></figure>

<h3 id="有序表的合并"><a href="#有序表的合并" class="headerlink" title="有序表的合并"></a>有序表的合并</h3><h4 id="顺序表实现"><a href="#顺序表实现" class="headerlink" title="顺序表实现"></a>顺序表实现</h4><p>算法思想</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">1.创建一个空表<br>2.依次从<span class="hljs-keyword">La</span>或Lb中&#x27;摘取&#x27;元素值较小的结点插入到表Lc的最后，直至其一个表为空表为止<br>3.继续将<span class="hljs-keyword">La</span>或Lb其中一个表剩余结点插入在Lc表的最后<br>	注：<span class="hljs-keyword">La</span>和Lb为有序表<br>	比较<span class="hljs-keyword">La</span>与Lb的元素，较小的加入<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_Sq</span><span class="hljs-params">(SqList LA,SqList LB,SqList &amp;LC)</span></span>&#123;<br>    pa = LA.elem;<br>    pb = LB.elem;		<span class="hljs-comment">//指针pa和pb的初值分别指向两个表的第一个元素</span><br>    LC.length = LA.length + LB.length;		<span class="hljs-comment">//新表长度为待合并两表的长度之和</span><br>    LC.elem = <span class="hljs-keyword">new</span> ElemType[LC.length];		<span class="hljs-comment">//分配空间</span><br>    pc=Lc.elem;<br>    pa_Last = LA.elem+LA.length<span class="hljs-number">-1</span>;		<span class="hljs-comment">//相当于LA.elem[0+La.length-1]</span><br>    pb_Last = LB.elem+LB.length<span class="hljs-number">-1</span>;		<span class="hljs-comment">//pa_Last 指向最后一个元素</span><br>    <br>    <span class="hljs-keyword">while</span>(pa&lt;=pa_last &amp;&amp; pb &lt;= pb_last)&#123;	<span class="hljs-comment">//两表都为空</span><br>        <span class="hljs-keyword">if</span>(*pa&lt;=*pb)*pc++ = *pa++;		<span class="hljs-comment">//依次”摘取“两表中值较小的结点</span><br>        <span class="hljs-keyword">else</span> *pc++ = *pb++;<br>	&#125;<br>    		<span class="hljs-comment">//注：其为后置++，先取值后加1</span><br>    <span class="hljs-keyword">while</span>(pa&lt;=pa_last) *pc++ = *pa++;<br>    <span class="hljs-keyword">while</span>(pb&lt;=pb_last) *pc++ = *pv++;		<span class="hljs-comment">//将剩余非空表，剩余元素加入Lc</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">时间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">ListLength</span>(<span class="hljs-variable">La</span>)+<span class="hljs-title">ListLength</span>(<span class="hljs-variable">Lb</span>))</span><br>空间复杂度：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">ListLength</span>(<span class="hljs-variable">La</span>)+<span class="hljs-title">ListLength</span>(<span class="hljs-variable">Lb</span>))</span><br></code></pre></td></tr></table></figure>

<h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_L</span><span class="hljs-params">(LinkList &amp;La,LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;<br>	pa = La-&gt;next;	pb=Lb-&gt;next;<br>	pc=Lc=La;			<span class="hljs-comment">//用La的头结点作为Lc的头结点</span><br>	<span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>        <span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<br>            pc-&gt;next=pa;<br>            pc=pa;<br>            pa=pa-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>			pc-&gt;next=pb;<br>            pc=pb;<br>            pb=pb-&gt;next;<br>        &#125;<br>    &#125;<br>    pc-&gt;next = pa?pa:pb;	<span class="hljs-comment">//插入剩余段</span><br>    <span class="hljs-keyword">delete</span> Lb;		<span class="hljs-comment">//释放Lb的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(ListLength(La)+<span class="hljs-built_in">ListLength</span>(Lb))<br>空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),不需要额外空间<br></code></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈和队列是限定插入和删除只能再表的”端点”进行的 线性表</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">栈：插入和删除只能在表尾进行，后进先出<br>队列：插入只能在表尾，但删除要从表头开始，先进先出<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/taTp9LxmwC5Wj7r.png" alt="image-20220327192904293"></p>
<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈：特殊的线性表，限定仅在一端(通常是表尾)，进行插入删除操作的线性表，后进先出的线性表，简称LIFO结构</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">栈进再表尾进行插入，删除操作的线性表<br>	表尾(an端)称为栈顶<span class="hljs-attribute">Top</span>;表头(a1端)称为栈底Base<br><br>插入元素到栈顶的操作，叫入栈	<span class="hljs-built_in">PUSH</span>(x)<br>从栈顶删除最后一个元素的操作，称为出栈	<span class="hljs-built_in">POP</span>(y)<br><br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/TyE3hDBJiaLOvYW.png" alt="image-20220330143326998" style="zoom: 33%;" />

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">逻辑结构：同线性表相同，仍为一对一关系<br>存储结构：用顺序栈或链栈存储即可，但以顺序栈更常见<br><br>与一般线性表的区别：只有运算规则不同<br></code></pre></td></tr></table></figure>

<h2 id="队列定义"><a href="#队列定义" class="headerlink" title="队列定义"></a>队列定义</h2><p>队列是先进先出的线性表，一端插入，令一端删除，在对尾插入，对头删除</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">逻辑结构：同线性表相同，仍为一对一关系<br>存储结构：用顺序队或链队存储即可，但以顺序队列更常见<br><br>与一般线性表的区别：只有运算规则不同<br></code></pre></td></tr></table></figure>

<h2 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ADT Stack&#123;<br>	数据对象：<br>		D=&#123;ai|ai《 ElemSet，i=<span class="hljs-number">1</span>,<span class="hljs-number">2.</span>.&#125;<br>	数据关系：<br>		R1=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai《 D&#125;<br>		约定an为栈顶，a1为栈底<br>	基本操作：初始化，进栈，出栈，取出栈顶元素<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ilEHr9nTAegvI1X.png" alt="image-20220330152226040"></p>
<h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">储存方式：同一般线性表的顺序存储结构完全相同，<br>		利用一组地址连续的存储单元依次存放自栈底到栈顶的元素<br>		top指针，指示栈顶元素在顺序栈中的位置<br>		base指针，指示栈底元素在顺序栈中的位置<br>	<span class="hljs-comment">//注：为了方便操作，通常top指示真正的栈顶元素之上的下标地址（最后一个元素之后的单元）</span><br>    	stacksize表示栈的可使用的最大容量<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">空栈：base <span class="hljs-operator">=</span><span class="hljs-operator">=</span> top是栈空标志<br>栈满：top - base <span class="hljs-operator">=</span> stacksize<br>	栈满时的处理方法：<br>		<span class="hljs-number">1</span>.报错，返回操作系统<br>		<span class="hljs-number">2</span>.分配更大的空间，作为栈的存储空间，将原栈的内容移入新栈<br>		<br>使用数组作为顺序栈存储方式特定：<br>	简单方便，但容易产生溢出<br>上溢：栈已满，又要压入元素<br>下溢：栈已空，还要弹出元素<br>	注：上溢为一种错误，使问题处理无法进行，而下溢为一种结束条件<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	SElemType *base;	<span class="hljs-comment">//栈底指针</span><br>	SElemTypr *top;		<span class="hljs-comment">//栈顶指针</span><br>	<span class="hljs-type">int</span> stacksize;		<span class="hljs-comment">//栈可用最大容量</span><br>&#125;SqStack;<br><br>栈中元素个数 = top-base = <span class="hljs-number">5</span>；<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;	<span class="hljs-comment">//构造一个空栈</span><br>	S.base = <span class="hljs-keyword">new</span> SElemType[MAXSIZE];	<span class="hljs-comment">//c++</span><br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span> (OVERFLOW);	<span class="hljs-comment">//存储分配失败</span><br>    S.top = S.base;<br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><p>空栈：base &#x3D;&#x3D; top是栈空标志</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>		<span class="hljs-comment">//若栈为空，返回TRUE;否则返回FALSE;</span><br>	<span class="hljs-keyword">if</span>(S.top == S.base)<br>		<span class="hljs-keyword">return</span> TRUE;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求栈的长度"><a href="#求栈的长度" class="headerlink" title="求栈的长度"></a>求栈的长度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span>(S.top - S.base);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="清空顺序栈"><a href="#清空顺序栈" class="headerlink" title="清空顺序栈"></a>清空顺序栈</h3><p>将top指针指向栈底</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.base)S.top = S.base;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="销毁顺序栈"><a href="#销毁顺序栈" class="headerlink" title="销毁顺序栈"></a>销毁顺序栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(S.base)&#123;<br>		<span class="hljs-keyword">delete</span> []S.base;		<span class="hljs-comment">//释放了内存</span><br>		S.stacksize = <span class="hljs-number">0</span>;<br>	   <span class="hljs-string">&quot;S.base = S.top = NULL;&quot;</span>	<span class="hljs-comment">//若不将指针置为空，则会称为野指针</span><br>	&#125;							<span class="hljs-comment">//野指针：访问一个已经销毁或者访问受限的内存区域的指针</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的入栈"><a href="#顺序栈的入栈" class="headerlink" title="顺序栈的入栈"></a>顺序栈的入栈</h3><p>算法思想：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.判断是否栈满，若满则出错（上溢）<br><span class="hljs-attribute">2</span>.元素e压入栈顶<br><span class="hljs-attribute">3</span>.栈顶指针加<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S , SELemType e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top - S.base == S.stacksize)	<span class="hljs-comment">//栈满 </span><br>		<span class="hljs-keyword">return</span> ERROR;<br>    <br>	*S.top = e；	<span class="hljs-comment">// *p  指 对p指针所指的空间进行操作, *p该指针空间内的元素	</span><br>    S.top++；<br>        	<span class="hljs-comment">//两部何为一部 *S.top++ = e;	</span><br>   <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="顺序栈的出栈"><a href="#顺序栈的出栈" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h3><p>算法思想</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">top</span>指针下移，元素出栈<br><span class="hljs-number">1</span>.判断是否空栈，若空栈则出错(下溢)<br><span class="hljs-number">2</span>.栈顶元素指针减一，(此时刚好top指针指向栈顶元素)<br><span class="hljs-number">3</span>.获取栈顶元素<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top == S.base)<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//等价于if(StackEmpty(S))</span><br>	--S.top;<br>	e = *S.top;			<span class="hljs-comment">//e = *--S.top;</span><br>	<span class="hljs-keyword">return</span> OK;		<br>&#125;<br><span class="hljs-comment">//若栈不为空，则删除S的栈顶元素，用e返回其值</span><br></code></pre></td></tr></table></figure>

<h2 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h2><p>链栈是运算受限的单链表，只能在链表头部进行</p>
<h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">StackNode</span>&#123;<br>	SElemType data;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-type">StackNode</span> *next;<br>&#125;StackNode, *LinkStack;<br>LinkStack S;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">注意：<br>	<span class="hljs-number">1.</span>链表的头指针就是栈顶<br>	<span class="hljs-number">2.</span>不需要头节点<br>	<span class="hljs-number">3.</span>基本不存在栈满情况<br>	<span class="hljs-number">4</span>，空栈相当于头指针指向空<br>	<span class="hljs-number">5.</span>插入和删除仅在栈顶处执行<br></code></pre></td></tr></table></figure>

<h3 id="链栈的初始化"><a href="#链栈的初始化" class="headerlink" title="链栈的初始化"></a>链栈的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span></span>&#123;<br>	<span class="hljs-comment">//构造一个空栈，栈顶指针置为空</span><br>	S = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断链栈是否为空"><a href="#判断链栈是否为空" class="headerlink" title="判断链栈是否为空"></a>判断链栈是否为空</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> TRUE;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链栈的入栈"><a href="#链栈的入栈" class="headerlink" title="链栈的入栈"></a>链栈的入栈</h3><p>头插法？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span></span>&#123;<br>	p = <span class="hljs-keyword">new</span> StackNode;		<span class="hljs-comment">//生成新节点</span><br>	p-&gt;data = e;		<span class="hljs-comment">//填入数据域</span><br>	p-&gt;next = S;		<span class="hljs-comment">//将新结点插入栈顶</span><br>	S = p;			<span class="hljs-comment">//修改栈顶指针</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;<br>    p = S;			<span class="hljs-comment">//保留栈顶地址，没有头结点</span><br>    S = S-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S!=<span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><p>递归：若一个对象部分的包含它自己，或用它自己给自己定义，则称这个对象是递归的</p>
<p>若一个过程直接地或者间接的调用自己，则称这个过程是递归的过程</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">递归调用函数 遵循后调用先返回<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">递归<br>优点：结构清晰，程序易读<br>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息，时间开销大。<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">如果时间效率要求，可以将递归转化<br>递归-》非递归<br>方法1：尾递归，单项递归-》循环结构<br>方法2：自用栈模拟系统的运行时栈<br><br>单项递归：有一处以上的递归，但语句只和主调函数有关，相互之间参数无关，并且这些递归调用语句位于算法的最后<br></code></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>仅在表尾进行插入操作，在表头进行删除操作的线性表</p>
<p>表尾an队尾，a1队头，先入先出</p>
<p>插入元素称为入队，删除元素称为出队，</p>
<h2 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h2><p>用一维数组base[MAXQSIZE]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br>Typedef <span class="hljs-keyword">struct</span>&#123;<br>	QElemtype *base;	<span class="hljs-comment">//初始化的动态分配存储空间</span><br>						<span class="hljs-comment">//base指向数组的首元素</span><br>	<span class="hljs-type">int</span> front;		<span class="hljs-comment">//头指针，指向队头元素的下标</span><br>	<span class="hljs-type">int</span> rear;		<span class="hljs-comment">//尾指针，指向对尾元素的小标</span><br>&#125;SqQueue;<br><span class="hljs-comment">//注：front rear代表元素下标</span><br></code></pre></td></tr></table></figure>

<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>初始化：front = rear = <span class="hljs-number">0</span><br><br><span class="hljs-number">2.</span>入队：base[rear] = x; rear++;<br><br><span class="hljs-number">3.</span>出队： x = base[front];	front++;<br>		空队标志：front == rear<br>            <br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">问题：当rear = MAXQSIZE时发生越界<br>            若front = <span class="hljs-number">0</span> rear=MAXQSIZE再入队——真溢出<br>            若front != <span class="hljs-number">0</span> rear=MAXQSIZE再入队——假溢出<br>    <br>解决假上溢<br>    <span class="hljs-number">1.</span>将队中元素依次向队头方向移动<br>    		缺点：浪费时间，每移动一次，队中元素都要移动<br>    <br>    <span class="hljs-number">2.</span>将队空间设想成一个循环的表，即分配给队列m个储存单元可以循环使用，<br>    	当rear为MAXQSIZE时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize同理<br>    <br>    	若rear+<span class="hljs-number">1</span> = MAXQSIZE，则令rear = <span class="hljs-number">0</span><br>    <span class="hljs-comment">//利用 模（mod，c语言中：%）运算</span><br>eg.插入运算<br>	Q.base[Q.rear] = x;<br>	Q.rear = (Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE;	<span class="hljs-number">6</span>%<span class="hljs-number">6</span> = <span class="hljs-number">0</span><br>   删除运算<br>	x = Q.base[s.front];<br>	Q.front = (Q.front+<span class="hljs-number">1</span>)%MASQSIZE;<br><br>循环队列：循环使用为队列分配储存空间<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">问题<span class="hljs-number">2</span>：<br>	队空：front == rear<br>	队满：front == rear 两个判断条件相同，如何区别队满和对空<br>    <br>解决方法：<br>    <span class="hljs-number">1.</span>另外设置一个标志以区别队空、队满<br>    	（加元素判断标志为<span class="hljs-number">0</span>则变为<span class="hljs-number">1</span>，删元素如果 front<span class="hljs-number">-1</span> = rear，将标志<span class="hljs-number">1</span>置为<span class="hljs-number">0</span>,标志已经为<span class="hljs-number">0</span>则不能删，用<span class="hljs-number">0</span>，<span class="hljs-number">1</span>判断是否为空）<br>    <br>    <span class="hljs-number">2.</span>令设一个变量，记录元素个数<br>    <br>  <span class="hljs-comment">//3.少用一个元素空间（不用改变struct定义结构）</span><br>    	队满判断：(rear+<span class="hljs-number">1</span>)%MAXQSIZE == front;<br>			尾指针再加<span class="hljs-number">1</span>等于头指针则为满<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Gqe67ozYcTFP8Bh.png" alt="image-20220404152614541"></p>
<h3 id="循环队列的类型定义"><a href="#循环队列的类型定义" class="headerlink" title="循环队列的类型定义"></a>循环队列的类型定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br>Typedef <span class="hljs-keyword">struct</span>&#123;<br>	QElemtype *base;	<span class="hljs-comment">//初始化的动态分配存储空间</span><br>						<span class="hljs-comment">//base指向数组的首元素</span><br>	<span class="hljs-type">int</span> front;		<span class="hljs-comment">//头指针，指向队头元素的下标</span><br>	<span class="hljs-type">int</span> rear;		<span class="hljs-comment">//尾指针，指向对尾元素的小标</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure>

<h3 id="队列的初始化"><a href="#队列的初始化" class="headerlink" title="队列的初始化"></a>队列的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>	Q.base = <span class="hljs-keyword">new</span> QElemType[MAXQSIZE]	<span class="hljs-comment">//分配数组空间</span><br>	Q.base = (QElemType*)<span class="hljs-built_in">malloc</span>(MAXQSIZE*<span class="hljs-built_in">sizeof</span>(QElemType));<br>    <br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW);	<span class="hljs-comment">//存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;		<span class="hljs-comment">//头指针尾指针置为0，队列为空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求队列的长度"><a href="#求队列的长度" class="headerlink" title="求队列的长度"></a>求队列的长度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">return</span>((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);<br>&#125;	<span class="hljs-comment">//当rear &lt; front 时需要加上MAXQSIZE</span><br><br><span class="hljs-comment">//队尾减去队头，如果rear循环 加上MAXQSIZE</span><br></code></pre></td></tr></table></figure>

<h3 id="循环队列入队"><a href="#循环队列入队" class="headerlink" title="循环队列入队"></a>循环队列入队</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE == Q.front)	<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">//队满</span><br>    <br>    Q.base[Q.rear] = e;		<span class="hljs-comment">//新元素加入队尾</span><br>    Q.rear = (Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE;	<span class="hljs-comment">//队尾指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="循环队列出队"><a href="#循环队列出队" class="headerlink" title="循环队列出队"></a>循环队列出队</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;		<span class="hljs-comment">//队空</span><br>	e = Q.base[Q.front];			<span class="hljs-comment">//保存队头元素</span><br>	Q.front = (Q.front+<span class="hljs-number">1</span>)%MAXQSIZE;		<span class="hljs-comment">//队头指针+1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front != Q.rear)&#123;		<span class="hljs-comment">//队列不为空</span><br>		<span class="hljs-keyword">return</span> Q.base[Q.front];		<span class="hljs-comment">//返回队头指针元素的值，队头指针不变</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p>队列的链式表示和实现</p>
<h3 id="链队列的类型定义"><a href="#链队列的类型定义" class="headerlink" title="链队列的类型定义"></a>链队列的类型定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 	<span class="hljs-comment">//最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span>&#123;<br>	QElemType data;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span> *next;<br>&#125;QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QueuePtr front;	<span class="hljs-comment">//队头指针</span><br>    QueuePtr rear;	<span class="hljs-comment">//队尾指针</span><br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/omVXh3u4DHvpSOJ.png" alt="image-20220404165627856"></p>
<h3 id="链队的初始化"><a href="#链队的初始化" class="headerlink" title="链队的初始化"></a>链队的初始化</h3><p>找到一个头结点，首尾指针都指向头节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>	Q.front = Q.rear = (QueuePtr) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span>(!Q.front) <span class="hljs-built_in">exit</span>(OVERFLOW);	<span class="hljs-comment">//判断是否生成成功，可以不要</span><br>    <br>    Q.front -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列的销毁"><a href="#链队列的销毁" class="headerlink" title="链队列的销毁"></a>链队列的销毁</h3><p>从头结点开始，依次释放所有的结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestroyQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(Q.front)&#123;<br>		p = Q.front-&gt;next;<br>		<span class="hljs-built_in">free</span>(Q.front);<br>		Q.front = p;<br>        <br>        <span class="hljs-comment">//也可以不使用新指针p，直接使用尾指针rear</span><br>        Q.rear = Q.front-&gt;next;<br>        <span class="hljs-built_in">free</span>(Q.front);<br>        Q.front = Q.rear;<br>	&#125;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列的入队"><a href="#链队列的入队" class="headerlink" title="链队列的入队"></a>链队列的入队</h3><p>只能放在队尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;<br>	p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    p-&gt;data = e; p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;	<span class="hljs-comment">//将新结点接入链表</span><br>    Q.rear = p;		<span class="hljs-comment">//尾指针指向最后</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列的出队"><a href="#链队列的出队" class="headerlink" title="链队列的出队"></a>链队列的出队</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;e, QElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <br>    <span class="hljs-keyword">if</span>(Q.rear==p)Q.rear = Q.front;	<span class="hljs-comment">//如果最后一个元素出队，则需要将尾指针指向头结点</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链队列队头元素"><a href="#链队列队头元素" class="headerlink" title="链队列队头元素"></a>链队列队头元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue Q, QElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>	e = Q.front-&gt;next-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h1><p>串：内容受限的线性表，内容只能为字符</p>
<p>数组和广义表是线性表的推广</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串：零个或者多个任意字符组成的有限序列</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a1a2····an&quot;</span><br></code></pre></td></tr></table></figure>

<p>子串：串中任意个连续字符组成的子序列（含空串）称为该串的子串</p>
<p>主串：包含子串的串相应的称为主串</p>
<p>字符位置：字符在序列中的序号为该字符在串中的位置</p>
<p>子串位置：子串的第一个字符在主串中的位置</p>
<p>空格串：由一个或多个空格组成的串，与空串不同</p>
<p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p>​		所有的空串都是相等的</p>
<h2 id="串的类型定义"><a href="#串的类型定义" class="headerlink" title="串的类型定义"></a>串的类型定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ADT String&#123;<br>	数据对象 <br>	数据关系：前驱和后继<br>	基本操作：<br>		<span class="hljs-built_in">StrAssign</span>(&amp;T,chars)		<span class="hljs-comment">//串赋值</span><br>		<span class="hljs-built_in">StrCompare</span>(S,T)			<span class="hljs-comment">//串比较</span><br>		<span class="hljs-built_in">StrLength</span>(S)			<span class="hljs-comment">//求串长</span><br>		<span class="hljs-built_in">Concat</span>(&amp;T,S1,S2)		<span class="hljs-comment">//串连结</span><br>		<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/U92OwhGAI1ja5CB.png" alt="image-20220412105342766" style="zoom: 40%;" />

<h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.顺序串<br>2.链串<br></code></pre></td></tr></table></figure>

<h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	<span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];		<span class="hljs-comment">//存储串的一维数组</span><br>	<span class="hljs-type">int</span> length;		<span class="hljs-comment">//串当前长度</span><br>&#125;SString;<br>		<span class="hljs-comment">//注：为了算法描述方便，下标为0的位置不用,所以MAXLEN+1</span><br></code></pre></td></tr></table></figure>

<h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">优点：操作方便		缺点：存储密度较低<br>	可以将多个字符放在一个节点中，以克服其缺点<br></code></pre></td></tr></table></figure>

<p>所有采用块链结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80	<span class="hljs-comment">//块的大小可以由用户定义</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>	<span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span> *next;<br>&#125;Chunk;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    Chunk *head,*tail;		<span class="hljs-comment">//串的头指针和尾指针</span><br>    <span class="hljs-type">int</span> curlen;				<span class="hljs-comment">//串的当前长度</span><br>&#125;LString;					<span class="hljs-comment">//字符串的块链结构</span><br><br></code></pre></td></tr></table></figure>

<h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h2><p>确定主串中所含子串(模式串)第一次出现的位置（定位）</p>
<p>​	应用：搜索引擎，拼写，语言翻译，数据压缩</p>
<p>算法种类：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BF算法：暴力破解</span><br><span class="hljs-keyword"></span>KMP算法（特点速度快）<br></code></pre></td></tr></table></figure>

<h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>穷举法</p>
<p>算法思路：从主串的每一个字符开始依次与T的字符进行匹配</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">INdex</span>(S,<span class="hljs-built_in">T</span>,pos)<br>将主串的第pos个字符和模式串的第一个字符比较，<br>	若相等，继续逐个比较后续字符；<br>	若不等，从主串的下一字符其，重新与模式串的第一个字符比较<br>	<br>	直到主串的一个连续字符序列与模式串相等，返回值为S中与<span class="hljs-built_in">T</span>匹配的子序列第一个字符的序号，即匹配成功。<br>	否则匹配失败，返回值<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString SString, SString T,(<span class="hljs-type">int</span> pos))</span></span>&#123; <span class="hljs-comment">//pos表示从中间的某个地方开始寻找</span><br>	<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>(pos),j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;<br>        <span class="hljs-keyword">if</span>(s.ch[i] == t.ch[j])&#123;<br>            i++;j++;	<span class="hljs-comment">//主串和子串依次匹配下一个字符</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>			i = i-j+<span class="hljs-number">2</span> ;		<span class="hljs-comment">// i = i - (j-1) + 1 (没有0号位置)</span><br>            j = <span class="hljs-number">1</span>;		<span class="hljs-comment">//主串、子串指针回溯重新开始下一次匹配</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt;= T.length) <span class="hljs-keyword">return</span> i-T.length;	<span class="hljs-comment">//返回匹配的第一个字符的下标</span><br>    		???匹配成功的判断条件，需要仔细考虑，没有 == <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<span class="hljs-comment">//匹配失败</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">算法复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>*<span class="hljs-variable">m</span>)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span> Index_BF(string S, string T)&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ,j = <span class="hljs-number">1</span>;  <span class="hljs-comment">//下标从1开始</span><br>    <span class="hljs-keyword">while</span> (i &lt;= S.<span class="hljs-built_in">length</span>() &amp;&amp; j &lt;= T.<span class="hljs-built_in">length</span>())<br>    &#123;   <br>       <span class="hljs-keyword">if</span>(S[i] == T[j])&#123;<br>            i++;j++;<br>       &#125; <span class="hljs-keyword">else</span>&#123;<br>        i = i - (j<span class="hljs-number">-1</span>) +<span class="hljs-number">1</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-comment">//匹配成功 返回下标</span><br>    <span class="hljs-keyword">if</span>(j&gt;T.<span class="hljs-built_in">length</span>()) <span class="hljs-keyword">return</span> i-T.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="*KMP算法"></a>*KMP算法</h3><p><a href="https://www.cnblogs.com/zzuuoo666/p/9028287.html">参考文章：很详尽KMP算法（厉害）</a></p>
<p>当匹配失败的时候，每次移动一个字符位置时间时间复杂度高，<strong>模式串以匹配成功部分的 后缀 可能与 起前缀有一部分是相同的 可将其直接向后移动</strong> 以达到不向前移动 i的目的</p>
<p><strong>移动位数 &#x3D;  以匹配字符数 - 对应的部分匹配值</strong></p>
<p>kmp算法关键 要对 模式串进行预处理 <strong>计算每一位的部分匹配值，即next数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">jNNNNjNNNN<br>next[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<p>ac模板next求法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>    <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>    ne[i] = j;<br>&#125;   <span class="hljs-comment">// ne[0] 为0默认值</span><br></code></pre></td></tr></table></figure>

<p>i &#x3D; next[]</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>非线性结构：树形结构（一个前驱多个后继）</p>
<p>​						图形结构（多个前驱多个后继）</p>
<p>树形结构：结点之间有分支，具有层次结构</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">树：是<span class="hljs-built_in">n</span>(<span class="hljs-comment">n&gt;=0</span>)个结点的有限集<br>	若<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span>，空树<br>	若<span class="hljs-built_in">n</span> &gt; <span class="hljs-number">0</span>,则满足<br>		<span class="hljs-number">1</span>.有且仅有一个特定的称为根的结点<br>		<span class="hljs-number">2</span>.其余结点可分为m(m&gt;=<span class="hljs-number">0</span>)个互不相交的有限集<span class="hljs-symbol">T1</span>，<span class="hljs-symbol">T2</span>，<span class="hljs-symbol">T3</span>...其中没一个集合本身都是一颗树，并称为根的的字树。<br>树的定义是一个递归的定义<br></code></pre></td></tr></table></figure>

<h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">结点：数据元素以及指向字数的分支<br>	根节点：非空树中无前驱结点的结点<br><br><span class="hljs-number">1.</span>结点的度：结点拥有的子树数（后继结点）<br><span class="hljs-number">2.</span>数的度：树内各结点的度的最大值<br>    叶子节点：度为<span class="hljs-number">0</span>的节点——终端节点<br>	度 != <span class="hljs-number">0</span> 分支节点，根节点以外的分支结点称为内部结点<br><br>结点的子树称为该节点的孩子，该节点称为孩子的双亲。  ———— 上下关系<br>    兄弟节点：<br>    堂兄弟节点：双亲在同一层的节点<br>    <br>结点的祖先：从根到该结点所经分支上所有节点<br>结点的子孙：以某结点为根的子树中的任一结点。<br>    <br>    树的深度：树中结点的最大层次<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/HX69JuDIPkdEynw.png" alt="image-20220414001908089"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">有序树：树中结点的各子树从左至右有次序（最左边的为第一个孩子）<br>无序树：树中结点的各子树无次序<br><br>森林：是m（m &gt;<span class="hljs-operator">=</span><span class="hljs-number">0</span>) 课互不相交的树的集合<br>	给森林的各子树加上一个双亲结点，森林就变成了树<br>	树一定是森林，森林不一定是树<br></code></pre></td></tr></table></figure>

<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树的结构简单，规律性最强</p>
<p>多叉树可以转化为二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">二插树是n&gt;=<span class="hljs-number">0</span>个结点的有限集，它或者是空集（n=<span class="hljs-number">0</span>）,或者由由一个根结点及两颗互不相交的分别称作这个根的左子树和右子树<br>特点：<br>	<span class="hljs-number">1.</span>每个结点最多有两个孩子（二叉树中不存在度大于<span class="hljs-number">2</span>的节点）<br>	<span class="hljs-number">2.</span>子树有左右之分，其次序不能颠倒<br>	<span class="hljs-number">3.</span>二叉树可以是空集合，根可以有空的左子树或空的右子树<br>    <br><span class="hljs-comment">//注：二叉树不是树的特殊情况，他们是两个概念</span><br>    	要区分左子树，和右子树<br>    虽然二叉树与树的概念不同，但是关于树的基本术语都试用<br>    <br>二叉树中每个结点的位置或者说次序是固定的，可以为空，但不可以说它没有位置<br></code></pre></td></tr></table></figure>

<h2 id="二叉树抽象数据类型定义"><a href="#二叉树抽象数据类型定义" class="headerlink" title="二叉树抽象数据类型定义"></a>二叉树抽象数据类型定义</h2><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">ADT BinaryTree&#123;<br>	数据对象D:具有相同特性的元素集合<br>	数据关系R：空集，二元关系<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>在二叉树的第i层上至多有<span class="hljs-number">2</span> <span class="hljs-built_in">pow</span>(i<span class="hljs-number">-1</span>)个结点，最少一个结点<br><br><span class="hljs-number">2.</span>深度为k的二叉树 至多 有<span class="hljs-number">2</span> <span class="hljs-built_in">pow</span>(k)<span class="hljs-number">-1</span> 个结点。(k&gt;=<span class="hljs-number">1</span>),最少k个结点<br>    <br><span class="hljs-number">3.</span>对于任何一颗二叉树T，其叶子树为n0，度为<span class="hljs-number">2</span>的结点树为n2，则n0 = n2 + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>满二叉树</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">一个深度为k且有<span class="hljs-number">2</span> <span class="hljs-built_in">pow</span>(k) -<span class="hljs-number">1</span> 个结点的二叉树称为满二叉树。<br>特点：<br>	<span class="hljs-number">1</span>.每一层上的结点数都是最大结点数（即每层都满）<br>	<span class="hljs-number">2</span>.叶子节点全部在最底层<br>	<br>满二叉树在同样深度的二叉树中结点个数最多<br>满二叉树在同样深度的二叉树中叶子结点个数最多<br></code></pre></td></tr></table></figure>

<p>完全二叉树</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中的编号<span class="hljs-number">1</span>~n的结点一一对应时，称为完全非二叉树。<br><br>特点：<br>	<span class="hljs-number">1</span>.叶子只可能分布在层次最大的两次上<br>	<span class="hljs-number">2</span>.对任一结点，如果其右子树的最大层次为<span class="hljs-selector-tag">i</span>，其左子树的最大层次必为<span class="hljs-selector-tag">i</span>或<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">性质<span class="hljs-number">4</span><br>	具有n个结点的完全二叉树的深度为 log2n 的底 + <span class="hljs-number">1</span><br>		注：x的底，表示不大于x的最大整数<br>	性质<span class="hljs-number">4</span>表明了完全二叉树<span class="hljs-string">&#x27;结点数n&#x27;</span>与完全二叉树<span class="hljs-string">&#x27;深度k&#x27;</span>之间的关系<br>    <br>    <br>性质<span class="hljs-number">5</span>：<br>    说明了<br>   <span class="hljs-string">&#x27;完全二叉树&#x27;</span>中<span class="hljs-string">&#x27;双亲结点编号&#x27;</span>与<span class="hljs-string">&#x27;孩子结点编号&#x27;</span>之间的关系<br>    第i个节点<br>    <span class="hljs-number">1.</span>双亲结点i/<span class="hljs-number">2</span><br>    <span class="hljs-number">2.</span>左孩子节点<span class="hljs-number">2</span>i<br>    <span class="hljs-number">3.</span>右孩子节点<span class="hljs-number">2</span>i+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树顺序存储表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100</span><br>Typedef TElemType SqBiTree[MAXSTIZE];<br>SqBiTree bt;		<span class="hljs-comment">//Binary Tree 二叉树</span><br><br><span class="hljs-number">1.</span>完全二叉树——按编号依次存储即可<br><span class="hljs-number">2.</span>如果是非完全二叉树—— 则需要补上空值，顺序存储<br></code></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">缺点：<br>	最坏情况：深度为<span class="hljs-variable">k</span>的且只有<span class="hljs-variable">k</span>个结点的单支树需要长度为<span class="hljs-number">2</span><span class="hljs-built_in">K</span><span class="hljs-operator">-</span><span class="hljs-number">1</span>的一维数组<br>	<br>特点：	<br>	结点间关系蕴含在其存储位置中<br>	浪费空间，适于存满二叉树和完全二叉树<br></code></pre></td></tr></table></figure>

<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell">特点：一个双亲parent，一个数据域<span class="hljs-class"><span class="hljs-keyword">data</span>，一个左孩子lchild，一个右孩子rchild</span><br></code></pre></td></tr></table></figure>

<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<br>	TElemType data;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span> *Ichild, *rchild;		<span class="hljs-comment">//左右孩子指针	</span><br>&#125;BiNode,*BiTree;<br><br><span class="hljs-comment">//嵌套定义 </span><br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">在<span class="hljs-built_in">n</span>个结点的二叉链表中，有<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>个空指针域<br>	<span class="hljs-number">2</span><span class="hljs-built_in">n</span>-（<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>） = <span class="hljs-built_in">n</span>+<span class="hljs-number">1</span><br>	<span class="hljs-number">2</span><span class="hljs-built_in">n</span>是共有链域，<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>是出了根结点都有双亲，剩余则就是空指针域<br></code></pre></td></tr></table></figure>

<h4 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h4><p>三个指针域parent，data，lchild，rchild</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm">typedef struct <span class="hljs-type">TriTNode</span>&#123;<br>	<span class="hljs-type">TElemType</span> data;<br>	struct <span class="hljs-type">TriTNode</span> *<span class="hljs-type">Ichild</span>,*parent,*rchild;		  	<br>&#125;<span class="hljs-type">TriTNode</span>,*<span class="hljs-type">TriTree</span>;<br></code></pre></td></tr></table></figure>

<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均背访问一次，且仅被访问一次</p>
<p>遍历是二叉树一切算法的核心</p>
<p>遍历方法：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">依次遍历二叉树中的三个组成部分，变是遍历了整个二叉树<br><span class="hljs-variable">L</span>：遍历左子树 <span class="hljs-built_in">D</span><span class="hljs-operator">:</span>访问根结点，<span class="hljs-variable">R</span>：遍历右子树<br><span class="hljs-variable">DLR</span>、<span class="hljs-variable">LDR</span>、<span class="hljs-variable">LRD</span>、<span class="hljs-variable">DRL</span>、<span class="hljs-variable">RDL</span>、<span class="hljs-variable">RLD</span> 六种<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">DLR——先序遍历 ——根左右<br>LDR——中序遍历 ——左根右<br>LRD——后序遍历 ——左右根<br><br>ABDGCEHF<br>DGBAEHCF<br>GDBHEFCA<br><br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/BfIOeWkb7XdaqRP.png" alt="image-20220414135424489" style="zoom:33%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">先序：-+axb-cd/ef		前缀表达式<br>中序：a+bxc-d-e/f		中缀表达式<br>后序：abcd-x+ef/-		后缀表达式<br></code></pre></td></tr></table></figure>

<p>根据遍历序列确定二叉树</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的<br><br>由二叉树的先序序列和后序，或者后序和中序可以确定唯一二叉树<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">先序和中序：<br>	由先序序列确定根；由中序序列确定左右子树，逐渐夹逼<br>	<br>中序和后续<br>	后续遍历，根结点必在后序序列尾部<br></code></pre></td></tr></table></figure>

<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><h4 id="先序遍历-—-实现"><a href="#先序遍历-—-实现" class="headerlink" title="先序遍历 — 实现"></a>先序遍历 — 实现</h4><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">DLR<br>若二叉树为空：则空操作<br>若二叉树非空,<br>	访问根节点<span class="hljs-comment">(D)</span><br>	前序遍历左子树<span class="hljs-comment">(L)</span><br>	前序遍历右子树<span class="hljs-comment">(R)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);		<span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);	<span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild);	<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="中序遍历-—-实现"><a href="#中序遍历-—-实现" class="headerlink" title="中序遍历 — 实现"></a>中序遍历 — 实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">INOrderTraverse</span>(T-&gt;lchild);	<span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T);		<span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">INOrderTraverse</span>(T-&gt;rchild);	<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="后序遍历-—-实现"><a href="#后序遍历-—-实现" class="headerlink" title="后序遍历 — 实现"></a>后序遍历 — 实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);	<span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild);	<span class="hljs-comment">//递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T);		<span class="hljs-comment">//访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或者说三中算法的访问路径是完全相同的，只是访问的时机不同。</p>
<img src="https://s2.loli.net/2024/02/24/K9GFNCRrkfSymVI.png" alt="image-20220414150959949" style="zoom:33%;" />

<p>每个节点经过三次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">时间复杂度O(n)	<span class="hljs-comment">//每个结点只访问一次</span><br>空间复杂度O(n)		<span class="hljs-comment">//栈所占用的最大辅助空间</span><br>		<span class="hljs-comment">//内存中需要一个储存栈</span><br></code></pre></td></tr></table></figure>

<h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><p>中序遍历二叉树：</p>
<p>二叉树中序遍历的非递归算法关键：在中序遍历经过某结点的整个左子树后，如何找到该结点的根和右子树</p>
<p>基本思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>建立一个栈<br><span class="hljs-number">2.</span>根结点进栈，遍历左子树<br><span class="hljs-number">3.</span>根结点出栈，输出根结点，遍历右子树<br>    <br>遇到结点，先入栈，访问左子树，当左子树为空，根节点出栈，访问右子树，右子树为空查询栈是否为空，不为空出栈继续访问，为空则为整个树都访问完成<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	BiTree p;<br>	<span class="hljs-built_in">InitStack</span>(S);		<span class="hljs-comment">//初始化一个栈</span><br>	p=T;	<span class="hljs-comment">//指向根节点</span><br>	<span class="hljs-keyword">while</span>(p||!<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>		<span class="hljs-keyword">if</span>(p)&#123;<br>			<span class="hljs-built_in">Push</span>(S,p); p = p-&gt;Ichild;<br>		&#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">Pop</span>(S,q);	<span class="hljs-comment">//p为空就用q接收栈顶元素</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, q-&gt;data;)<br>            p = q-&gt;rchild;	<span class="hljs-comment">//继续访问右子树</span><br>            <br>        &#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 注：这里栈中存储的数据为树的指针</span><br></code></pre></td></tr></table></figure>

<h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>对于一个二叉树，从根节点开始，从上到下，从左到右的顺序访问每一个节点</p>
<p>​		没个节点仅访问一层</p>
<p>算法思想</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">使用一个队列<br><span class="hljs-number">1</span>.将根结点进队<br><span class="hljs-number">2</span>.队不空时循环:从队列中出列一个结点*p,访问它;<br>	<span class="hljs-number">1</span>.若它有左孩子结点，将左孩子结点进队<br>	<span class="hljs-number">2</span>.若它有右孩子结点，将右孩子结点进队<br></code></pre></td></tr></table></figure>

<p>实现</p>
<p>队列类型定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	BiNode data[MaxSize];		<span class="hljs-comment">//存放队中元素</span><br>	<span class="hljs-type">int</span> front, rear;			<span class="hljs-comment">//队头和队尾指针</span><br>&#125;SqQueue;		<span class="hljs-comment">//顺序循环队列类型</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LeverOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    <br>	BTNode *p;	SqQueue qu;<br>    <span class="hljs-built_in">InitQueue</span>(qu);		<span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b);		<span class="hljs-comment">//根结点指针进入队列</span><br>    <br>    <br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;		<span class="hljs-comment">//队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p);				<span class="hljs-comment">//出队结点p</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p-&gt;data);		<span class="hljs-comment">//访问结点p</span><br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>			<span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild);<br>        &#125;			<span class="hljs-comment">//有左孩子时将其进队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">enQueue</span>(qu, p-&gt;rchild);<br>        &#125;			<span class="hljs-comment">//有右孩子时将其进队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>遍历算法的应用</p>
<p>用 先序遍历序列 建立二叉树的二叉链表</p>
<p>先序序列逆推二叉树不是唯一的，要确保唯一性用空节点补充 #<br>        ABC##DE#G##F###</p>
<p>ABD#G###CE#H##F##</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&quot;#&quot;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(!(T=(BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode))))<br>            <span class="hljs-built_in">exit</span>(OVERFLOW);		<span class="hljs-comment">// T = new BiTNode;</span><br>        T-&gt;data = ch;	<span class="hljs-comment">//生成根结点</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);	<span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h3><p>算法思想</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">如果是空树，递归结束<br>否则，申请新的结点空间，复制根结点<br>	递归复制左子树<br>	递归复制右子树<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T, BiTree &amp;New T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>		NewT = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>		NewT = <span class="hljs-keyword">new</span> BiTNode;<br>        NewT-&gt;data = T-&gt;data;<br>        <br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild, NewT-&gt;lchild);<br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild, NewT-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h3><p>思想</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">如果是空树，则深度为<span class="hljs-number">0</span><br>否则，递归计算左子树的深度记为m，递归计算右子树的深度记为<span class="hljs-built_in">n</span>，二叉树的深度则为m与<span class="hljs-built_in">n</span>中较大者加<span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);<br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild); <br>        <span class="hljs-keyword">if</span>(m&gt;n) <span class="hljs-keyword">return</span> (m+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span>(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算二叉树的结点总数"><a href="#计算二叉树的结点总数" class="headerlink" title="计算二叉树的结点总数"></a>计算二叉树的结点总数</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">如果是空树，则结点个数为0;<br>否则,结点个数个数为左子树的结点个数 + 右子树的结点个数再<span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算叶子结点树"><a href="#计算叶子结点树" class="headerlink" title="计算叶子结点树"></a>计算叶子结点树</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">如果是空树，则叶子结点个数为0<br>否则，为左子树的叶子结点个数 + 右子树的叶子结点个数<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;	<span class="hljs-comment">//如果是叶子结点返回1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>&#125;<br>	<span class="hljs-comment">//通过递归，叶子结点返回1，一个一个相加</span><br></code></pre></td></tr></table></figure>

<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>问题：如何寻找特定遍历序列中二叉树结点的前驱和后继</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">解决方法：<br><span class="hljs-number">1.</span>通过遍历寻找			——费时间<br><span class="hljs-number">2.</span>再增设前驱、后继指针域	——增加了存储负担<br><span class="hljs-number">3.</span>利用二叉链表的空的指针域<br><br>	如果某个结点的左孩子为空，则将空的左孩子指针域改为<span class="hljs-string">&#x27;指向其前驱&#x27;</span>；如果某结点的右孩子为空，则将空的右孩子指针域改为<span class="hljs-string">&#x27;指向其后继&#x27;</span><br>    	——<span class="hljs-string">&#x27;这种改变指向的指针称为&quot;线索&quot;&#x27;</span><br>    线索二叉树——Threaded Binary Tree<br><br>对二叉树按某种遍历次序使其变为线索二叉树的过程叫<span class="hljs-string">&#x27;线索化&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p>森林是m(m&gt;&#x3D;0)课互不相交的树的集合</p>
<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">实现：定义<span class="hljs-string">&#x27;结构数组&#x27;</span>，存放树的结点、没个结点含两个域<br>	数据域：存放结点本身的信息<br>	双亲域:指示本结点的双亲结点在数组中的位置<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">特点：找双亲容易，找孩子难<br></code></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>	TElemType data;<br>	<span class="hljs-type">int</span> parent;		<span class="hljs-comment">//双亲位置域</span><br>&#125;PTNode;<br><br>树结构：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	PTNode nodes[MAX_TREE_SIZE];<br>	<span class="hljs-type">int</span> r, n; <span class="hljs-comment">//根结点的位置和结点个数</span><br>&#125;PTree；<br></code></pre></td></tr></table></figure>

<h3 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h3><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储<br>则<span class="hljs-built_in">n</span>个结点有<span class="hljs-built_in">n</span>个孩子链表(叶子的孩子链表为空表)，孩子链表设头指针<br>而<span class="hljs-built_in">n</span>个头指针又组成一个线性表，用顺序表（含<span class="hljs-built_in">n</span>个元素的结构数组）存储。<br></code></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">孩子结点结构：<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>	<span class="hljs-type">int</span>  child;		<span class="hljs-comment">//孩子节点下标的位置</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next;	<span class="hljs-comment">//下一个孩子的指针</span><br>&#125;*ChildPtr;<br>双亲结点结构：<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	TElemType	data;<br>	ChildPtr firstchild;		<span class="hljs-comment">//孩子链表头指针</span><br>&#125;CTBox;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">特点：找孩子容易，找双亲难<br></code></pre></td></tr></table></figure>

<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>二叉树表示法，二叉链表表示法</p>
<p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm">typedef struct <span class="hljs-type">CsSNode</span>&#123;<br>	<span class="hljs-type">ElemType</span> data；<br>	struct <span class="hljs-type">CSNode</span> *firstchild，*nextsibling;<br>&#125;<span class="hljs-type">CSNode</span>,*<span class="hljs-type">CSTree</span>;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Ua8oW61pOSC5DNP.png" alt="image-20220424180352061"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">左孩子，右兄弟<br>但不利于找双亲<br></code></pre></td></tr></table></figure>

<h3 id="树与二叉树的转化"><a href="#树与二叉树的转化" class="headerlink" title="树与二叉树的转化"></a>树与二叉树的转化</h3><p><img src="https://s2.loli.net/2024/02/24/xFDhO2vfTWycSp9.png" alt="image-20220424181505568"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>加线：在兄弟加一条线<br><span class="hljs-number">2.</span>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系<br><span class="hljs-number">3.</span>旋转：以树的根结点为轴心，将整树顺时针转<span class="hljs-number">45</span><br><br>树变二叉树：兄弟相连留长子		<span class="hljs-string">&#x27;长兄如父&#x27;</span><br>    <br><br>二叉树变树：左孩右右连双亲，去掉原来右孩线<br></code></pre></td></tr></table></figure>

<h3 id="森林转化成二叉树"><a href="#森林转化成二叉树" class="headerlink" title="森林转化成二叉树"></a>森林转化成二叉树</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.将各棵树分别转换成二叉树<br>2.将每棵树的根结点用线相连<br>3.以第一颗树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构<br><br>树变二叉根相连<br><br>二叉树变森林：去掉全部右孩线，孤立二叉再还原<br><br></code></pre></td></tr></table></figure>

<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p>树：</p>
<p>三种方式：先根，后根，层次遍历</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">先跟遍历：若树不为空，先访问根的结点，然后依次先根遍历各课子树<br>后跟遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点<br>层次遍历：若树不空，则自上而下自左至右访问树中每个结点（队列）<br></code></pre></td></tr></table></figure>

<p>森林：</p>
<p>看成三部分构成：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.森林中第一课树的根结点<br>2.森林中第一课树的子树森林<br>3.森林中其他树构成的森林<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">先根：依次从左至右对森林中的每一棵树进行先根遍历<br>中序遍历：<br>	<span class="hljs-number">1.</span>中序遍历森林中第一棵树的子树森林<br>	<span class="hljs-number">2.</span>访问森林中第一颗树的根节点<br>	<span class="hljs-number">3.</span>中序遍历森林中，除第一颗树之外其余树构成的森林<br>		<span class="hljs-string">&#x27;依次从左至右对森林中的每一棵树进行h根遍历&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径<br><br>		结点的路径长度：两结点间路径上的分支数<br><br><span class="hljs-number">2.</span>数的路径长度：从树根到每一个结点的路径长度之和<br>		结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树<br><br><span class="hljs-number">3.</span>权：将树中结点赋给一个有着某种含义的数值，这个数组成为该结点的权<br>		结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积<br>		树的带权路径长度：树中所有叶子结点的带权路径长度之和。<br>    <br>哈夫曼树：最优二叉树（带权路径长度 (WPL)最短的二叉树）<br>    注：<span class="hljs-number">1.</span>满二叉树不一定是哈夫曼树<br>       <span class="hljs-string">&#x27;2.哈夫曼树中权越大的叶子离根近&#x27;</span><br>       <span class="hljs-number">3.</span>具有相同带权结点的哈夫曼树不唯一<br></code></pre></td></tr></table></figure>

<h3 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">贪心算法：构造哈夫曼树时首先选择权值小的叶子结点<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.构造森林全是根<br><span class="hljs-attribute">2</span>.选用两小造新树<br><span class="hljs-attribute">3</span>.删除两小添新人<br><span class="hljs-attribute">4</span>.重复<span class="hljs-number">2</span>，<span class="hljs-number">3</span>剩单根<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>哈夫曼树的结点度数为<span class="hljs-number">0</span>或<span class="hljs-number">2</span>，没有度为<span class="hljs-number">1</span>的结点<br>  	度：结点的子树<br><span class="hljs-number">2.</span>包含n个叶子结点的哈夫曼树中共用<span class="hljs-number">2</span>n<span class="hljs-number">-1</span>个结点<br></code></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">采用顺序存储结构 —— 一维结构数组<br></code></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-type">int</span> weight;<br>	<span class="hljs-type">int</span> parent,lch,rch;<br>&#125;NTNode,*HuffmanTree;<br><br></code></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>初始化HT[<span class="hljs-number">1.</span>.<span class="hljs-number">.2</span>n<span class="hljs-number">-1</span>]: lch = rch = parent =<span class="hljs-number">0</span>;<br><span class="hljs-number">2.</span>输入n个叶子结点：置HT[<span class="hljs-number">1.</span>...n]的weight值<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHUffmanTree</span><span class="hljs-params">(HuffmanTree &amp;HT, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br>    m = <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;		<span class="hljs-comment">//数组共2n-1个元素</span><br>    <br>    HT = <span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];	??/<span class="hljs-number">0</span>不使用所以申请<span class="hljs-number">2</span>n长度 ，<span class="hljs-string">&quot;为啥是2n？？？？？？&quot;</span><br>        <br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;		<span class="hljs-comment">//将2n-1个元素lch = rch = parent =0</span><br>        HT[i].lch = <span class="hljs-number">0</span>;<br>        HT[i].rch = <span class="hljs-number">0</span>;<br>        HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n,i++)&#123;<br>        cin&gt;&gt;HT[i].weight;	<span class="hljs-comment">//输入前n个元素的weight值</span><br>    &#125;<br>&#125;<span class="hljs-comment">//初始化结束，开始建立哈夫曼树</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3.</span>进行以下n<span class="hljs-number">-1</span>次合并，依次产生n<span class="hljs-number">-1</span>个结点HT[i],i=n+<span class="hljs-number">1.</span>..<span class="hljs-number">.2</span>n<span class="hljs-number">-1</span><br>	a) 在HT[<span class="hljs-number">1.</span>..i<span class="hljs-number">-1</span>]中选两个未被选过(从parent == <span class="hljs-number">0</span>的结点中选)的weight最小的两个结点HT[s1]和HT[s2],s1,s2为两个最小结点下标<br>	b)修改HT[s1]和HT[s2]的parent值：HT[s1].parent=i;HT[s2].parent=i;<br>	c)修改新产生的HT[i]<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>		HT[i].lch = s1; HT[i].rch = s2;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i = n+<span class="hljs-number">1</span>; i&lt;m;i++)&#123;<br>	<span class="hljs-built_in">Select</span>(HT,i<span class="hljs-number">-1</span>,s1,s2);	<span class="hljs-comment">//在HT[k](1&lt;=k&lt;=i-1)中选择两个双亲域为0，</span><br>    						<span class="hljs-comment">//且权值最小的结点，并返回他们在HT中的序号 s1和s2</span><br>    <br>    HT[s1].parent=i;HT[s2].parent=i;<span class="hljs-comment">//表示从表F中删除</span><br>    <br>    HT[i].lch = s1; HT[i].rch = s2;		<span class="hljs-comment">//s1,s2为i左右孩子</span><br>    HT[i].weight = HT[s1].weight + HT[s2].weight;	<span class="hljs-comment">//i的权值为左右孩子的权值之和</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><img src="https://s2.loli.net/2024/02/24/OzAbcQmNFWXDBhe.png" alt="image-20220501143636920"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.为什么哈夫曼编码能够保证是前缀编码？<br>	因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的前缀<br>2.为什么哈夫曼编码能保证字符编码总长最短？<br>	因为哈夫曼树的带权路径长度最短，故字符编码的总长最短<br>	<br>	任一字符的编码都不是另一个字符的编码的前缀—— 前缀编码<br>性质：1.哈夫曼编码是前缀编码<br>	 2.哈夫曼编码是最优前缀码<br>	 <br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanCode</span><span class="hljs-params">(HuffmanTree HT,HuffmanCode &amp;HC,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br>    <br>	HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> *[n+<span class="hljs-number">1</span>];	<span class="hljs-comment">//分配n个字符编码的头指针矢量</span><br>    cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];		<span class="hljs-comment">//分配临时存放编码的动态数组空间</span><br>    cd[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;			<span class="hljs-comment">//编码结束符</span><br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;		<span class="hljs-comment">//逐个字符求哈夫曼编码</span><br>		start = n<span class="hljs-number">-1</span>; c=i; f=HT[i].parent;<br>        <br>        <span class="hljs-keyword">while</span>(f!=<span class="hljs-number">0</span>)&#123;		<span class="hljs-comment">//从叶子结点开始向上回溯，直到根结点</span><br>            --start;		<span class="hljs-comment">//回溯一次start向前指向一个位置</span><br>            <span class="hljs-keyword">if</span>(HT[f].lchild == c)&#123;<br>                cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;	<span class="hljs-comment">//左孩子生成0</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;	<span class="hljs-comment">//又孩子生成1</span><br>            &#125;<br>            c=f; f=HT[f].parent;	<span class="hljs-comment">//继续向上回溯</span><br>        &#125;<span class="hljs-comment">//求出第i个字符的编码</span><br>        HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n - start]; <span class="hljs-comment">//为第i个字符编码分配空间</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);	<span class="hljs-comment">//将求得编码从cd中复制到HC中</span><br>    &#125;<span class="hljs-comment">//for循环结束</span><br>    <br>    <span class="hljs-keyword">delete</span> cd;		<span class="hljs-comment">//s</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">图：<span class="hljs-built_in">G</span>(V,E)<br>	V:顶点(数据元素)的有穷非空集合<br>	E:边的有穷集合<br>	<br>无向图:每条边都是无方向的<br>有向图：每条边都是有方向的<br>完全图：任意两个点都有一条边相连<br>	无向完全图：n个顶点，<span class="hljs-built_in">n</span>(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>条边<br>	有向完全图：n个顶点，<span class="hljs-built_in">n</span>(n<span class="hljs-number">-1</span>)条边<br>	<br>稀疏图：有很少边或弧的图<br>稠密图：有较多边或弧的图<br>网:	边/弧带权的图<br>邻接：有边/弧相连的两个顶点之间的关系<br>		存在(vi,vj),称vi和vj互为邻接点；无先后关系<br>		存在&lt;vi,vj&gt;,称vi邻接到vj，vj邻接于vi；（有序，有先后关系）<br>关联(依附)：边/弧于顶点之间的关系<br>		存在(vi,vj)/&lt;vi,vj&gt;,称该边/弧关联于vi和vj<br>		<br>顶点的度：与该顶点相关联的边的数目，记为TD<br>		在有向图中，顶点的度等于该顶点的入度<span class="hljs-built_in">ID</span>(v)和出度<span class="hljs-built_in">OD</span>(v)之和<br>		<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">有向图中仅一个顶点的入度为0，其余顶点的入度均为1 —— 有向树<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">路径：连续的边构成的顶点序列<br>路径长度：路径上边弧的数目/权值之和<br>回路(环)：第一个顶点和最后一个顶点相同的路径<br>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径<br>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径<br><br>联通图(强连通图)<br>	在图中，若任何两个顶点v,u都存在v到u的路径，则称G为联通图<br>		无向图——联通图<br>		有向图任意两点联通——强联通图<br>		<br>权和网<br>	图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费<br>		带权的图称为网<br>		<br><br>子图：边和顶点为子集<br><br>联通分量	<span class="hljs-string">&#x27;要求顶点&#x27;</span><br>	无向图G的极大联通子图称为G的连通分量<br>	极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中<span class="hljs-string">&#x27;顶点&#x27;</span>加入，子图不在连通<br>    	（一个非连通图内，拆开后有几部分是连通的）<br>    <br>    有向图G的极大强连通子图称为G的强连通分量<br>    极大强连通子图意思是：该子图是G强连通子图，将G的任何不在该子图中<span class="hljs-string">&#x27;顶点&#x27;</span>加入，子图不在强连通<br>    <br>    <br>极小连通子图:该子图是G的连通子图，在该子图中删除任何一条边，该子图不在连通 <span class="hljs-string">&#x27;要求边&#x27;</span><br>    <br>生成树：包含无向图G所有顶点的极小连通子图<br>    生成森林：对非连通图，由各个连通分量的生成树的集合<br></code></pre></td></tr></table></figure>

<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">多对多的逻辑结构<br><br>图没有顺序存储结构，但可以借助二维数组来表示元素间的关系—— 数组表示法（邻接矩阵）<br><br>链式存储结构—— 多重链表—— 邻接表、邻接多重表，十字链表<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;无向图&#x27;</span><br>无向图的邻接矩阵是对称的<br>	顶点i的度=第i行(列)中<span class="hljs-number">1</span>的个数<br>完全图的邻接矩阵中，对角元素为<span class="hljs-number">0</span>，其余为<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/Wzup9jJZVdnBrFe.png" alt="image-20220504193841256"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;有向图&#x27;</span><br>第i行含义：以结点vi为尾的弧 (出度边)<br>第i列含义：以结点vi为头的弧 (入度边)<br>    <br>有向图的邻接矩阵可能不是对称的<br>顶点的度 = 第i行元素之和 + 第i列元素之和    <br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/zTGZ8kWb4D179CF.png" alt="image-20220504193953459"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&#x27;网&#x27;</span> ——有权图<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/ki4dEZPHVe81IbJ.png" alt="image-20220504193422542"></p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵的存储表示：用两个数组分别存储  顶点表  和  邻接矩阵</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767		<span class="hljs-comment">//表示极大值，即∞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100 			<span class="hljs-comment">//最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;	<span class="hljs-comment">//设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;		<span class="hljs-comment">//假设边的权值类型为整形</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    VerTexType vexs[MVNum];		<span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];		<span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;			<span class="hljs-comment">//图的当前点数和边数</span><br>&#125;AMGraph;		<br>		<span class="hljs-comment">///Adjacency Matrix Graph</span><br></code></pre></td></tr></table></figure>

<h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>邻接矩阵表示法创建无向网</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">算法思想<br><span class="hljs-number">1.</span>输入总顶点数和总边数<br><span class="hljs-number">2.</span>依次输入点的信息存入顶点表中<br><span class="hljs-number">3.</span>初始化邻接矩阵，使每个权值初始化为极大值<br><span class="hljs-number">4.</span>构造邻接矩阵<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span></span>&#123;<br>    					<span class="hljs-comment">//采用邻接矩阵表示法，创建无向网G</span><br>	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;	<span class="hljs-comment">//输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)&#123;<br>        cin&gt;&gt;G.vexs[i];		<span class="hljs-comment">//依次输入点的信息</span><br>    &#125;<br>    	<br>    <span class="hljs-comment">//初始化邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.vexnum;++j)&#123;<br>            G.arcs[i][j] = MaxInt;	<span class="hljs-comment">//边的权值均置为极大值</span><br>        &#125;<br>    &#125;<br>    	<br>    <span class="hljs-comment">//构造邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.arcnum;++k)&#123;<br>        cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;  <span class="hljs-comment">//输入一条边所依附的顶点及边的权值</span><br>        <br>        i = <span class="hljs-built_in">LocateVex</span>(G,v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G,v2);		<span class="hljs-comment">//确定v1和v2在G中的位置(顶点表vexs[]下标)</span><br>        <br>        G.arcs[i][j] = w;  		<span class="hljs-comment">// 边&lt;v1,v2&gt;的权值置为w</span><br>        G.arcs[j][i] = G.arcs[i][j]		<span class="hljs-comment">//置&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;权值为w</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>补充算法——查找顶点的下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;G.vexnum;++i)&#123;<br>		<span class="hljs-keyword">if</span>(u==G.vexs[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/OraH5CPNcod8ELh.png" alt="image-20220504231426847"></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">邻接矩阵：<br>优点：直观，简单，好理解<br>	 方便检查任意<br>	 <br>缺点：不利于增加和删除顶点<br>	 浪费空间——存稀疏图，有大量无效元素<br>	 		——对稠密图（特别是完全图）还是合算的<br>	浪费时间——统计稀疏图中一共有多少条边，<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>^<span class="hljs-number">2</span>)</span><br></code></pre></td></tr></table></figure>

<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><img src="https://s2.loli.net/2024/02/24/RdQyF6umpXecsSC.png" alt="image-20220505144317856"></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">无向图：<br>特点：<br>	<span class="hljs-number">1</span>.邻接表不唯一<br>	<span class="hljs-number">2</span>.若无向图中有<span class="hljs-built_in">n</span>个顶点，e条边，则其邻接表需要<span class="hljs-built_in">n</span>个头结点和<span class="hljs-number">2</span>e个表结点，事宜存稀疏图。<br>	<span class="hljs-number">3</span>.无向图顶点的度vi为第i个单链表中的结点数<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">有向图：<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/i5CkE7VyeXARS9g.png" alt="image-20220505235315869"></p>
<h4 id="邻接表建立定义"><a href="#邻接表建立定义" class="headerlink" title="邻接表建立定义"></a>邻接表建立定义</h4><p>顶点的结点结构</p>
<pre><code class="hljs"> data + firstarc
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span>&#123;<br>	VerTexType data;		<span class="hljs-comment">//顶点信息</span><br>	ArcNode *firstarc;		<span class="hljs-comment">//指向第一条依附该顶点的边的指针</span><br>&#125;VNode，AdjList[NVNum];		<span class="hljs-comment">//AdjList 表示邻接表类型</span><br></code></pre></td></tr></table></figure>

<p>边结点结构</p>
<p>​	adjvex + nextarc + info</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100			<span class="hljs-comment">//最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>&#123;		<span class="hljs-comment">//边结点</span><br>    <span class="hljs-type">int</span> adjvex;			<span class="hljs-comment">//该边所指向的顶点的位置</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> *nextarc;	<span class="hljs-comment">//指向的下一条边的指针</span><br>    OtherInfo info;			<span class="hljs-comment">//和边相关的信息 ——权</span><br>&#125;ArcNode;<br></code></pre></td></tr></table></figure>

<p>图的结构定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	AdjList vertices;		<span class="hljs-comment">//顶点集</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;	<span class="hljs-comment">//图的当前顶点数和弧数</span><br>&#125;ALGraph; <br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/CoZmHnP7t9iykG8.png" alt=" "></p>
<h4 id="创建无向网"><a href="#创建无向网" class="headerlink" title="创建无向网"></a>创建无向网</h4><p>算法思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>输入顶点数和总边数<br><span class="hljs-number">2.</span>建立顶点表<br>	依次输入点的信息存入顶点表中<br>	使每个表头结点的指针域初始化为<span class="hljs-literal">NULL</span><br><span class="hljs-number">3.</span>创建邻接表<br>	依次输入每条边依附的两个顶点<br>	<span class="hljs-string">&#x27;确定两个顶点的序号i和j，建立边结点&#x27;</span><br>	<span class="hljs-string">&#x27;将此边结点分别插入到vi和vj对应的两个边链表的头部&#x27;</span><br></code></pre></td></tr></table></figure>

<p>临界表示法创建无向图G</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span></span>&#123;   <br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;	<span class="hljs-comment">//输入总顶点数和边数</span><br>    <br>    <span class="hljs-comment">//输入各点，构造表头结点表</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)&#123;			<br>        cin&gt;&gt;G.vertices[i].data;		<span class="hljs-comment">//输入点值</span><br>        G.vertices[i].firstarc=<span class="hljs-literal">NULL</span>;	<span class="hljs-comment">//初始化表头结点的指针域</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//输入各边，构造邻接表</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.arcnum;++k)&#123;<br>        cin&gt;&gt;v1&gt;&gt;v2;<br>        i = <span class="hljs-built_in">LocateVex</span>(G,v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G,v2);<br>        <br>        p1 = <span class="hljs-keyword">new</span> ArcNode;		<span class="hljs-comment">//生成一个新的边结点*p1</span><br>        p1-&gt;adjvex=j;			<span class="hljs-comment">//邻接点序号为j</span><br>        q<br>        <br>        G.vertices[i].firstarc=p1;	<span class="hljs-comment">//*p1插入顶点vi的边表头部</span><br>        	<span class="hljs-comment">//1.先接上屁股，2在把头拼回去</span><br>        <br>        <span class="hljs-comment">//为无向图，所以i-&gt;j的边建立完成还需建立j-&gt;i的边</span><br>        p2 = <span class="hljs-keyword">new</span> ArcNode;		<br>        p2-&gt;adjvex=i;			<br>        p1-&gt;nextarc = G.vertices[j].firstarc;		<br>        G.vertices[j].firstarc=p2;   <br>    &#125;<span class="hljs-comment">//for</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="邻接表特点"><a href="#邻接表特点" class="headerlink" title="邻接表特点"></a>邻接表特点</h4><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>.方便查找任一顶点的所有<span class="hljs-string">&quot;邻接点&quot;</span><br><span class="hljs-number">2</span>.节约稀疏图的空间<br><span class="hljs-number">3</span>.方便计算任意节点的度<br>	对于无向图：是的<br>	有向图：只能计算出度；构造<span class="hljs-string">&quot;逆邻接表&quot;</span> 方便计算<span class="hljs-string">&quot;入度&quot;</span><br></code></pre></td></tr></table></figure>

<p>邻接矩阵和邻接表的区别</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">对于任一确定的无向图<br>	邻接矩阵是唯一的，但邻接表不唯一<br>空间复杂度<br>	邻接矩阵<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>) 邻接表<span class="hljs-built_in">O</span>(n+e)<br></code></pre></td></tr></table></figure>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p><img src="https://s2.loli.net/2024/02/24/kupao5rOqfG2UiJ.png" alt="image-20220506170015188"></p>
<p>十字链表是有向图的另一种链式存储结构，可以看成是邻接表和逆邻接表结合起来的一链表</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">在顶点节点中增加一个指针域<br>	同时计算入度和出度<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/9pau1L7JDh86UqN.png" alt="image-20220507100258033"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><img src="https://s2.loli.net/2024/02/24/nqDkcUEzlQI7h83.png" alt="image-20220507100941657"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 DFS"></a>深度优先遍历 DFS</h3><p>邻接矩阵实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    cout &lt;&lt; v;	visited[v] = <span class="hljs-literal">true</span>;		<span class="hljs-comment">//访问第v个顶点, visited辅助数组,确保只访问一次</span><br>    <span class="hljs-keyword">for</span>(w = <span class="hljs-number">0</span>; w &lt; G.vexnum; w++)&#123;<br>        <span class="hljs-keyword">if</span>((G.arcs[v][M]!=<span class="hljs-number">0</span>)&amp;&amp;(!visited[w]))&#123;<br>            <span class="hljs-built_in">DFS</span>(G,w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">从图的某一顶点出发,依次访问该结点所有邻接点,在按这些顶点被访问的先后次序访问与他们相邻接的所有未被访问的顶点<br>		<span class="hljs-comment">//类似于层次遍历</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/1NaRXr8OpVAjLdc.png" alt="image-20220507112122764"></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">生成树<span class="hljs-symbol">:</span>所有顶点均连接在一起，但不存在回路的图<br>生成树特点：<br>	<span class="hljs-number">1</span>.顶点个数与图相同<br>	<span class="hljs-number">2</span>.生成树是图的极小连通子图，去掉一条边则非连通<br>	<span class="hljs-number">3</span>.一个有<span class="hljs-built_in">n</span>个顶点的连通图的生成树有<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>条边<br>	<span class="hljs-number">4</span>.在生成树中在加一条边必然形成回路<br>	<span class="hljs-number">5</span>.生成树两个顶点间的路径是唯一的<br>	<br>最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为该网的最小生成树，也叫最小代价生成树<br></code></pre></td></tr></table></figure>

<h3 id="构造最小生成树"><a href="#构造最小生成树" class="headerlink" title="构造最小生成树"></a>构造最小生成树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">MST性质：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)d<br><br>图中n个顶点分为两个集合：<br>	已落在生成树上的顶点集: U<br>	尚未落在生成树上的顶点集：V-U<br>在所有连通U中顶点和V-U中顶点的边中选取<span class="hljs-string">&#x27;权值最小的边&#x27;</span><br></code></pre></td></tr></table></figure>

<h4 id="Prim-普里姆算法"><a href="#Prim-普里姆算法" class="headerlink" title="Prim 普里姆算法"></a>Prim 普里姆算法</h4><p>算法思想</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>.设<span class="hljs-built_in">N</span>=(V,E)是连通网，TE是<span class="hljs-built_in">N</span>上最小生成树中边的集合<br><span class="hljs-number">2</span>.初始令U=&#123;<span class="hljs-symbol">u0</span>&#125;顶点集,(<span class="hljs-symbol">u0</span>属于V)，TE=&#123;&#125;边权为<br><span class="hljs-number">3</span>.在剩余边集中选择一条代价最小的(<span class="hljs-symbol">u0</span>,<span class="hljs-symbol">v0</span>)边 ，(已经在生成树上的点与为在生成树上的点边权最小的边)<br><span class="hljs-number">4</span>.将(<span class="hljs-symbol">u0</span>,<span class="hljs-symbol">v0</span>)并入集合TE，同时<span class="hljs-symbol">v0</span>并入顶点集U<br><span class="hljs-number">5</span>.重复操作直至 U=V为至，则<span class="hljs-built_in">T</span>=(V,TE)为<span class="hljs-built_in">N</span>的最小生成树<br></code></pre></td></tr></table></figure>

<h4 id="kruskal-克鲁斯卡尔算法"><a href="#kruskal-克鲁斯卡尔算法" class="headerlink" title="kruskal 克鲁斯卡尔算法"></a>kruskal 克鲁斯卡尔算法</h4><p><img src="https://s2.loli.net/2024/02/24/c8bMn7I4AZ6w1q9.png" alt="image-20220508203509087"> </p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>问题：在有向网中A点到B点的所有路径的中，寻找一条边权最小的路径，及最短路径</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">单源最短路径——<span class="hljs-keyword">Dijkstra </span>迪杰斯特拉算法<br>所有顶点之间——Floyd 弗洛伊德算法<br></code></pre></td></tr></table></figure>

<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>算法思想</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.初始化：先找出从源点<span class="hljs-built_in">v0</span>到各终点vk的直达路径（<span class="hljs-built_in">v0</span>,vk），即通过一条弧到达的路径<br>		无法到达的点，路径长度设为无穷大<br><span class="hljs-number">2</span>.选择：从这些路径中找出一条长度最短的路径（<span class="hljs-built_in">v0</span>,u)<br><br><span class="hljs-number">3</span>.更新：然后对其余各条路径进行适当调整<br>		若在图中存在弧（u,vk），且（<span class="hljs-built_in">v0</span>,u）+（u，vk）&lt; (<span class="hljs-built_in">v0</span>,vk)<br>		则以路径(<span class="hljs-built_in">v0</span>,u,vk)代替(<span class="hljs-built_in">v0</span>,vk)<br>		<br>		已经找到顶点的集合放在 S集合，为找到路径顶点放在T集合 = V-S<br>在调整之后的各条路径中，再寻找长度最短的路径。..<br></code></pre></td></tr></table></figure>

<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Dijkstra:</span>按路径长度递增次序产生最短路径<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/FyxQdHh1Zpef86w.png" alt="image-20220530221933287"></p>
<p><img src="https://s2.loli.net/2024/02/24/jGtdF3zlaPmKHQR.png" alt="image-20220530222918295"></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>在查找表中找：</p>
<p>​		查找表是由同一类型的数据构成的集合。由于”集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">查找表分为两类：<br>	静态查找表，动态查找表<br>	<br>ASL	： 平均查找长度<br></code></pre></td></tr></table></figure>

<h2 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>​	应用范围：顺序表或线性链表表示的静态查找表</p>
<p>​	表内元素之间无序</p>
<p>数据元素类型定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	KeyType key;	<span class="hljs-comment">//关键字域</span><br>	....			<span class="hljs-comment">//其他域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	ElemType *R;	<span class="hljs-comment">//表基质</span><br>	<span class="hljs-type">int</span> length;		<span class="hljs-comment">//表长</span><br>&#125;SSTable;<br>SSTable ST <span class="hljs-comment">//定义顺序表</span><br></code></pre></td></tr></table></figure>

<p>在顺序表ST中查找值为key的数据元素，从最后一个元素开始比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST ,KeyType Key)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(i=ST.length; i&gt;=<span class="hljs-number">1</span>; --i)&#123;<br>		<span class="hljs-keyword">if</span>(ST.R[i].key == key ) <span class="hljs-keyword">return</span> i;		<span class="hljs-comment">//返回的是下标的位置</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST ,KeyType Key)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(i=ST.length; ST.R[i].key != key; --i)<br>        <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;		<span class="hljs-comment">//未找到元素从这里结束</span><br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种算法每次都需要比较两次，</p>
<p>可以引入“监视哨”（将关键字key存入表头），从而免去没一步都需要检查是否查找完毕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//设置监视哨的顺序查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST ,KeyType Key)</span></span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-keyword">for</span>(i=ST.length; ST.R[i].key != key; --i);	<span class="hljs-comment">//此循环体没有语句</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ST.length较大时，此改进可以使查找时间缩短一半<br><br><span class="hljs-string">&#x27;时间复杂度：（n+1）/2&#x27;</span>	查找概率相等<br>空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/TYwmCyPUj9sqON8.png" alt="image-20220605113121244"></p>
<p>优点：算法简单，逻辑次序无要求，不同储存结构都适用</p>
<p>缺点：ASL太长，时间效率太低</p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>​	——二分法 </p>
<p>元素是有序的</p>
<p>折半查找：每次将待查找记录所在区间缩小一半</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">初始：令low=<span class="hljs-number">1</span>， high = n; mid = (low+high)/<span class="hljs-number">2</span> 的底<br><br>mid = (low+high)/<span class="hljs-number">2</span><br>key&lt;mid 则：high = mid <span class="hljs-number">-1</span><br>key&gt;mid 则：low = mid + <span class="hljs-number">1</span><br>key == mid ,找到<br><br>high &lt; low ,查找失败<br></code></pre></td></tr></table></figure>

<p>二分法，折半查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, keyType key)</span></span>&#123;<br>    low = <span class="hljs-number">1</span>; high = ST.length;	<span class="hljs-comment">//置区间初值</span><br>    <br>    <span class="hljs-keyword">while</span> (low &lt;= high)&#123;	<br>        mid = (low + high)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span>(ST.R[mid].key == key)&#123;<br>            <span class="hljs-keyword">return</span> mid;		<span class="hljs-comment">//查找成功</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key)&#123;	<span class="hljs-comment">//缩小查找区间</span><br>            high = mid <span class="hljs-number">-1</span>;	<span class="hljs-comment">//在前半区继续查找</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            low = mid +<span class="hljs-number">1</span>; 	<span class="hljs-comment">//在后半取继续查找</span><br>        &#125;       <br>    &#125;<span class="hljs-comment">//循环结束条件：1.查找成功 2.low &gt;high</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<span class="hljs-comment">//不存在查找元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>递归算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, keyType key， <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<span class="hljs-comment">//找不到时返回0</span><br>    mid = (low + high)/<span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">if</span>(key = ST.R[mid].key) <span class="hljs-keyword">return</span> mid;	<span class="hljs-comment">//查询成功 返回值</span><br>    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key)&#123;<br>        high = mid <span class="hljs-number">-1</span>;	<span class="hljs-comment">//缩小查找区间</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST, key, low, high);	<span class="hljs-comment">//在前半区查找</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        low = mid + <span class="hljs-number">1</span>;	<span class="hljs-comment">//缩小查找区间</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST, key, low, high);	<span class="hljs-comment">//在后半区查找</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/deOR5ojfVENrZtT.png" alt="image-20220605120459531"></p>
<p><img src="https://s2.loli.net/2024/02/24/mS1MZ9BDVOtrHPe.png" alt="image-20220605122150613"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">ASL = lo<span class="hljs-name">g2</span><span class="hljs-comment">(n+1)</span> - <span class="hljs-number">1</span><br>优点：效率比较高 <br>缺点：只适用于有序表，且限于顺序储存结构（对线性链表无效）<br></code></pre></td></tr></table></figure>

<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>索引顺序表的查找</p>
<p>条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>将表分成几块，且表或者有序， 或者<span class="hljs-string">&quot;分块有序&quot;</span>(块内无序，块间有序)<br>    若i&lt;j,则第j块中所有记录的关键字均大于第i块中的最大关键字<br><br><span class="hljs-number">2.</span>建立索引表<br>    （每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）<br>    <br>查找过程：先确定待查记录所在块，再在块内查找<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/dzVOjlTKtiRgMsP.png" alt="image-20220605124023172"></p>
<p><img src="https://s2.loli.net/2024/02/24/tw3iJ5NlASLhekE.png" alt="image-20220605124255146"></p>
<h2 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h2><p>当表插入、删除操作频繁操作时，为维护表的有序性，需要移动表中记录，</p>
<p>改用动态查找表——</p>
<p>表结构在查找过程中动态生成</p>
<p>对于给定key 若表中存在，则成功返回，否则，插入关键字等于key的记录</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树：又称为二叉搜索树，二叉查找树</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.若其左子树非空，则左子树上所有结点的值均小于根结点的值<br>2.若其右子树非空，则右子树上所有结点的值均大于根节点的值<br>3.其左右子树本身又各是一颗二叉排序树<br></code></pre></td></tr></table></figure>

<p>存储结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>	KeyType key;<br>	InfoType otherinfo;<br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span>&#123;<br>    ElemType data;		<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;	<span class="hljs-comment">//左右孩子指针</span><br>&#125;BSTNode, *BSTree;<br><br>BSTree T;	<span class="hljs-comment">//定义二叉排序树</span><br></code></pre></td></tr></table></figure>

<p>算法思想：递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree, KeyType key)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((!T)||key==T-&gt;data.key) <span class="hljs-keyword">return</span> T;	<span class="hljs-comment">//找到返回</span><br>    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild ,key);	<span class="hljs-comment">//在左子树中继续查找</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild ,key);	<span class="hljs-comment">//在右子树中继续查找</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>二叉排序的查找</p>
<p>查找效率看树的深度有关</p>
<p><img src="https://s2.loli.net/2024/02/24/LEtnxGCUqg6Iy4o.png" alt="image-20220607140344084"></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>算法思想</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">若二叉排序树为空，则插入结点作为根结点插入到空树中<br>否则，继续在其左右子树上查找<br>	树中已有，不再插入<br>	树中没有<br>		查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或者右孩子<br></code></pre></td></tr></table></figure>



<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">一个无序序列可以通过构造二叉排序树从而变成一个有序序列<br>	插入的结点均为叶子结点，故无需移动其他结点<br>	<br>	但：关键字的输入顺序不同，建立的二叉树不同<br></code></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">注意的问题：<br>	1.将因删除结点而断开的二叉链表重新链接起来<br>	2.防止重新链接后树的高度增加<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.删除结点是叶子结点：直接删除该结点<br>2.被删除结点只有左子树或者只有右子树，则用其左子树或者右子树替换他<br>3.被删除的结点既有左子树又有右子树<br>	用其中序前驱值替换，在删除前驱结点（采用递归）<br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/02/24/qzwBTPu3s6oyfSc.png" alt="image-20220607152918132" style="zoom:25%;" />

<img src="https://s2.loli.net/2024/02/24/Fae6RslHujzrP4J.png" alt="image-20220607153008800" style="zoom:25%;" />

<img src="https://s2.loli.net/2024/02/24/LcC1Qrok2m4j98w.png" alt="image-20220607153531347" style="zoom:44%;" />

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>解决形态不均衡的二叉排序树的查找效率，做平衡化处理，使其称为平衡二叉树</p>
<p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">平衡二叉树  AVL树<br>一颗平衡二叉树或者空树，或是具有下列性质的二叉排序树<br>	<span class="hljs-number">1.</span>左子树与右子树高度之差的绝对值小于等于<span class="hljs-number">1</span><br>	<span class="hljs-number">2.</span>左子树和右子树也是平衡二叉排序树<br>	<br>为了方便起见， 给每个结点附加一个数字，给出该结点左子树与右子树的高度差 ——平衡因子BF<br>	平衡因子 = 结点左子树的高度 - 结点右子树的高度 （<span class="hljs-number">-1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">当我们在一个平衡二叉排序树上插入一个结点，可能会导致失衡<br></code></pre></td></tr></table></figure>

<h4 id="平衡调整"><a href="#平衡调整" class="headerlink" title="平衡调整"></a>平衡调整</h4><p><img src="https://s2.loli.net/2024/02/24/7FOLdp3sY9ySBt8.png" alt="image-20220607161143042"></p>
<p><img src="https://s2.loli.net/2024/02/24/3Xt1UGZ97Ty6JVP.png" alt="image-20220607161209790"></p>
<p>调整原则</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.降低高度<br>2.保持二叉树排序性质 （老二作根）<br></code></pre></td></tr></table></figure>



<h2 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h2><p>基本思想：记录存储位置与关键字之间的关系</p>
<p>散列函数——Hash</p>
<p>优点：查找效率高 O（1），空间效率低</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">散列方法：<br>	选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放，查找时，由同一个函数对给定值计算地址<br>	将k与地址单元中元素是关键码进行比，确定查找是否成功<br>	<br>散列函数：散列方法中使用的转化函数<br>散列表：按上述方法构成的表<span class="hljs-comment">(数组)</span><br><br>冲突：不同的关键码映射到同一个散列地址<br>		key<span class="hljs-number">1</span> != key<span class="hljs-number">2</span>  但 H<span class="hljs-comment">(key1)</span> = H<span class="hljs-comment">(key2)</span><br></code></pre></td></tr></table></figure>

<h3 id="散列函数构造"><a href="#散列函数构造" class="headerlink" title="散列函数构造"></a>散列函数构造</h3><p>考虑因素</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.执行速度<br>2.关键字长度<br>3.散列表的大小<br>4.关键字的分布频率<br>5.查找频率<br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">要求：<span class="hljs-number">1</span>.<span class="hljs-built_in">n</span>个数据原仅占用<span class="hljs-built_in">n</span>个地址，虽然散列查找是以空间换时间，但仍希望散列的空间尽量小<br>	<span class="hljs-number">2</span>.无论用什么方法存储，目的都是尽量均匀的存放元素，以避免冲突<br>	<br>构造方法：<br>	<span class="hljs-number">1</span>.直接定值法 <span class="hljs-number">5</span>.除留余数法<br></code></pre></td></tr></table></figure>

<h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hash</span><span class="hljs-params">(key)</span></span> = a*key + <span class="hljs-selector-tag">b</span><br>优点：key的线性函数为散列地址，不会产生冲突<br>缺点：要占用连续地址空间，空间效率低<br></code></pre></td></tr></table></figure>

<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(key)</span></span> = key mod <span class="hljs-selector-tag">p</span> (p是一个整数)<br>关键：如何选取合适的p？<br>技巧：设表长为m，取p&lt;=m且为质数<br></code></pre></td></tr></table></figure>

<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">有冲突时就去寻找下一个空的散列地址值，只要散列列表足够大，肯定能找到<br>	除留余数法 ： <span class="hljs-string">&#x27;Hi = (Hash(key)+di) mod m  di 为增量序列&#x27;</span><br>	<br>	di确定常用方法：	<br> q<br>	<span class="hljs-number">2.</span>二探测法：di为 <span class="hljs-number">1</span>^<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>^<span class="hljs-number">2</span>, <span class="hljs-number">2</span>^<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>^<span class="hljs-number">2</span>,...二次序列<br>	<span class="hljs-number">3.</span>伪随机探测法：di为伪随机数序列<br></code></pre></td></tr></table></figure>

<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">基本思想：散列地址相同的记录成一单链表<br>m个散列表地址就设m个单链表，然后用一个数组将m个单链表的表头指针储存起来<br></code></pre></td></tr></table></figure>

<p>建立步骤</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>.取关键字<span class="hljs-keyword">key</span> ，计算其散列函数值（地址）若该地址对应链表为空，则将元素插入链表，否则执行<span class="hljs-number">2</span><br><span class="hljs-number">2</span>，根据冲突处理，计算关键字<span class="hljs-keyword">key</span>的下一个存储地址，若该地址对应链表不为空，则利用链表前插/或后插<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">优点：非同义词不会冲突，无聚集现象<br>链表上结点空间动态申请，更适合于表长不确定情况<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/SeoREfLG3D76Nzv.png" alt="image-20220608120351760"></p>
<p><img src="https://s2.loli.net/2024/02/24/Fe9tDahKXl5nC7B.png" alt="image-20220608120403125"></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">插入排序：直接插入排序，折半插入排序，希尔排序<br>交换排序：冒泡排序，快速排序<br>选择排序：简单选择排序，堆排序<br>归并排序：2-路归并排序<br>基数排序<br></code></pre></td></tr></table></figure>

<p>储存结构——记录序列以顺序表存储</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;		<span class="hljs-comment">//定义每个数据元素的结构</span><br>	KeyType key;<br>	InfoType  otherinfo;<br>&#125;RedType;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;		<span class="hljs-comment">//定义顺序表的结构</span><br>	RedType r[MAXSIZE + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span> length;<br>&#125;SqList<br></code></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>前半段有序，后半段无序</p>
<p>寻找插入位置</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">顺序法确定 	—— 直接插入排序<br>二分法确定	—— 二分插入排序<br>缩小增量多遍插入排序		—— 希尔排序<br></code></pre></td></tr></table></figure>

<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>复制插入元素<br>	x=a[i]<br><span class="hljs-number">2.</span>记录后移，查找插入位置<br>    <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;a[j];j--)&#123;<br>        a[j+<span class="hljs-number">1</span>] = a[i];		<span class="hljs-comment">//向后移动</span><br>    &#125;<br><span class="hljs-number">3.</span>插入到正确位置 a[j+<span class="hljs-number">1</span>] = x;<br></code></pre></td></tr></table></figure>

<p>使用哨兵 </p>
<p>​	顺序表0号位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>复制为哨兵 L.r[<span class="hljs-number">0</span>] = L.r[i]<br><span class="hljs-number">2.</span>记录后移，查询插入位置<br>	<span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;L.r[<span class="hljs-number">0</span>].key&lt;L.r[j];j--)&#123;<br>		L.r[j+<span class="hljs-number">1</span>] = L.r[j];<br>    &#125;<br><span class="hljs-number">3.</span>插入到正确位置<br>    L.r[j+<span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=L.lengthl;++i)&#123;<br>		<span class="hljs-keyword">if</span>(L.r[i].key &lt; L.r[i<span class="hljs-number">-1</span>].key)&#123;<br>            L.r[<span class="hljs-number">0</span>] = L.r[i]		<span class="hljs-comment">//哨兵</span><br>			<span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;L.r[<span class="hljs-number">0</span>].key&lt;L.r[j];j--)&#123;	<span class="hljs-comment">//寻找移动</span><br>				L.r[j+<span class="hljs-number">1</span>] = L.r[j];<br>    		&#125;	<br>            L.r[j+<span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];		<span class="hljs-comment">//插入</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">原始数据越接近有序，排序速度越块<br>最坏情况下	<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)	最后情况<span class="hljs-built_in">O</span>(n)	平均情况<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)<br><br>空间复制度 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 只需要一个哨兵<br></code></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p><img src="https://s2.loli.net/2024/02/24/gZxR3h7f6MqVXvk.png" alt="image-20220610151850605"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">改进了查找sulv，但仍需移动，时间f<br></code></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>定义增量Dk，对每个Dk-间隔进行插入排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span> <span class="hljs-params">(SQlist &amp;L, <span class="hljs-type">int</span> dlta[], <span class="hljs-type">int</span> t)</span></span>&#123;<br>	<span class="hljs-comment">//按增量序列dlta[0..t-1]对顺序表L作希尔排序</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;t; ++k)<br>        <span class="hljs-built_in">Shelllnsert</span>(L, dlta[k]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shelllnsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dk)</span></span>&#123;	<span class="hljs-comment">//步长为dk的插入排序</span><br>    <span class="hljs-keyword">for</span>(i=dk+<span class="hljs-number">1</span>; i&lt;=L.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(r[i].key &lt; r[i-dk].key)&#123;<br>            r[<span class="hljs-number">0</span>]=r[i];<br>            <span class="hljs-keyword">for</span>(j=i-dk; j&gt;<span class="hljs-number">0</span> &amp;&amp; (r[<span class="hljs-number">0</span>].key &lt; r[j].key); j=j-dk)<br>                r[j+dk] = r[j];<br>            r[j+dk] = r[<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">希尔排序是一种不稳定的排序算法<br>	增量序列，最后一位必须为0<br></code></pre></td></tr></table></figure>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span>个记录，总共需要<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>趟<br>第m趟需要比较<span class="hljs-built_in">n</span>-m次<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n<span class="hljs-number">-1</span>; m++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n-i; j++)<br>            <span class="hljs-keyword">if</span>(r[j].key &gt; r[j+<span class="hljs-number">1</span>].key)&#123;<br>                x=r[j];<br>                r[j]=r[j+<span class="hljs-number">1</span>]<br>				r[j+<span class="hljs-number">1</span>] = x<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">优点：每趟结束，选最大放倒最后面<br>时间复杂度：<br>	最好正序 比较<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>，移动<span class="hljs-number">0</span>	<span class="hljs-built_in">n</span>(<span class="hljs-comment"></span>)<br>	最坏 O(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>任取一个元素为中心<br><span class="hljs-number">2.</span>所以比他小的元素前放，比它大的元素一律后放，形成左右两个子表<br><span class="hljs-number">3.</span>对各子表重新选择中心并依此规则调整<br><span class="hljs-number">4.</span>直到每个子表的元素只剩一个<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1.每一趟的子表的形成是采用从两头向中间交替式逼近法<br>2,每趟中对各子表的操作都相似，可采用递归算法<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">QSort</span>(L,<span class="hljs-number">1</span>,L.length);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SQList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;	<span class="hljs-comment">//长度大于1 (子表中元素只剩一个时停止)</span><br>        pivotloc = <span class="hljs-built_in">Partition</span>(L,low,high);<br>        <span class="hljs-comment">//将线性表分成两部分，pivotloc为枢轴元素排好序位置 （中间值）</span><br>        <br>        <span class="hljs-built_in">QSort</span>(L,low,pivotloc<span class="hljs-number">-1</span>);	<span class="hljs-comment">//对低子表递归排序</span><br>        <span class="hljs-built_in">QSort</span>(L,pivotloc+<span class="hljs-number">1</span>, high);	<span class="hljs-comment">//对高子表递归排序</span><br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span> <span class="hljs-params">(SQList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    L.r[<span class="hljs-number">0</span>] = L.r[low];  <span class="hljs-comment">//哨兵（选第一个元素作为枢轴 填入哨兵位置）</span><br>    pivotkey = L.r[low].key;	<span class="hljs-comment">//中间值</span><br>    <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>		<span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) --high;<br>        L.r[low] = L.r[high];	<span class="hljs-comment">//找一个大的往前放</span><br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) ++low;<br>        L.r[high] = L.r[low];	<span class="hljs-comment">//找一个小的往后放</span><br>    &#125;	<span class="hljs-comment">//大小交替进行，直至low = high</span><br>    L.r[low] = L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//枢轴填入</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">时间复杂度	： <span class="hljs-built_in">O</span>(nlog2n)<br><br>空间复杂度：快速排序不是原地排序<br>	使用了递归，需要调用栈的支持，栈的长度取决于调用的深度<br>	平均情况下：需要<span class="hljs-built_in">O</span>(logn) 最坏<span class="hljs-built_in">o</span>(n)<br>	<br>快速排序不适合 原本有序的排列方式<br><br>输入数据次序越乱，快排越快，快排不是自然排序方法<br></code></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">在待排序的数据中选出最大（小）的元素放在其最终的位置<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/02/24/tIB3gq9MVN6n4EO.png" alt="image-20220612174328041"></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">时间复杂度： <span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)<br><br>简单选择排序是不稳定排序<br></code></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://s2.loli.net/2024/02/24/NLt3nUiXRkJrzj7.png" alt="image-20220612184403867"></p>
<p>堆顶元素拿走之后， 调整剩余元素使其成为堆</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">小根堆：<br>输出根并以最后一个元素代替之，比较其左右孩子的大小，并与其中较小者交换，直至到叶子结点<br></code></pre></td></tr></table></figure>



<p><img src="https://s2.loli.net/2024/02/24/anBkNv1zrGPJ2Eb.png" alt="image-20220612192544910"></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">时间复杂度 <br>	一次重新堆化时间不超过 <span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">logn</span>)</span><br>	<span class="hljs-variable">n</span>-<span class="hljs-number">1</span>次循环所需时间不超过<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>)</span><br>	 <span class="hljs-function"><span class="hljs-title">Tw</span>(<span class="hljs-variable">n</span>) = <span class="hljs-title">O</span>(<span class="hljs-variable">logn</span>) + <span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>) = <span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>)</span><br>	 与数据记录顺序无关， 最好最坏时间复杂度一样<br>	 <br>	 空间复杂度 ：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-number">1</span>)</span><br>	 不稳定排序方式<br></code></pre></td></tr></table></figure>

<h2 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h2><p><img src="https://s2.loli.net/2024/02/24/ukEmTn96axJCvsL.png" alt="image-20220612193502836"></p>
]]></content>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
